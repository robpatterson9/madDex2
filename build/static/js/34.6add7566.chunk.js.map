{"version":3,"sources":["views/Nft/market/index.tsx","state/nftMarket/hooks.ts"],"names":["Home","lazy","NftProfile","Collection","Collections","Market","account","useWeb3React","initializationState","useGetNFTInitializationState","useFetchCollections","NFTMarketInitializationState","INITIALIZED","exact","path","nftsBaseUrl","to","pancakeBunniesAddress","toLowerCase","dispatch","useAppDispatch","useEffect","fetchCollections","fetchNftsFromCollections","useFetchByBunnyId","bunnyId","isFetchingMoreNfts","useSelector","state","nftMarket","data","latestFetchAt","existingBunniesInState","useGetAllBunniesByBunnyId","existingTokenIds","map","nft","tokenId","firstBunny","length","existingMetadata","useMemo","name","description","collection","collectionName","image","fetchMorePancakeBunnies","orderDirection","fetchNftsByBunnyId","useGetCollections","collections","useGetCollection","collectionAddress","checksummedCollectionAddress","isAddress","useNftsFromCollection","nfts","filter","attributes","value","marketData","isTradable","useUserNfts","user"],"mappings":"8HAAA,4EAQMA,EAAOC,gBAAK,kBAAM,yDAClBC,EAAaD,gBAAK,kBAAM,gEACxBE,EAAaF,gBAAK,kBAAM,mCACxBG,EAAcH,gBAAK,kBAAM,mCAkChBI,UAhCA,WACb,IAAQC,EAAYC,cAAZD,QACFE,EAAsBC,cAI5B,OAFAC,cAEIF,IAAwBG,IAA6BC,YAChD,cAAC,IAAD,IAIP,qCACE,cAAC,IAAD,CAAOC,OAAK,EAACC,KAAMC,IAAnB,SACE,cAACf,EAAD,MAEF,eAAC,IAAD,CAAOa,OAAK,EAACC,KAAI,UAAKC,IAAL,gBAAjB,UACE,cAAC,IAAD,CAAUC,GAAE,UAAKD,IAAL,wBAAgCE,OAC5C,cAACb,EAAD,OAEF,cAAC,IAAD,CAAOU,KAAI,UAAKC,IAAL,mCAAX,SACE,cAACZ,EAAD,MAEF,cAAC,IAAD,CAAOW,KAAI,UAAKC,IAAL,6BAAX,SACE,cAACb,EAAD,MAEF,cAAC,IAAD,CAAOW,OAAK,EAACC,KAAI,UAAKC,IAAL,YAAjB,SACE,cAAC,IAAD,CAAUC,GAAE,UAAKD,IAAL,qBAAmC,OAAPT,QAAO,IAAPA,OAAA,EAAAA,EAASY,gBAAiB,a,iCCvC1E,8UAUaR,EAAsB,WACjC,IAAMS,EAAWC,cACjBC,qBAAU,WACRF,EAASG,eACTH,EAASI,YAAyBN,QACjC,CAACE,KAKOK,EAAoB,SAACC,GAChC,IAAMN,EAAWC,cAEXM,EAAqBC,aAAY,SAACC,GAAD,OAAkBA,EAAMC,UAAUC,KAAKJ,sBACxEK,EAAgBJ,aAAY,SAACC,GAAD,OAAkBA,EAAMC,UAAUC,KAAKC,iBAInEC,EAAyBC,EAA0BR,GACnDS,EAAmBF,EAAyBA,EAAuBG,KAAI,SAACC,GAAD,OAASA,EAAIC,WAAW,GAE/FC,EAAaN,EAAuBO,OAAS,EAAIP,EAAuB,GAAK,KAG7EQ,EAAmBC,mBAAQ,WAC/B,OAAOH,EACH,CACEI,KAAMJ,EAAWI,KACjBC,YAAaL,EAAWK,YACxBC,WAAY,CAAEF,KAAMJ,EAAWO,gBAC/BC,MAAOR,EAAWQ,OAEpB,OACH,CAACR,IAKJ,MAAO,CAAEZ,qBAAoBK,gBAAegB,wBAHZ,SAACC,GAC/B7B,EAAS8B,YAAmB,CAAExB,UAASS,mBAAkBM,mBAAkBQ,uBAyBlEE,EAAoB,WAC/B,OAAOvB,aAAY,SAACC,GAAD,OAAkBA,EAAMC,UAAUC,KAAKqB,gBAG/CC,EAAmB,SAACC,GAC/B,IAAMC,EAA+BC,YAAUF,IAAsB,GAErE,OADoBH,IACDI,IAGRE,EAAwB,SAACH,GACpC,IAAMC,EAA+BC,YAAUF,IAAsB,GAErE,OADyB1B,aAAY,SAACC,GAAD,OAAkBA,EAAMC,UAAUC,KAAK2B,KAAKH,OAItErB,EAA4B,SAACR,GACxC,IAAMgC,EAAmB9B,aAAY,SAACC,GAAD,OAAkBA,EAAMC,UAAUC,KAAK2B,KAAKxC,QACjF,OAAOwC,EAAOA,EAAKC,QAAO,SAACtB,GAAD,OAASA,EAAIuB,WAAW,GAAGC,QAAUnC,GAAWW,EAAIyB,WAAWC,cAAc,IAG5FrD,EAA+B,WAC1C,OAAOkB,aAAY,SAACC,GAAD,OAAkBA,EAAMC,UAAUrB,wBAG1CuD,EAAc,WACzB,OAAOpC,aAAY,SAACC,GAAD,OAAkBA,EAAMC,UAAUC,KAAKkC","file":"static/js/34.6add7566.chunk.js","sourcesContent":["import React, { lazy } from 'react'\nimport { Redirect, Route } from 'react-router-dom'\nimport { useWeb3React } from '@web3-react/core'\nimport { useFetchCollections, useGetNFTInitializationState } from 'state/nftMarket/hooks'\nimport PageLoader from 'components/Loader/PageLoader'\nimport { NFTMarketInitializationState } from 'state/nftMarket/types'\nimport { nftsBaseUrl, pancakeBunniesAddress } from './constants'\n\nconst Home = lazy(() => import('./Home'))\nconst NftProfile = lazy(() => import('./Profile'))\nconst Collection = lazy(() => import('./Collection'))\nconst Collections = lazy(() => import('./Collections'))\n\nconst Market = () => {\n  const { account } = useWeb3React()\n  const initializationState = useGetNFTInitializationState()\n\n  useFetchCollections()\n\n  if (initializationState !== NFTMarketInitializationState.INITIALIZED) {\n    return <PageLoader />\n  }\n\n  return (\n    <>\n      <Route exact path={nftsBaseUrl}>\n        <Home />\n      </Route>\n      <Route exact path={`${nftsBaseUrl}/collections`}>\n        <Redirect to={`${nftsBaseUrl}/collections/${pancakeBunniesAddress}`} />\n        <Collections />\n      </Route>\n      <Route path={`${nftsBaseUrl}/collections/:collectionAddress`}>\n        <Collection />\n      </Route>\n      <Route path={`${nftsBaseUrl}/profile/:accountAddress?`}>\n        <NftProfile />\n      </Route>\n      <Route exact path={`${nftsBaseUrl}/profile`}>\n        <Redirect to={`${nftsBaseUrl}/profile/${account?.toLowerCase() || ''}`} />\n      </Route>\n    </>\n  )\n}\n\nexport default Market\n","import { useEffect, useMemo } from 'react'\nimport { useSelector } from 'react-redux'\nimport { useAppDispatch } from 'state'\nimport { pancakeBunniesAddress } from 'views/Nft/market/constants'\nimport { isAddress } from 'utils'\nimport useRefresh from 'hooks/useRefresh'\nimport { fetchCollections, fetchNftsByBunnyId, fetchNftsFromCollections, updateNftTokensData } from './reducer'\nimport { State } from '../types'\nimport { NftToken, UserNftsState } from './types'\n\nexport const useFetchCollections = () => {\n  const dispatch = useAppDispatch()\n  useEffect(() => {\n    dispatch(fetchCollections())\n    dispatch(fetchNftsFromCollections(pancakeBunniesAddress))\n  }, [dispatch])\n}\n\n// Returns a function that fetches more NFTs when called and puts them into redux state.\n// Also returns loading flag and time of latest successful fetch\nexport const useFetchByBunnyId = (bunnyId: string) => {\n  const dispatch = useAppDispatch()\n\n  const isFetchingMoreNfts = useSelector((state: State) => state.nftMarket.data.isFetchingMoreNfts)\n  const latestFetchAt = useSelector((state: State) => state.nftMarket.data.latestFetchAt)\n\n  // Extra guard in case market data shifts\n  // we don't wanna fetch same tokens multiple times\n  const existingBunniesInState = useGetAllBunniesByBunnyId(bunnyId)\n  const existingTokenIds = existingBunniesInState ? existingBunniesInState.map((nft) => nft.tokenId) : []\n\n  const firstBunny = existingBunniesInState.length > 0 ? existingBunniesInState[0] : null\n\n  // If we already have NFT with this bunny id in state - we can reuse its metadata without making API request\n  const existingMetadata = useMemo(() => {\n    return firstBunny\n      ? {\n          name: firstBunny.name,\n          description: firstBunny.description,\n          collection: { name: firstBunny.collectionName },\n          image: firstBunny.image,\n        }\n      : null\n  }, [firstBunny])\n\n  const fetchMorePancakeBunnies = (orderDirection: 'asc' | 'desc') => {\n    dispatch(fetchNftsByBunnyId({ bunnyId, existingTokenIds, existingMetadata, orderDirection }))\n  }\n  return { isFetchingMoreNfts, latestFetchAt, fetchMorePancakeBunnies }\n}\n\n// This hook gets all token ids stored in redux and periodically checks subgraph in case the data we have is staled\n// e.g. NFT gets sold - must be changed form isTradable: true to isTradable: false\nexport const useUpdateNftInfo = (collectionAddress: string) => {\n  const dispatch = useAppDispatch()\n  const { fastRefresh } = useRefresh()\n\n  const lastUpdateAt = useSelector((state: State) => state.nftMarket.data.lastUpdateAt)\n  const isFetchingMoreNfts = useSelector((state: State) => state.nftMarket.data.isFetchingMoreNfts)\n\n  const existingNfts = useNftsFromCollection(collectionAddress)\n\n  useEffect(() => {\n    const msSinceLastUpdate = Date.now() - lastUpdateAt\n    const existingTokenIds = existingNfts ? existingNfts.map((nft) => nft.tokenId) : []\n    if (msSinceLastUpdate > 10000 && !isFetchingMoreNfts) {\n      dispatch(updateNftTokensData({ collectionAddress, existingTokenIds }))\n    }\n  }, [dispatch, fastRefresh, collectionAddress, existingNfts, lastUpdateAt, isFetchingMoreNfts])\n}\n\nexport const useGetCollections = () => {\n  return useSelector((state: State) => state.nftMarket.data.collections)\n}\n\nexport const useGetCollection = (collectionAddress: string) => {\n  const checksummedCollectionAddress = isAddress(collectionAddress) || ''\n  const collections = useGetCollections()\n  return collections[checksummedCollectionAddress]\n}\n\nexport const useNftsFromCollection = (collectionAddress: string) => {\n  const checksummedCollectionAddress = isAddress(collectionAddress) || ''\n  const nfts: NftToken[] = useSelector((state: State) => state.nftMarket.data.nfts[checksummedCollectionAddress])\n  return nfts\n}\n\nexport const useGetAllBunniesByBunnyId = (bunnyId: string) => {\n  const nfts: NftToken[] = useSelector((state: State) => state.nftMarket.data.nfts[pancakeBunniesAddress])\n  return nfts ? nfts.filter((nft) => nft.attributes[0].value === bunnyId && nft.marketData.isTradable) : []\n}\n\nexport const useGetNFTInitializationState = () => {\n  return useSelector((state: State) => state.nftMarket.initializationState)\n}\n\nexport const useUserNfts = (): UserNftsState => {\n  return useSelector((state: State) => state.nftMarket.data.user)\n}\n"],"sourceRoot":""}