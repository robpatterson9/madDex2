{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$();\n\nimport { useEffect, useMemo } from 'react';\nimport { useSelector } from 'react-redux';\nimport { useAppDispatch } from 'state';\nimport { pancakeBunniesAddress } from 'views/Nft/market/constants';\nimport { isAddress } from 'utils';\nimport useRefresh from 'hooks/useRefresh';\nimport { fetchCollections, fetchNftsByBunnyId, fetchNftsFromCollections, updateNftTokensData } from './reducer';\nexport const useFetchCollections = () => {\n  _s();\n\n  const dispatch = useAppDispatch();\n  useEffect(() => {\n    dispatch(fetchCollections());\n    dispatch(fetchNftsFromCollections(pancakeBunniesAddress));\n  }, [dispatch]);\n}; // Returns a function that fetches more NFTs when called and puts them into redux state.\n// Also returns loading flag and time of latest successful fetch\n\n_s(useFetchCollections, \"DKdeqxp2QYw2p6z8/ErYMRK/Ubo=\", false, function () {\n  return [useAppDispatch];\n});\n\nexport const useFetchByBunnyId = bunnyId => {\n  _s2();\n\n  const dispatch = useAppDispatch();\n  const isFetchingMoreNfts = useSelector(state => state.nftMarket.data.isFetchingMoreNfts);\n  const latestFetchAt = useSelector(state => state.nftMarket.data.latestFetchAt); // Extra guard in case market data shifts\n  // we don't wanna fetch same tokens multiple times\n\n  const existingBunniesInState = useGetAllBunniesByBunnyId(bunnyId);\n  const existingTokenIds = existingBunniesInState ? existingBunniesInState.map(nft => nft.tokenId) : [];\n  const firstBunny = existingBunniesInState.length > 0 ? existingBunniesInState[0] : null; // If we already have NFT with this bunny id in state - we can reuse its metadata without making API request\n\n  const existingMetadata = useMemo(() => {\n    return firstBunny ? {\n      name: firstBunny.name,\n      description: firstBunny.description,\n      collection: {\n        name: firstBunny.collectionName\n      },\n      image: firstBunny.image\n    } : null;\n  }, [firstBunny]);\n\n  const fetchMorePancakeBunnies = orderDirection => {\n    dispatch(fetchNftsByBunnyId({\n      bunnyId,\n      existingTokenIds,\n      existingMetadata,\n      orderDirection\n    }));\n  };\n\n  return {\n    isFetchingMoreNfts,\n    latestFetchAt,\n    fetchMorePancakeBunnies\n  };\n}; // This hook gets all token ids stored in redux and periodically checks subgraph in case the data we have is staled\n// e.g. NFT gets sold - must be changed form isTradable: true to isTradable: false\n\n_s2(useFetchByBunnyId, \"UJBWvTWnl45eOBWR7+pO7PiDehQ=\", false, function () {\n  return [useAppDispatch, useSelector, useSelector, useGetAllBunniesByBunnyId];\n});\n\nexport const useUpdateNftInfo = collectionAddress => {\n  _s3();\n\n  const dispatch = useAppDispatch();\n  const {\n    fastRefresh\n  } = useRefresh();\n  const lastUpdateAt = useSelector(state => state.nftMarket.data.lastUpdateAt);\n  const isFetchingMoreNfts = useSelector(state => state.nftMarket.data.isFetchingMoreNfts);\n  const existingNfts = useNftsFromCollection(collectionAddress);\n  useEffect(() => {\n    const msSinceLastUpdate = Date.now() - lastUpdateAt;\n    const existingTokenIds = existingNfts ? existingNfts.map(nft => nft.tokenId) : [];\n\n    if (msSinceLastUpdate > 10000 && !isFetchingMoreNfts) {\n      dispatch(updateNftTokensData({\n        collectionAddress,\n        existingTokenIds\n      }));\n    }\n  }, [dispatch, fastRefresh, collectionAddress, existingNfts, lastUpdateAt, isFetchingMoreNfts]);\n};\n\n_s3(useUpdateNftInfo, \"bdd6tkJQtOSxY4sgbB2NXVffI0Y=\", false, function () {\n  return [useAppDispatch, useRefresh, useSelector, useSelector, useNftsFromCollection];\n});\n\nexport const useGetCollections = () => {\n  _s4();\n\n  return useSelector(state => state.nftMarket.data.collections);\n};\n\n_s4(useGetCollections, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport const useGetCollection = collectionAddress => {\n  _s5();\n\n  const checksummedCollectionAddress = isAddress(collectionAddress) || '';\n  const collections = useGetCollections();\n  return collections[checksummedCollectionAddress];\n};\n\n_s5(useGetCollection, \"rOT1WniuoigD2aZKvIIZj/pyD5Q=\", false, function () {\n  return [useGetCollections];\n});\n\nexport const useNftsFromCollection = collectionAddress => {\n  _s6();\n\n  const checksummedCollectionAddress = isAddress(collectionAddress) || '';\n  const nfts = useSelector(state => state.nftMarket.data.nfts[checksummedCollectionAddress]);\n  return nfts;\n};\n\n_s6(useNftsFromCollection, \"zAGuQX0xmf9hZ66CtrQbaIJyE6c=\", false, function () {\n  return [useSelector];\n});\n\nexport const useGetAllBunniesByBunnyId = bunnyId => {\n  _s7();\n\n  const nfts = useSelector(state => state.nftMarket.data.nfts[pancakeBunniesAddress]);\n  return nfts ? nfts.filter(nft => nft.attributes[0].value === bunnyId && nft.marketData.isTradable) : [];\n};\n\n_s7(useGetAllBunniesByBunnyId, \"zAGuQX0xmf9hZ66CtrQbaIJyE6c=\", false, function () {\n  return [useSelector];\n});\n\nexport const useGetNFTInitializationState = () => {\n  _s8();\n\n  return useSelector(state => state.nftMarket.initializationState);\n};\n\n_s8(useGetNFTInitializationState, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport const useUserNfts = () => {\n  _s9();\n\n  return useSelector(state => state.nftMarket.data.user);\n};\n\n_s9(useUserNfts, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/nftMarket/hooks.ts"],"names":["useEffect","useMemo","useSelector","useAppDispatch","pancakeBunniesAddress","isAddress","useRefresh","fetchCollections","fetchNftsByBunnyId","fetchNftsFromCollections","updateNftTokensData","useFetchCollections","dispatch","useFetchByBunnyId","bunnyId","isFetchingMoreNfts","state","nftMarket","data","latestFetchAt","existingBunniesInState","useGetAllBunniesByBunnyId","existingTokenIds","map","nft","tokenId","firstBunny","length","existingMetadata","name","description","collection","collectionName","image","fetchMorePancakeBunnies","orderDirection","useUpdateNftInfo","collectionAddress","fastRefresh","lastUpdateAt","existingNfts","useNftsFromCollection","msSinceLastUpdate","Date","now","useGetCollections","collections","useGetCollection","checksummedCollectionAddress","nfts","filter","attributes","value","marketData","isTradable","useGetNFTInitializationState","initializationState","useUserNfts","user"],"mappings":"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","sourcesContent":["import { useEffect, useMemo } from 'react'\nimport { useSelector } from 'react-redux'\nimport { useAppDispatch } from 'state'\nimport { pancakeBunniesAddress } from 'views/Nft/market/constants'\nimport { isAddress } from 'utils'\nimport useRefresh from 'hooks/useRefresh'\nimport { fetchCollections, fetchNftsByBunnyId, fetchNftsFromCollections, updateNftTokensData } from './reducer'\nimport { State } from '../types'\nimport { NftToken, UserNftsState } from './types'\n\nexport const useFetchCollections = () => {\n  const dispatch = useAppDispatch()\n  useEffect(() => {\n    dispatch(fetchCollections())\n    dispatch(fetchNftsFromCollections(pancakeBunniesAddress))\n  }, [dispatch])\n}\n\n// Returns a function that fetches more NFTs when called and puts them into redux state.\n// Also returns loading flag and time of latest successful fetch\nexport const useFetchByBunnyId = (bunnyId: string) => {\n  const dispatch = useAppDispatch()\n\n  const isFetchingMoreNfts = useSelector((state: State) => state.nftMarket.data.isFetchingMoreNfts)\n  const latestFetchAt = useSelector((state: State) => state.nftMarket.data.latestFetchAt)\n\n  // Extra guard in case market data shifts\n  // we don't wanna fetch same tokens multiple times\n  const existingBunniesInState = useGetAllBunniesByBunnyId(bunnyId)\n  const existingTokenIds = existingBunniesInState ? existingBunniesInState.map((nft) => nft.tokenId) : []\n\n  const firstBunny = existingBunniesInState.length > 0 ? existingBunniesInState[0] : null\n\n  // If we already have NFT with this bunny id in state - we can reuse its metadata without making API request\n  const existingMetadata = useMemo(() => {\n    return firstBunny\n      ? {\n          name: firstBunny.name,\n          description: firstBunny.description,\n          collection: { name: firstBunny.collectionName },\n          image: firstBunny.image,\n        }\n      : null\n  }, [firstBunny])\n\n  const fetchMorePancakeBunnies = (orderDirection: 'asc' | 'desc') => {\n    dispatch(fetchNftsByBunnyId({ bunnyId, existingTokenIds, existingMetadata, orderDirection }))\n  }\n  return { isFetchingMoreNfts, latestFetchAt, fetchMorePancakeBunnies }\n}\n\n// This hook gets all token ids stored in redux and periodically checks subgraph in case the data we have is staled\n// e.g. NFT gets sold - must be changed form isTradable: true to isTradable: false\nexport const useUpdateNftInfo = (collectionAddress: string) => {\n  const dispatch = useAppDispatch()\n  const { fastRefresh } = useRefresh()\n\n  const lastUpdateAt = useSelector((state: State) => state.nftMarket.data.lastUpdateAt)\n  const isFetchingMoreNfts = useSelector((state: State) => state.nftMarket.data.isFetchingMoreNfts)\n\n  const existingNfts = useNftsFromCollection(collectionAddress)\n\n  useEffect(() => {\n    const msSinceLastUpdate = Date.now() - lastUpdateAt\n    const existingTokenIds = existingNfts ? existingNfts.map((nft) => nft.tokenId) : []\n    if (msSinceLastUpdate > 10000 && !isFetchingMoreNfts) {\n      dispatch(updateNftTokensData({ collectionAddress, existingTokenIds }))\n    }\n  }, [dispatch, fastRefresh, collectionAddress, existingNfts, lastUpdateAt, isFetchingMoreNfts])\n}\n\nexport const useGetCollections = () => {\n  return useSelector((state: State) => state.nftMarket.data.collections)\n}\n\nexport const useGetCollection = (collectionAddress: string) => {\n  const checksummedCollectionAddress = isAddress(collectionAddress) || ''\n  const collections = useGetCollections()\n  return collections[checksummedCollectionAddress]\n}\n\nexport const useNftsFromCollection = (collectionAddress: string) => {\n  const checksummedCollectionAddress = isAddress(collectionAddress) || ''\n  const nfts: NftToken[] = useSelector((state: State) => state.nftMarket.data.nfts[checksummedCollectionAddress])\n  return nfts\n}\n\nexport const useGetAllBunniesByBunnyId = (bunnyId: string) => {\n  const nfts: NftToken[] = useSelector((state: State) => state.nftMarket.data.nfts[pancakeBunniesAddress])\n  return nfts ? nfts.filter((nft) => nft.attributes[0].value === bunnyId && nft.marketData.isTradable) : []\n}\n\nexport const useGetNFTInitializationState = () => {\n  return useSelector((state: State) => state.nftMarket.initializationState)\n}\n\nexport const useUserNfts = (): UserNftsState => {\n  return useSelector((state: State) => state.nftMarket.data.user)\n}\n"]},"metadata":{},"sourceType":"module"}