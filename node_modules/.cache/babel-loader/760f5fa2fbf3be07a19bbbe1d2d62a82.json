{"ast":null,"code":"import _toConsumableArray from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _slicedToArray from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _defineProperty from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _objectSpread from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _taggedTemplateLiteral from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";import _regeneratorRuntime from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";var _templateObject,_templateObject2,_templateObject3,_templateObject4,_templateObject5,_templateObject6,_templateObject7,_templateObject8,_templateObject9,_templateObject10;import{request,gql}from'graphql-request';import{GRAPH_API_NFTMARKET,API_NFT}from'config/constants/endpoints';import{getErc721Contract}from'utils/contractHelpers';import map from'lodash/map';import{pancakeBunniesAddress}from'views/Nft/market/constants';import{NftLocation}from'./types';import{getBaseNftFields,getBaseTransactionFields,getCollectionBaseFields}from'./queries';/**\n * API HELPERS\n */ /**\n * Fetch static data from all collections using the API\n * @returns\n */export var getCollectionsApi=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var res,json;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return fetch(\"\".concat(API_NFT,\"/collections\"));case 2:res=_context.sent;if(!res.ok){_context.next=8;break;}_context.next=6;return res.json();case 6:json=_context.sent;return _context.abrupt(\"return\",json.data);case 8:console.error('Failed to fetch NFT collections',res.statusText);return _context.abrupt(\"return\",[]);case 10:case\"end\":return _context.stop();}}},_callee);}));return function getCollectionsApi(){return _ref.apply(this,arguments);};}();/**\n * Fetch static data from a collection using the API\n * @returns\n */export var getCollectionApi=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(collectionAddress){var res,json;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return fetch(\"\".concat(API_NFT,\"/collections/\").concat(collectionAddress));case 2:res=_context2.sent;if(!res.ok){_context2.next=8;break;}_context2.next=6;return res.json();case 6:json=_context2.sent;return _context2.abrupt(\"return\",json.data);case 8:console.error(\"API: Failed to fetch NFT collection \".concat(collectionAddress),res.statusText);return _context2.abrupt(\"return\",null);case 10:case\"end\":return _context2.stop();}}},_callee2);}));return function getCollectionApi(_x){return _ref2.apply(this,arguments);};}();/**\n * Fetch static data for all nfts in a collection using the API\n * @param collectionAddress\n * @returns\n */export var getNftsFromCollectionApi=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(collectionAddress){var res,data;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.next=2;return fetch(\"\".concat(API_NFT,\"/collections/\").concat(collectionAddress,\"/tokens\"));case 2:res=_context3.sent;if(!res.ok){_context3.next=8;break;}_context3.next=6;return res.json();case 6:data=_context3.sent;return _context3.abrupt(\"return\",data);case 8:console.error(\"API: Failed to fetch NFT tokens for \".concat(collectionAddress,\" collection\"),res.statusText);return _context3.abrupt(\"return\",null);case 10:case\"end\":return _context3.stop();}}},_callee3);}));return function getNftsFromCollectionApi(_x2){return _ref3.apply(this,arguments);};}();/**\n * Fetch a single NFT using the API\n * @param collectionAddress\n * @param tokenId\n * @returns NFT from API\n */export var getNftApi=/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(collectionAddress,tokenId){var res,json;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:_context4.next=2;return fetch(\"\".concat(API_NFT,\"/collections/\").concat(collectionAddress,\"/tokens/\").concat(tokenId));case 2:res=_context4.sent;if(!res.ok){_context4.next=8;break;}_context4.next=6;return res.json();case 6:json=_context4.sent;return _context4.abrupt(\"return\",json.data);case 8:console.error(\"API: Can't fetch NFT token \".concat(tokenId,\" in \").concat(collectionAddress),res.status);return _context4.abrupt(\"return\",null);case 10:case\"end\":return _context4.stop();}}},_callee4);}));return function getNftApi(_x3,_x4){return _ref4.apply(this,arguments);};}();/**\n * Fetch a list of NFT from different collections\n * @param from Array of { collectionAddress: string; tokenId: string }\n * @returns Array of NFT from API\n */export var getNftsFromDifferentCollectionsApi=/*#__PURE__*/function(){var _ref5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(from){var promises,responses;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:promises=from.map(function(nft){return getNftApi(nft.collectionAddress,nft.tokenId);});_context5.next=3;return Promise.all(promises);case 3:responses=_context5.sent;return _context5.abrupt(\"return\",responses.filter(function(resp){return resp;}).map(function(res,index){var _res$image,_res$image2;return{tokenId:res.tokenId,name:res.name,collectionName:res.collection.name,collectionAddress:from[index].collectionAddress,description:res.description,attributes:res.attributes,createdAt:res.createdAt,updatedAt:res.updatedAt,image:{original:(_res$image=res.image)===null||_res$image===void 0?void 0:_res$image.original,thumbnail:(_res$image2=res.image)===null||_res$image2===void 0?void 0:_res$image2.thumbnail}};}));case 5:case\"end\":return _context5.stop();}}},_callee5);}));return function getNftsFromDifferentCollectionsApi(_x5){return _ref5.apply(this,arguments);};}();/**\n * SUBGRAPH HELPERS\n */ /**\n * Fetch market data from a collection using the Subgraph\n * @returns\n */export var getCollectionSg=/*#__PURE__*/function(){var _ref6=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(collectionAddress){var res;return _regeneratorRuntime.wrap(function _callee6$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:_context6.prev=0;_context6.next=3;return request(GRAPH_API_NFTMARKET,gql(_templateObject||(_templateObject=_taggedTemplateLiteral([\"\\n        query getCollectionData($collectionAddress: String!) {\\n          collection(id: $collectionAddress) {\\n            \",\"\\n          }\\n        }\\n      \"])),getCollectionBaseFields()),{collectionAddress:collectionAddress.toLowerCase()});case 3:res=_context6.sent;return _context6.abrupt(\"return\",res.collection);case 7:_context6.prev=7;_context6.t0=_context6[\"catch\"](0);console.error('Failed to fetch collection',_context6.t0);return _context6.abrupt(\"return\",null);case 11:case\"end\":return _context6.stop();}}},_callee6,null,[[0,7]]);}));return function getCollectionSg(_x6){return _ref6.apply(this,arguments);};}();/**\n * Fetch market data from all collections using the Subgraph\n * @returns\n */export var getCollectionsSg=/*#__PURE__*/function(){var _ref7=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee7(){var res;return _regeneratorRuntime.wrap(function _callee7$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:_context7.prev=0;_context7.next=3;return request(GRAPH_API_NFTMARKET,gql(_templateObject2||(_templateObject2=_taggedTemplateLiteral([\"\\n        {\\n          collections {\\n            \",\"\\n          }\\n        }\\n      \"])),getCollectionBaseFields()));case 3:res=_context7.sent;return _context7.abrupt(\"return\",res.collections);case 7:_context7.prev=7;_context7.t0=_context7[\"catch\"](0);console.error('Failed to fetch NFT collections',_context7.t0);return _context7.abrupt(\"return\",[]);case 11:case\"end\":return _context7.stop();}}},_callee7,null,[[0,7]]);}));return function getCollectionsSg(){return _ref7.apply(this,arguments);};}();/**\n * Fetch market data for all nfts in a collection using the Subgraph\n * @param collectionAddress\n * @returns\n */export var getNftsFromCollectionSg=/*#__PURE__*/function(){var _ref8=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee8(collectionAddress){var res;return _regeneratorRuntime.wrap(function _callee8$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:_context8.prev=0;_context8.next=3;return request(GRAPH_API_NFTMARKET,gql(_templateObject3||(_templateObject3=_taggedTemplateLiteral([\"\\n        query getNftCollectionMarketData($collectionAddress: String!) {\\n          collection(id: $collectionAddress) {\\n            id\\n            nfts {\\n             \",\"\\n            }\\n          }\\n        }\\n      \"])),getBaseNftFields()),{collectionAddress:collectionAddress.toLowerCase()});case 3:res=_context8.sent;return _context8.abrupt(\"return\",res.collection.nfts);case 7:_context8.prev=7;_context8.t0=_context8[\"catch\"](0);console.error('Failed to fetch NFTs from collection',_context8.t0);return _context8.abrupt(\"return\",[]);case 11:case\"end\":return _context8.stop();}}},_callee8,null,[[0,7]]);}));return function getNftsFromCollectionSg(_x7){return _ref8.apply(this,arguments);};}();/**\n * Fetch market data for PancakeBunnies NFTs by bunny id using the Subgraph\n * @param bunnyId - bunny id to query\n * @param existingTokenIds - tokens that are already loaded into redux\n * @returns\n */export var getNftsByBunnyIdSg=/*#__PURE__*/function(){var _ref9=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee9(bunnyId,existingTokenIds,orderDirection){var where,res;return _regeneratorRuntime.wrap(function _callee9$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:_context9.prev=0;where=existingTokenIds.length>0?{otherId:bunnyId,isTradable:true,tokenId_not_in:existingTokenIds}:{otherId:bunnyId,isTradable:true};_context9.next=4;return request(GRAPH_API_NFTMARKET,gql(_templateObject4||(_templateObject4=_taggedTemplateLiteral([\"\\n        query getNftsByBunnyIdSg($collectionAddress: String!, $where: NFT_filter, $orderDirection: String!) {\\n          nfts(first: 30, where: $where, orderBy: currentAskPrice, orderDirection: $orderDirection) {\\n            \",\"\\n          }\\n        }\\n      \"])),getBaseNftFields()),{collectionAddress:pancakeBunniesAddress.toLowerCase(),where:where,orderDirection:orderDirection});case 4:res=_context9.sent;return _context9.abrupt(\"return\",res.nfts);case 8:_context9.prev=8;_context9.t0=_context9[\"catch\"](0);console.error(\"Failed to fetch collection NFTs for bunny id \".concat(bunnyId),_context9.t0);return _context9.abrupt(\"return\",[]);case 12:case\"end\":return _context9.stop();}}},_callee9,null,[[0,8]]);}));return function getNftsByBunnyIdSg(_x8,_x9,_x10){return _ref9.apply(this,arguments);};}();/**\n * Fetch market data for PancakeBunnies NFTs by bunny id using the Subgraph\n * @param bunnyId - bunny id to query\n * @param existingTokenIds - tokens that are already loaded into redux\n * @returns\n */export var getMarketDataForTokenIds=/*#__PURE__*/function(){var _ref10=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee10(collectionAddress,existingTokenIds){var res;return _regeneratorRuntime.wrap(function _callee10$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:_context10.prev=0;if(!(existingTokenIds.length===0)){_context10.next=3;break;}return _context10.abrupt(\"return\",[]);case 3:_context10.next=5;return request(GRAPH_API_NFTMARKET,gql(_templateObject5||(_templateObject5=_taggedTemplateLiteral([\"\\n        query getMarketDataForTokenIds($collectionAddress: String!, $where: NFT_filter) {\\n          nfts(first: 1000, where: $where) {\\n            \",\"\\n          }\\n        }\\n      \"])),getBaseNftFields()),{collectionAddress:collectionAddress.toLowerCase(),where:{tokenId_not_in:existingTokenIds}});case 5:res=_context10.sent;return _context10.abrupt(\"return\",res.nfts);case 9:_context10.prev=9;_context10.t0=_context10[\"catch\"](0);console.error(\"Failed to fetch market data for NFTs stored tokens\",_context10.t0);return _context10.abrupt(\"return\",[]);case 13:case\"end\":return _context10.stop();}}},_callee10,null,[[0,9]]);}));return function getMarketDataForTokenIds(_x11,_x12){return _ref10.apply(this,arguments);};}();export var getNftsMarketData=/*#__PURE__*/function(){var _ref11=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee11(){var where,first,orderBy,orderDirection,skip,res,_args11=arguments;return _regeneratorRuntime.wrap(function _callee11$(_context11){while(1){switch(_context11.prev=_context11.next){case 0:where=_args11.length>0&&_args11[0]!==undefined?_args11[0]:{};first=_args11.length>1&&_args11[1]!==undefined?_args11[1]:1000;orderBy=_args11.length>2&&_args11[2]!==undefined?_args11[2]:'id';orderDirection=_args11.length>3&&_args11[3]!==undefined?_args11[3]:'desc';skip=_args11.length>4&&_args11[4]!==undefined?_args11[4]:0;_context11.prev=5;_context11.next=8;return request(GRAPH_API_NFTMARKET,gql(_templateObject6||(_templateObject6=_taggedTemplateLiteral([\"\\n        query getNftsMarketData($first: Int, $skip: Int!, $where: NFT_filter, $orderBy: NFT_orderBy, $orderDirection: OrderDirection) {\\n          nfts(where: $where, orderBy: $orderBy, orderDirection: $orderDirection, skip: $skip) {\\n            \",\"\\n            transactionHistory {\\n              \",\"\\n            }\\n          }\\n        }\\n      \"])),getBaseNftFields(),getBaseTransactionFields()),{where:where,first:first,skip:skip,orderBy:orderBy,orderDirection:orderDirection});case 8:res=_context11.sent;return _context11.abrupt(\"return\",res.nfts);case 12:_context11.prev=12;_context11.t0=_context11[\"catch\"](5);console.error('Failed to fetch NFTs market data',_context11.t0);return _context11.abrupt(\"return\",[]);case 16:case\"end\":return _context11.stop();}}},_callee11,null,[[5,12]]);}));return function getNftsMarketData(){return _ref11.apply(this,arguments);};}();export var getAllPancakeBunniesLowestPrice=/*#__PURE__*/function(){var _ref12=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee12(bunnyIds){var singlePancakeBunnySubQueries,rawResponse;return _regeneratorRuntime.wrap(function _callee12$(_context12){while(1){switch(_context12.prev=_context12.next){case 0:_context12.prev=0;singlePancakeBunnySubQueries=bunnyIds.map(function(bunnyId){return\"b\".concat(bunnyId,\":nfts(first: 1, where: { otherId: \").concat(bunnyId,\", isTradable: true }, orderBy: currentAskPrice, orderDirection: asc) {\\n        currentAskPrice\\n      }\\n    \");});_context12.next=4;return request(GRAPH_API_NFTMARKET,gql(_templateObject7||(_templateObject7=_taggedTemplateLiteral([\"\\n        query getAllPancakeBunniesLowestPrice {\\n          \",\"\\n        }\\n      \"])),singlePancakeBunnySubQueries));case 4:rawResponse=_context12.sent;return _context12.abrupt(\"return\",Object.keys(rawResponse).reduce(function(lowestPricesData,subQueryKey){var bunnyId=subQueryKey.split('b')[1];return _objectSpread(_objectSpread({},lowestPricesData),{},_defineProperty({},bunnyId,rawResponse[subQueryKey].length>0?parseFloat(rawResponse[subQueryKey][0].currentAskPrice):Infinity));},{}));case 8:_context12.prev=8;_context12.t0=_context12[\"catch\"](0);console.error('Failed to fetch PancakeBunnies lowest prices',_context12.t0);return _context12.abrupt(\"return\",{});case 12:case\"end\":return _context12.stop();}}},_callee12,null,[[0,8]]);}));return function getAllPancakeBunniesLowestPrice(_x13){return _ref12.apply(this,arguments);};}();export var getAllPancakeBunniesRecentUpdatedAt=/*#__PURE__*/function(){var _ref13=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee13(bunnyIds){var singlePancakeBunnySubQueries,rawResponse;return _regeneratorRuntime.wrap(function _callee13$(_context13){while(1){switch(_context13.prev=_context13.next){case 0:_context13.prev=0;singlePancakeBunnySubQueries=bunnyIds.map(function(bunnyId){return\"b\".concat(bunnyId,\":nfts(first: 1, where: { otherId: \").concat(bunnyId,\", isTradable: true }, orderBy: updatedAt, orderDirection: desc) {\\n        updatedAt\\n      }\\n    \");});_context13.next=4;return request(GRAPH_API_NFTMARKET,gql(_templateObject8||(_templateObject8=_taggedTemplateLiteral([\"\\n        query getAllPancakeBunniesLowestPrice {\\n          \",\"\\n        }\\n      \"])),singlePancakeBunnySubQueries));case 4:rawResponse=_context13.sent;return _context13.abrupt(\"return\",Object.keys(rawResponse).reduce(function(updatedAtData,subQueryKey){var bunnyId=subQueryKey.split('b')[1];return _objectSpread(_objectSpread({},updatedAtData),{},_defineProperty({},bunnyId,rawResponse[subQueryKey].length>0?Number(rawResponse[subQueryKey][0].updatedAt):-Infinity));},{}));case 8:_context13.prev=8;_context13.t0=_context13[\"catch\"](0);console.error('Failed to fetch PancakeBunnies latest market updates',_context13.t0);return _context13.abrupt(\"return\",{});case 12:case\"end\":return _context13.stop();}}},_callee13,null,[[0,8]]);}));return function getAllPancakeBunniesRecentUpdatedAt(_x14){return _ref13.apply(this,arguments);};}();/**\n * Returns the lowest price of any NFT in a collection\n */export var getLowestPriceInCollection=/*#__PURE__*/function(){var _ref14=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee14(collectionAddress){var response,_response,nftSg;return _regeneratorRuntime.wrap(function _callee14$(_context14){while(1){switch(_context14.prev=_context14.next){case 0:_context14.prev=0;_context14.next=3;return getNftsMarketData({collection:collectionAddress.toLowerCase(),isTradable:true},1,'currentAskPrice','asc');case 3:response=_context14.sent;if(!(response.length===0)){_context14.next=6;break;}return _context14.abrupt(\"return\",0);case 6:_response=_slicedToArray(response,1),nftSg=_response[0];return _context14.abrupt(\"return\",parseFloat(nftSg.currentAskPrice));case 10:_context14.prev=10;_context14.t0=_context14[\"catch\"](0);console.error(\"Failed to lowest price NFTs in collection \".concat(collectionAddress),_context14.t0);return _context14.abrupt(\"return\",0);case 14:case\"end\":return _context14.stop();}}},_callee14,null,[[0,10]]);}));return function getLowestPriceInCollection(_x15){return _ref14.apply(this,arguments);};}();/**\n * Fetch user trading data for buyTradeHistory, sellTradeHistory and askOrderHistory from the Subgraph\n * @param where a User_filter where condition\n * @returns a UserActivity object\n */export var getUserActivity=/*#__PURE__*/function(){var _ref15=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee15(address){var res;return _regeneratorRuntime.wrap(function _callee15$(_context15){while(1){switch(_context15.prev=_context15.next){case 0:_context15.prev=0;_context15.next=3;return request(GRAPH_API_NFTMARKET,gql(_templateObject9||(_templateObject9=_taggedTemplateLiteral([\"\\n        query getUserActivity($address: String!) {\\n          user(id: $address) {\\n            buyTradeHistory(first: 250, orderBy: timestamp, orderDirection: desc) {\\n              \",\"\\n              nft {\\n                \",\"\\n              }\\n            }\\n            sellTradeHistory(first: 250, orderBy: timestamp, orderDirection: desc) {\\n              \",\"\\n              nft {\\n                \",\"\\n              }\\n            }\\n            askOrderHistory(first: 500, orderBy: timestamp, orderDirection: desc) {\\n              id\\n              block\\n              timestamp\\n              orderType\\n              askPrice\\n              nft {\\n                \",\"\\n              }\\n            }\\n          }\\n        }\\n      \"])),getBaseTransactionFields(),getBaseNftFields(),getBaseTransactionFields(),getBaseNftFields(),getBaseNftFields()),{address:address});case 3:res=_context15.sent;return _context15.abrupt(\"return\",res.user||{askOrderHistory:[],buyTradeHistory:[],sellTradeHistory:[]});case 7:_context15.prev=7;_context15.t0=_context15[\"catch\"](0);console.error('Failed to fetch user Activity',_context15.t0);return _context15.abrupt(\"return\",{askOrderHistory:[],buyTradeHistory:[],sellTradeHistory:[]});case 11:case\"end\":return _context15.stop();}}},_callee15,null,[[0,7]]);}));return function getUserActivity(_x16){return _ref15.apply(this,arguments);};}();/**\n * Get the most recently listed NFTs\n * @param first Number of nfts to retrieve\n * @returns NftTokenSg[]\n */export var getLatestListedNfts=/*#__PURE__*/function(){var _ref16=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee16(first){var res;return _regeneratorRuntime.wrap(function _callee16$(_context16){while(1){switch(_context16.prev=_context16.next){case 0:_context16.prev=0;_context16.next=3;return request(GRAPH_API_NFTMARKET,gql(_templateObject10||(_templateObject10=_taggedTemplateLiteral([\"\\n        query getLatestNftMarketData($first: Int) {\\n          nfts(where: { isTradable: true }, orderBy: updatedAt , orderDirection: desc, first: $first) {\\n            \",\"\\n            collection {\\n              id\\n            }\\n          }\\n        }\\n      \"])),getBaseNftFields()),{first:first});case 3:res=_context16.sent;return _context16.abrupt(\"return\",res.nfts);case 7:_context16.prev=7;_context16.t0=_context16[\"catch\"](0);console.error('Failed to fetch NFTs market data',_context16.t0);return _context16.abrupt(\"return\",[]);case 11:case\"end\":return _context16.stop();}}},_callee16,null,[[0,7]]);}));return function getLatestListedNfts(_x17){return _ref16.apply(this,arguments);};}();/**\n * OTHER HELPERS\n */export var fetchWalletTokenIdsForCollections=/*#__PURE__*/function(){var _ref17=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee19(account,collections){var walletNftPromises,walletNfts;return _regeneratorRuntime.wrap(function _callee19$(_context19){while(1){switch(_context19.prev=_context19.next){case 0:walletNftPromises=map(collections,/*#__PURE__*/function(){var _ref18=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee18(collection){var collectionAddress,contract,balanceOfResponse,balanceOf,getTokenId,tokenIdPromises,i,tokenIds,nftLocation,tokensWithCollectionAddress;return _regeneratorRuntime.wrap(function _callee18$(_context18){while(1){switch(_context18.prev=_context18.next){case 0:collectionAddress=collection.address;contract=getErc721Contract(collectionAddress);_context18.prev=2;_context18.next=5;return contract.balanceOf(account);case 5:balanceOfResponse=_context18.sent;_context18.next=12;break;case 8:_context18.prev=8;_context18.t0=_context18[\"catch\"](2);console.error(_context18.t0);return _context18.abrupt(\"return\",[]);case 12:balanceOf=balanceOfResponse.toNumber();// User has no NFTs for this collection\nif(!balanceOfResponse.eq(0)){_context18.next=15;break;}return _context18.abrupt(\"return\",[]);case 15:getTokenId=/*#__PURE__*/function(){var _ref19=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee17(index){var tokenIdBn,tokenId;return _regeneratorRuntime.wrap(function _callee17$(_context17){while(1){switch(_context17.prev=_context17.next){case 0:_context17.prev=0;_context17.next=3;return contract.tokenOfOwnerByIndex(account,index);case 3:tokenIdBn=_context17.sent;tokenId=tokenIdBn.toString();return _context17.abrupt(\"return\",tokenId);case 8:_context17.prev=8;_context17.t0=_context17[\"catch\"](0);console.error('getTokenIdAndData',_context17.t0);return _context17.abrupt(\"return\",null);case 12:case\"end\":return _context17.stop();}}},_callee17,null,[[0,8]]);}));return function getTokenId(_x21){return _ref19.apply(this,arguments);};}();tokenIdPromises=[];// For each index get the tokenId\nfor(i=0;i<balanceOf;i++){tokenIdPromises.push(getTokenId(i));}_context18.next=20;return Promise.all(tokenIdPromises);case 20:tokenIds=_context18.sent;nftLocation=NftLocation.WALLET;tokensWithCollectionAddress=tokenIds.map(function(tokenId){return{tokenId:tokenId,collectionAddress:collectionAddress,nftLocation:nftLocation};});return _context18.abrupt(\"return\",tokensWithCollectionAddress);case 24:case\"end\":return _context18.stop();}}},_callee18,null,[[2,8]]);}));return function(_x20){return _ref18.apply(this,arguments);};}());_context19.next=3;return Promise.all(walletNftPromises);case 3:walletNfts=_context19.sent;return _context19.abrupt(\"return\",walletNfts.flat());case 5:case\"end\":return _context19.stop();}}},_callee19);}));return function fetchWalletTokenIdsForCollections(_x18,_x19){return _ref17.apply(this,arguments);};}();/**\n * Helper to combine data from the collections' API and subgraph\n */export var combineCollectionData=function combineCollectionData(collectionApiData,collectionSgData){var collectionsMarketObj=collectionSgData.reduce(function(prev,current){return _objectSpread(_objectSpread({},prev),{},_defineProperty({},current.id,_objectSpread({},current)));},{});return collectionApiData.reduce(function(accum,current){var collectionMarket=collectionsMarketObj[current.address.toLowerCase()];var collection=_objectSpread(_objectSpread({},current),collectionMarket);return _objectSpread(_objectSpread({},accum),{},_defineProperty({},current.address,collection));},{});};/**\n * Evaluate whether a market NFT is in a users wallet, their profile picture, or on sale\n * @param tokenId string\n * @param tokenIdsInWallet array of tokenIds in wallet\n * @param tokenIdsForSale array of tokenIds on sale\n * @param profileNftId Optional tokenId of users' profile picture\n * @returns NftLocation enum value\n */export var getNftLocationForMarketNft=function getNftLocationForMarketNft(tokenId,tokenIdsInWallet,tokenIdsForSale,profileNftId){if(tokenId===profileNftId){return NftLocation.PROFILE;}if(tokenIdsForSale.includes(tokenId)){return NftLocation.FORSALE;}if(tokenIdsInWallet.includes(tokenId)){return NftLocation.WALLET;}console.error(\"Cannot determine location for tokenID \".concat(tokenId,\", defaulting to NftLocation.WALLET\"));return NftLocation.WALLET;};/**\n * Construct complete TokenMarketData entities with a users' wallet NFT ids and market data for their wallet NFTs\n * @param walletNfts TokenIdWithCollectionAddress\n * @param marketDataForWalletNfts TokenMarketData[]\n * @returns TokenMarketData[]\n */export var attachMarketDataToWalletNfts=function attachMarketDataToWalletNfts(walletNfts,marketDataForWalletNfts){var walletNftsWithMarketData=walletNfts.map(function(walletNft){var marketData=marketDataForWalletNfts.find(function(marketNft){return marketNft.tokenId===walletNft.tokenId;});return marketData!==null&&marketData!==void 0?marketData:{tokenId:walletNft.tokenId,collection:{id:walletNft.collectionAddress.toLowerCase()},nftLocation:walletNft.nftLocation,metadataUrl:null,transactionHistory:null,currentSeller:null,isTradable:null,currentAskPrice:null,latestTradedPriceInBNB:null,tradeVolumeBNB:null,totalTrades:null,otherId:null};});return walletNftsWithMarketData;};/**\n * Attach TokenMarketData and location to NftToken\n * @param nftsWithMetadata NftToken[] with API metadata\n * @param nftsForSale  market data for nfts that are on sale (i.e. not in a user's wallet)\n * @param walletNfts makret data for nfts in a user's wallet\n * @param tokenIdsInWallet array of token ids in user's wallet\n * @param tokenIdsForSale array of token ids of nfts that are on sale\n * @param profileNftId profile picture token id\n * @returns NFT[]\n */export var combineNftMarketAndMetadata=function combineNftMarketAndMetadata(nftsWithMetadata,nftsForSale,walletNfts,tokenIdsInWallet,tokenIdsForSale,profileNftId){var completeNftData=nftsWithMetadata.map(function(nft){// Get metadata object\nvar isOnSale=nftsForSale.filter(function(forSaleNft){return forSaleNft.tokenId===nft.tokenId;}).length>0;var marketData;if(isOnSale){marketData=nftsForSale.find(function(marketNft){return marketNft.tokenId===nft.tokenId;});}else{marketData=walletNfts.find(function(marketNft){return marketNft.tokenId===nft.tokenId;});}var location=getNftLocationForMarketNft(nft.tokenId,tokenIdsInWallet,tokenIdsForSale,profileNftId);return _objectSpread(_objectSpread({},nft),{},{marketData:marketData,location:location});});return completeNftData;};/**\n * Get in-wallet, on-sale & profile pic NFT metadata, complete with market data for a given account\n * @param account\n * @param collections\n * @param profileNftWithCollectionAddress\n * @returns Promise<NftToken[]>\n */export var getCompleteAccountNftData=/*#__PURE__*/function(){var _ref20=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee20(account,collections,profileNftWithCollectionAddress){var walletNftIds,tokenIds,marketDataForWalletNfts,walletNftsWithMarketData,tokenIdsInWallet,marketDataForSaleNfts,tokenIdsForSale,forSaleNftIds,metadataForAllNfts,completeNftData;return _regeneratorRuntime.wrap(function _callee20$(_context20){while(1){switch(_context20.prev=_context20.next){case 0:_context20.next=2;return fetchWalletTokenIdsForCollections(account,collections);case 2:walletNftIds=_context20.sent;if(profileNftWithCollectionAddress===null||profileNftWithCollectionAddress===void 0?void 0:profileNftWithCollectionAddress.tokenId){walletNftIds.push(profileNftWithCollectionAddress);}tokenIds=walletNftIds.map(function(nft){return nft.tokenId;});_context20.next=7;return getNftsMarketData({tokenId_in:tokenIds});case 7:marketDataForWalletNfts=_context20.sent;walletNftsWithMarketData=attachMarketDataToWalletNfts(walletNftIds,marketDataForWalletNfts);tokenIdsInWallet=walletNftIds.filter(function(walletNft){// Profile Pic NFT is included in walletNftIds array, hence this filter\nreturn(profileNftWithCollectionAddress===null||profileNftWithCollectionAddress===void 0?void 0:profileNftWithCollectionAddress.tokenId)!==walletNft.tokenId;}).map(function(nft){return nft.tokenId;});_context20.next=12;return getNftsMarketData({currentSeller:account.toLowerCase()});case 12:marketDataForSaleNfts=_context20.sent;tokenIdsForSale=marketDataForSaleNfts.map(function(nft){return nft.tokenId;});forSaleNftIds=marketDataForSaleNfts.map(function(nft){return{collectionAddress:nft.collection.id,tokenId:nft.tokenId};});_context20.next=17;return getNftsFromDifferentCollectionsApi([].concat(_toConsumableArray(walletNftIds),_toConsumableArray(forSaleNftIds)));case 17:metadataForAllNfts=_context20.sent;completeNftData=combineNftMarketAndMetadata(metadataForAllNfts,marketDataForSaleNfts,walletNftsWithMarketData,tokenIdsInWallet,tokenIdsForSale,profileNftWithCollectionAddress===null||profileNftWithCollectionAddress===void 0?void 0:profileNftWithCollectionAddress.tokenId);return _context20.abrupt(\"return\",completeNftData);case 20:case\"end\":return _context20.stop();}}},_callee20);}));return function getCompleteAccountNftData(_x22,_x23,_x24){return _ref20.apply(this,arguments);};}();","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/nftMarket/helpers.ts"],"names":["request","gql","GRAPH_API_NFTMARKET","API_NFT","getErc721Contract","map","pancakeBunniesAddress","NftLocation","getBaseNftFields","getBaseTransactionFields","getCollectionBaseFields","getCollectionsApi","fetch","res","ok","json","data","console","error","statusText","getCollectionApi","collectionAddress","getNftsFromCollectionApi","getNftApi","tokenId","status","getNftsFromDifferentCollectionsApi","from","promises","nft","Promise","all","responses","filter","resp","index","name","collectionName","collection","description","attributes","createdAt","updatedAt","image","original","thumbnail","getCollectionSg","toLowerCase","getCollectionsSg","collections","getNftsFromCollectionSg","nfts","getNftsByBunnyIdSg","bunnyId","existingTokenIds","orderDirection","where","length","otherId","isTradable","tokenId_not_in","getMarketDataForTokenIds","getNftsMarketData","first","orderBy","skip","getAllPancakeBunniesLowestPrice","bunnyIds","singlePancakeBunnySubQueries","rawResponse","Object","keys","reduce","lowestPricesData","subQueryKey","split","parseFloat","currentAskPrice","Infinity","getAllPancakeBunniesRecentUpdatedAt","updatedAtData","Number","getLowestPriceInCollection","response","nftSg","getUserActivity","address","user","askOrderHistory","buyTradeHistory","sellTradeHistory","getLatestListedNfts","fetchWalletTokenIdsForCollections","account","walletNftPromises","contract","balanceOf","balanceOfResponse","toNumber","eq","getTokenId","tokenOfOwnerByIndex","tokenIdBn","toString","tokenIdPromises","i","push","tokenIds","nftLocation","WALLET","tokensWithCollectionAddress","walletNfts","flat","combineCollectionData","collectionApiData","collectionSgData","collectionsMarketObj","prev","current","id","accum","collectionMarket","getNftLocationForMarketNft","tokenIdsInWallet","tokenIdsForSale","profileNftId","PROFILE","includes","FORSALE","attachMarketDataToWalletNfts","marketDataForWalletNfts","walletNftsWithMarketData","walletNft","marketData","find","marketNft","metadataUrl","transactionHistory","currentSeller","latestTradedPriceInBNB","tradeVolumeBNB","totalTrades","combineNftMarketAndMetadata","nftsWithMetadata","nftsForSale","completeNftData","isOnSale","forSaleNft","location","getCompleteAccountNftData","profileNftWithCollectionAddress","walletNftIds","tokenId_in","marketDataForSaleNfts","forSaleNftIds","metadataForAllNfts"],"mappings":"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","sourcesContent":["import { request, gql } from 'graphql-request'\nimport { GRAPH_API_NFTMARKET, API_NFT } from 'config/constants/endpoints'\nimport { getErc721Contract } from 'utils/contractHelpers'\nimport { ethers } from 'ethers'\nimport map from 'lodash/map'\nimport { pancakeBunniesAddress } from 'views/Nft/market/constants'\nimport {\n  TokenMarketData,\n  ApiCollections,\n  TokenIdWithCollectionAddress,\n  NftToken,\n  NftLocation,\n  Collection,\n  ApiResponseCollectionTokens,\n  ApiResponseSpecificToken,\n  ApiCollection,\n  CollectionMarketDataBaseFields,\n  Transaction,\n  AskOrder,\n} from './types'\nimport { getBaseNftFields, getBaseTransactionFields, getCollectionBaseFields } from './queries'\n\n/**\n * API HELPERS\n */\n\n/**\n * Fetch static data from all collections using the API\n * @returns\n */\nexport const getCollectionsApi = async (): Promise<ApiCollection[]> => {\n  const res = await fetch(`${API_NFT}/collections`)\n  if (res.ok) {\n    const json = await res.json()\n    return json.data\n  }\n  console.error('Failed to fetch NFT collections', res.statusText)\n  return []\n}\n\n/**\n * Fetch static data from a collection using the API\n * @returns\n */\nexport const getCollectionApi = async (collectionAddress: string): Promise<ApiCollection> => {\n  const res = await fetch(`${API_NFT}/collections/${collectionAddress}`)\n  if (res.ok) {\n    const json = await res.json()\n    return json.data\n  }\n  console.error(`API: Failed to fetch NFT collection ${collectionAddress}`, res.statusText)\n  return null\n}\n\n/**\n * Fetch static data for all nfts in a collection using the API\n * @param collectionAddress\n * @returns\n */\nexport const getNftsFromCollectionApi = async (collectionAddress: string): Promise<ApiResponseCollectionTokens> => {\n  const res = await fetch(`${API_NFT}/collections/${collectionAddress}/tokens`)\n  if (res.ok) {\n    const data = await res.json()\n    return data\n  }\n  console.error(`API: Failed to fetch NFT tokens for ${collectionAddress} collection`, res.statusText)\n  return null\n}\n\n/**\n * Fetch a single NFT using the API\n * @param collectionAddress\n * @param tokenId\n * @returns NFT from API\n */\nexport const getNftApi = async (\n  collectionAddress: string,\n  tokenId: string,\n): Promise<ApiResponseSpecificToken['data']> => {\n  const res = await fetch(`${API_NFT}/collections/${collectionAddress}/tokens/${tokenId}`)\n  if (res.ok) {\n    const json = await res.json()\n    return json.data\n  }\n\n  console.error(`API: Can't fetch NFT token ${tokenId} in ${collectionAddress}`, res.status)\n  return null\n}\n\n/**\n * Fetch a list of NFT from different collections\n * @param from Array of { collectionAddress: string; tokenId: string }\n * @returns Array of NFT from API\n */\nexport const getNftsFromDifferentCollectionsApi = async (\n  from: { collectionAddress: string; tokenId: string }[],\n): Promise<NftToken[]> => {\n  const promises = from.map((nft) => getNftApi(nft.collectionAddress, nft.tokenId))\n  const responses = await Promise.all(promises)\n  // Sometimes API can't find some tokens (e.g. 404 response)\n  // at least return the ones that returned successfully\n  return responses\n    .filter((resp) => resp)\n    .map((res, index) => ({\n      tokenId: res.tokenId,\n      name: res.name,\n      collectionName: res.collection.name,\n      collectionAddress: from[index].collectionAddress,\n      description: res.description,\n      attributes: res.attributes,\n      createdAt: res.createdAt,\n      updatedAt: res.updatedAt,\n      image: {\n        original: res.image?.original,\n        thumbnail: res.image?.thumbnail,\n      },\n    }))\n}\n\n/**\n * SUBGRAPH HELPERS\n */\n\n/**\n * Fetch market data from a collection using the Subgraph\n * @returns\n */\nexport const getCollectionSg = async (collectionAddress: string): Promise<CollectionMarketDataBaseFields> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getCollectionData($collectionAddress: String!) {\n          collection(id: $collectionAddress) {\n            ${getCollectionBaseFields()}\n          }\n        }\n      `,\n      { collectionAddress: collectionAddress.toLowerCase() },\n    )\n    return res.collection\n  } catch (error) {\n    console.error('Failed to fetch collection', error)\n    return null\n  }\n}\n\n/**\n * Fetch market data from all collections using the Subgraph\n * @returns\n */\nexport const getCollectionsSg = async (): Promise<CollectionMarketDataBaseFields[]> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        {\n          collections {\n            ${getCollectionBaseFields()}\n          }\n        }\n      `,\n    )\n    return res.collections\n  } catch (error) {\n    console.error('Failed to fetch NFT collections', error)\n    return []\n  }\n}\n\n/**\n * Fetch market data for all nfts in a collection using the Subgraph\n * @param collectionAddress\n * @returns\n */\nexport const getNftsFromCollectionSg = async (collectionAddress: string): Promise<TokenMarketData[]> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getNftCollectionMarketData($collectionAddress: String!) {\n          collection(id: $collectionAddress) {\n            id\n            nfts {\n             ${getBaseNftFields()}\n            }\n          }\n        }\n      `,\n      { collectionAddress: collectionAddress.toLowerCase() },\n    )\n    return res.collection.nfts\n  } catch (error) {\n    console.error('Failed to fetch NFTs from collection', error)\n    return []\n  }\n}\n\n/**\n * Fetch market data for PancakeBunnies NFTs by bunny id using the Subgraph\n * @param bunnyId - bunny id to query\n * @param existingTokenIds - tokens that are already loaded into redux\n * @returns\n */\nexport const getNftsByBunnyIdSg = async (\n  bunnyId: string,\n  existingTokenIds: string[],\n  orderDirection: 'asc' | 'desc',\n): Promise<TokenMarketData[]> => {\n  try {\n    const where =\n      existingTokenIds.length > 0\n        ? { otherId: bunnyId, isTradable: true, tokenId_not_in: existingTokenIds }\n        : { otherId: bunnyId, isTradable: true }\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getNftsByBunnyIdSg($collectionAddress: String!, $where: NFT_filter, $orderDirection: String!) {\n          nfts(first: 30, where: $where, orderBy: currentAskPrice, orderDirection: $orderDirection) {\n            ${getBaseNftFields()}\n          }\n        }\n      `,\n      {\n        collectionAddress: pancakeBunniesAddress.toLowerCase(),\n        where,\n        orderDirection,\n      },\n    )\n    return res.nfts\n  } catch (error) {\n    console.error(`Failed to fetch collection NFTs for bunny id ${bunnyId}`, error)\n    return []\n  }\n}\n\n/**\n * Fetch market data for PancakeBunnies NFTs by bunny id using the Subgraph\n * @param bunnyId - bunny id to query\n * @param existingTokenIds - tokens that are already loaded into redux\n * @returns\n */\nexport const getMarketDataForTokenIds = async (\n  collectionAddress: string,\n  existingTokenIds: string[],\n): Promise<TokenMarketData[]> => {\n  try {\n    if (existingTokenIds.length === 0) {\n      return []\n    }\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getMarketDataForTokenIds($collectionAddress: String!, $where: NFT_filter) {\n          nfts(first: 1000, where: $where) {\n            ${getBaseNftFields()}\n          }\n        }\n      `,\n      {\n        collectionAddress: collectionAddress.toLowerCase(),\n        where: { tokenId_not_in: existingTokenIds },\n      },\n    )\n    return res.nfts\n  } catch (error) {\n    console.error(`Failed to fetch market data for NFTs stored tokens`, error)\n    return []\n  }\n}\n\nexport const getNftsMarketData = async (\n  where = {},\n  first = 1000,\n  orderBy = 'id',\n  orderDirection: 'asc' | 'desc' = 'desc',\n  skip = 0,\n): Promise<TokenMarketData[]> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getNftsMarketData($first: Int, $skip: Int!, $where: NFT_filter, $orderBy: NFT_orderBy, $orderDirection: OrderDirection) {\n          nfts(where: $where, orderBy: $orderBy, orderDirection: $orderDirection, skip: $skip) {\n            ${getBaseNftFields()}\n            transactionHistory {\n              ${getBaseTransactionFields()}\n            }\n          }\n        }\n      `,\n      { where, first, skip, orderBy, orderDirection },\n    )\n\n    return res.nfts\n  } catch (error) {\n    console.error('Failed to fetch NFTs market data', error)\n    return []\n  }\n}\n\nexport const getAllPancakeBunniesLowestPrice = async (bunnyIds: string[]): Promise<Record<string, number>> => {\n  try {\n    const singlePancakeBunnySubQueries = bunnyIds.map(\n      (\n        bunnyId,\n      ) => `b${bunnyId}:nfts(first: 1, where: { otherId: ${bunnyId}, isTradable: true }, orderBy: currentAskPrice, orderDirection: asc) {\n        currentAskPrice\n      }\n    `,\n    )\n    const rawResponse: Record<string, { currentAskPrice: string }[]> = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getAllPancakeBunniesLowestPrice {\n          ${singlePancakeBunnySubQueries}\n        }\n      `,\n    )\n    return Object.keys(rawResponse).reduce((lowestPricesData, subQueryKey) => {\n      const bunnyId = subQueryKey.split('b')[1]\n      return {\n        ...lowestPricesData,\n        [bunnyId]:\n          rawResponse[subQueryKey].length > 0 ? parseFloat(rawResponse[subQueryKey][0].currentAskPrice) : Infinity,\n      }\n    }, {})\n  } catch (error) {\n    console.error('Failed to fetch PancakeBunnies lowest prices', error)\n    return {}\n  }\n}\n\nexport const getAllPancakeBunniesRecentUpdatedAt = async (bunnyIds: string[]): Promise<Record<string, number>> => {\n  try {\n    const singlePancakeBunnySubQueries = bunnyIds.map(\n      (\n        bunnyId,\n      ) => `b${bunnyId}:nfts(first: 1, where: { otherId: ${bunnyId}, isTradable: true }, orderBy: updatedAt, orderDirection: desc) {\n        updatedAt\n      }\n    `,\n    )\n    const rawResponse: Record<string, { updatedAt: string }[]> = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getAllPancakeBunniesLowestPrice {\n          ${singlePancakeBunnySubQueries}\n        }\n      `,\n    )\n    return Object.keys(rawResponse).reduce((updatedAtData, subQueryKey) => {\n      const bunnyId = subQueryKey.split('b')[1]\n      return {\n        ...updatedAtData,\n        [bunnyId]: rawResponse[subQueryKey].length > 0 ? Number(rawResponse[subQueryKey][0].updatedAt) : -Infinity,\n      }\n    }, {})\n  } catch (error) {\n    console.error('Failed to fetch PancakeBunnies latest market updates', error)\n    return {}\n  }\n}\n\n/**\n * Returns the lowest price of any NFT in a collection\n */\nexport const getLowestPriceInCollection = async (collectionAddress: string) => {\n  try {\n    const response = await getNftsMarketData(\n      { collection: collectionAddress.toLowerCase(), isTradable: true },\n      1,\n      'currentAskPrice',\n      'asc',\n    )\n\n    if (response.length === 0) {\n      return 0\n    }\n\n    const [nftSg] = response\n    return parseFloat(nftSg.currentAskPrice)\n  } catch (error) {\n    console.error(`Failed to lowest price NFTs in collection ${collectionAddress}`, error)\n    return 0\n  }\n}\n\n/**\n * Fetch user trading data for buyTradeHistory, sellTradeHistory and askOrderHistory from the Subgraph\n * @param where a User_filter where condition\n * @returns a UserActivity object\n */\nexport const getUserActivity = async (\n  address: string,\n): Promise<{ askOrderHistory: AskOrder[]; buyTradeHistory: Transaction[]; sellTradeHistory: Transaction[] }> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getUserActivity($address: String!) {\n          user(id: $address) {\n            buyTradeHistory(first: 250, orderBy: timestamp, orderDirection: desc) {\n              ${getBaseTransactionFields()}\n              nft {\n                ${getBaseNftFields()}\n              }\n            }\n            sellTradeHistory(first: 250, orderBy: timestamp, orderDirection: desc) {\n              ${getBaseTransactionFields()}\n              nft {\n                ${getBaseNftFields()}\n              }\n            }\n            askOrderHistory(first: 500, orderBy: timestamp, orderDirection: desc) {\n              id\n              block\n              timestamp\n              orderType\n              askPrice\n              nft {\n                ${getBaseNftFields()}\n              }\n            }\n          }\n        }\n      `,\n      { address },\n    )\n\n    return res.user || { askOrderHistory: [], buyTradeHistory: [], sellTradeHistory: [] }\n  } catch (error) {\n    console.error('Failed to fetch user Activity', error)\n    return {\n      askOrderHistory: [],\n      buyTradeHistory: [],\n      sellTradeHistory: [],\n    }\n  }\n}\n\n/**\n * Get the most recently listed NFTs\n * @param first Number of nfts to retrieve\n * @returns NftTokenSg[]\n */\nexport const getLatestListedNfts = async (first: number): Promise<TokenMarketData[]> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getLatestNftMarketData($first: Int) {\n          nfts(where: { isTradable: true }, orderBy: updatedAt , orderDirection: desc, first: $first) {\n            ${getBaseNftFields()}\n            collection {\n              id\n            }\n          }\n        }\n      `,\n      { first },\n    )\n\n    return res.nfts\n  } catch (error) {\n    console.error('Failed to fetch NFTs market data', error)\n    return []\n  }\n}\n\n/**\n * OTHER HELPERS\n */\n\nexport const fetchWalletTokenIdsForCollections = async (\n  account: string,\n  collections: ApiCollections,\n): Promise<TokenIdWithCollectionAddress[]> => {\n  const walletNftPromises = map(collections, async (collection): Promise<TokenIdWithCollectionAddress[]> => {\n    const { address: collectionAddress } = collection\n    const contract = getErc721Contract(collectionAddress)\n    let balanceOfResponse\n\n    try {\n      balanceOfResponse = await contract.balanceOf(account)\n    } catch (e) {\n      console.error(e)\n      return []\n    }\n\n    const balanceOf = balanceOfResponse.toNumber()\n\n    // User has no NFTs for this collection\n    if (balanceOfResponse.eq(0)) {\n      return []\n    }\n\n    const getTokenId = async (index: number) => {\n      try {\n        const tokenIdBn: ethers.BigNumber = await contract.tokenOfOwnerByIndex(account, index)\n        const tokenId = tokenIdBn.toString()\n        return tokenId\n      } catch (error) {\n        console.error('getTokenIdAndData', error)\n        return null\n      }\n    }\n\n    const tokenIdPromises = []\n\n    // For each index get the tokenId\n    for (let i = 0; i < balanceOf; i++) {\n      tokenIdPromises.push(getTokenId(i))\n    }\n\n    const tokenIds = await Promise.all(tokenIdPromises)\n    const nftLocation = NftLocation.WALLET\n    const tokensWithCollectionAddress = tokenIds.map((tokenId) => {\n      return { tokenId, collectionAddress, nftLocation }\n    })\n\n    return tokensWithCollectionAddress\n  })\n\n  const walletNfts = await Promise.all(walletNftPromises)\n  return walletNfts.flat()\n}\n\n/**\n * Helper to combine data from the collections' API and subgraph\n */\nexport const combineCollectionData = (\n  collectionApiData: ApiCollection[],\n  collectionSgData: CollectionMarketDataBaseFields[],\n): Record<string, Collection> => {\n  const collectionsMarketObj: Record<string, CollectionMarketDataBaseFields> = collectionSgData.reduce(\n    (prev, current) => ({ ...prev, [current.id]: { ...current } }),\n    {},\n  )\n\n  return collectionApiData.reduce((accum, current) => {\n    const collectionMarket = collectionsMarketObj[current.address.toLowerCase()]\n    const collection: Collection = {\n      ...current,\n      ...collectionMarket,\n    }\n\n    return {\n      ...accum,\n      [current.address]: collection,\n    }\n  }, {})\n}\n\n/**\n * Evaluate whether a market NFT is in a users wallet, their profile picture, or on sale\n * @param tokenId string\n * @param tokenIdsInWallet array of tokenIds in wallet\n * @param tokenIdsForSale array of tokenIds on sale\n * @param profileNftId Optional tokenId of users' profile picture\n * @returns NftLocation enum value\n */\nexport const getNftLocationForMarketNft = (\n  tokenId: string,\n  tokenIdsInWallet: string[],\n  tokenIdsForSale: string[],\n  profileNftId?: string,\n): NftLocation => {\n  if (tokenId === profileNftId) {\n    return NftLocation.PROFILE\n  }\n  if (tokenIdsForSale.includes(tokenId)) {\n    return NftLocation.FORSALE\n  }\n  if (tokenIdsInWallet.includes(tokenId)) {\n    return NftLocation.WALLET\n  }\n  console.error(`Cannot determine location for tokenID ${tokenId}, defaulting to NftLocation.WALLET`)\n  return NftLocation.WALLET\n}\n\n/**\n * Construct complete TokenMarketData entities with a users' wallet NFT ids and market data for their wallet NFTs\n * @param walletNfts TokenIdWithCollectionAddress\n * @param marketDataForWalletNfts TokenMarketData[]\n * @returns TokenMarketData[]\n */\nexport const attachMarketDataToWalletNfts = (\n  walletNfts: TokenIdWithCollectionAddress[],\n  marketDataForWalletNfts: TokenMarketData[],\n): TokenMarketData[] => {\n  const walletNftsWithMarketData = walletNfts.map((walletNft) => {\n    const marketData = marketDataForWalletNfts.find((marketNft) => marketNft.tokenId === walletNft.tokenId)\n    return (\n      marketData ?? {\n        tokenId: walletNft.tokenId,\n        collection: {\n          id: walletNft.collectionAddress.toLowerCase(),\n        },\n        nftLocation: walletNft.nftLocation,\n        metadataUrl: null,\n        transactionHistory: null,\n        currentSeller: null,\n        isTradable: null,\n        currentAskPrice: null,\n        latestTradedPriceInBNB: null,\n        tradeVolumeBNB: null,\n        totalTrades: null,\n        otherId: null,\n      }\n    )\n  })\n  return walletNftsWithMarketData\n}\n\n/**\n * Attach TokenMarketData and location to NftToken\n * @param nftsWithMetadata NftToken[] with API metadata\n * @param nftsForSale  market data for nfts that are on sale (i.e. not in a user's wallet)\n * @param walletNfts makret data for nfts in a user's wallet\n * @param tokenIdsInWallet array of token ids in user's wallet\n * @param tokenIdsForSale array of token ids of nfts that are on sale\n * @param profileNftId profile picture token id\n * @returns NFT[]\n */\nexport const combineNftMarketAndMetadata = (\n  nftsWithMetadata: NftToken[],\n  nftsForSale: TokenMarketData[],\n  walletNfts: TokenMarketData[],\n  tokenIdsInWallet: string[],\n  tokenIdsForSale: string[],\n  profileNftId?: string,\n): NftToken[] => {\n  const completeNftData = nftsWithMetadata.map<NftToken>((nft) => {\n    // Get metadata object\n    const isOnSale = nftsForSale.filter((forSaleNft) => forSaleNft.tokenId === nft.tokenId).length > 0\n    let marketData\n    if (isOnSale) {\n      marketData = nftsForSale.find((marketNft) => marketNft.tokenId === nft.tokenId)\n    } else {\n      marketData = walletNfts.find((marketNft) => marketNft.tokenId === nft.tokenId)\n    }\n    const location = getNftLocationForMarketNft(nft.tokenId, tokenIdsInWallet, tokenIdsForSale, profileNftId)\n    return { ...nft, marketData, location }\n  })\n  return completeNftData\n}\n\n/**\n * Get in-wallet, on-sale & profile pic NFT metadata, complete with market data for a given account\n * @param account\n * @param collections\n * @param profileNftWithCollectionAddress\n * @returns Promise<NftToken[]>\n */\nexport const getCompleteAccountNftData = async (\n  account: string,\n  collections: ApiCollections,\n  profileNftWithCollectionAddress?: TokenIdWithCollectionAddress,\n): Promise<NftToken[]> => {\n  const walletNftIds = await fetchWalletTokenIdsForCollections(account, collections)\n  if (profileNftWithCollectionAddress?.tokenId) {\n    walletNftIds.push(profileNftWithCollectionAddress)\n  }\n  const tokenIds = walletNftIds.map((nft) => nft.tokenId)\n\n  const marketDataForWalletNfts = await getNftsMarketData({ tokenId_in: tokenIds })\n  const walletNftsWithMarketData = attachMarketDataToWalletNfts(walletNftIds, marketDataForWalletNfts)\n\n  const tokenIdsInWallet = walletNftIds\n    .filter((walletNft) => {\n      // Profile Pic NFT is included in walletNftIds array, hence this filter\n      return profileNftWithCollectionAddress?.tokenId !== walletNft.tokenId\n    })\n    .map((nft) => nft.tokenId)\n\n  const marketDataForSaleNfts = await getNftsMarketData({ currentSeller: account.toLowerCase() })\n  const tokenIdsForSale = marketDataForSaleNfts.map((nft) => nft.tokenId)\n\n  const forSaleNftIds = marketDataForSaleNfts.map((nft) => {\n    return { collectionAddress: nft.collection.id, tokenId: nft.tokenId }\n  })\n\n  const metadataForAllNfts = await getNftsFromDifferentCollectionsApi([...walletNftIds, ...forSaleNftIds])\n\n  const completeNftData = combineNftMarketAndMetadata(\n    metadataForAllNfts,\n    marketDataForSaleNfts,\n    walletNftsWithMarketData,\n    tokenIdsInWallet,\n    tokenIdsForSale,\n    profileNftWithCollectionAddress?.tokenId,\n  )\n\n  return completeNftData\n}\n"]},"metadata":{},"sourceType":"module"}