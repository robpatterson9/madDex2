{"ast":null,"code":"import{useEffect,useMemo}from'react';import isEmpty from'lodash/isEmpty';import{useAppDispatch}from'state';import{fetchUserNfts}from'state/nftMarket/reducer';import{useGetCollections,useUserNfts}from'state/nftMarket/hooks';import usePreviousValue from'hooks/usePreviousValue';import{useProfile}from'state/profile/hooks';import{NftLocation,UserNftInitializationState}from'state/nftMarket/types';// We need to fetch collectibles for non-connected accounts, hence this hook accepts an account string.\nvar useFetchUserNfts=function useFetchUserNfts(account){var _profile$tokenId;var dispatch=useAppDispatch();var _useProfile=useProfile(),profile=_useProfile.profile,isProfileInitialized=_useProfile.isInitialized,isProfileLoading=_useProfile.isLoading;var _useUserNfts=useUserNfts(),userNftsInitializationState=_useUserNfts.userNftsInitializationState;var collections=useGetCollections();var hasProfileNft=profile===null||profile===void 0?void 0:profile.tokenId;var profileNftTokenId=profile===null||profile===void 0?void 0:(_profile$tokenId=profile.tokenId)===null||_profile$tokenId===void 0?void 0:_profile$tokenId.toString();var profileNftCollectionAddress=profile===null||profile===void 0?void 0:profile.collectionAddress;var profileNftWithCollectionAddress=useMemo(function(){if(hasProfileNft){return{tokenId:profileNftTokenId,collectionAddress:profileNftCollectionAddress,nftLocation:NftLocation.PROFILE};}return null;},[profileNftTokenId,profileNftCollectionAddress,hasProfileNft]);var previousProfileNftTokenId=usePreviousValue(profileNftTokenId);// Fetch on first load when profile fetch is resolved\nvar shouldFetch=account&&userNftsInitializationState===UserNftInitializationState.UNINITIALIZED&&isProfileInitialized&&!isProfileLoading;// Fetch on account / profile change, once profile fetch is resolved\nvar hasAccountSwitched=previousProfileNftTokenId!==profileNftTokenId&&!isProfileLoading;useEffect(function(){if((shouldFetch||hasAccountSwitched)&&!isEmpty(collections)){dispatch(fetchUserNfts({account:account,collections:collections,profileNftWithCollectionAddress:profileNftWithCollectionAddress}));}},[dispatch,account,shouldFetch,hasAccountSwitched,profileNftTokenId,collections,profileNftWithCollectionAddress]);};export default useFetchUserNfts;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/views/Nft/market/Profile/hooks/useFetchUserNfts.tsx"],"names":["useEffect","useMemo","isEmpty","useAppDispatch","fetchUserNfts","useGetCollections","useUserNfts","usePreviousValue","useProfile","NftLocation","UserNftInitializationState","useFetchUserNfts","account","dispatch","profile","isProfileInitialized","isInitialized","isProfileLoading","isLoading","userNftsInitializationState","collections","hasProfileNft","tokenId","profileNftTokenId","toString","profileNftCollectionAddress","collectionAddress","profileNftWithCollectionAddress","nftLocation","PROFILE","previousProfileNftTokenId","shouldFetch","UNINITIALIZED","hasAccountSwitched"],"mappings":"AAAA,OAASA,SAAT,CAAoBC,OAApB,KAAmC,OAAnC,CACA,MAAOC,CAAAA,OAAP,KAAoB,gBAApB,CACA,OAASC,cAAT,KAA+B,OAA/B,CACA,OAASC,aAAT,KAA8B,yBAA9B,CACA,OAASC,iBAAT,CAA4BC,WAA5B,KAA+C,uBAA/C,CACA,MAAOC,CAAAA,gBAAP,KAA6B,wBAA7B,CACA,OAASC,UAAT,KAA2B,qBAA3B,CACA,OAASC,WAAT,CAAsBC,0BAAtB,KAAwD,uBAAxD,CAEA;AACA,GAAMC,CAAAA,gBAAgB,CAAG,QAAnBA,CAAAA,gBAAmB,CAACC,OAAD,CAAqB,sBAC5C,GAAMC,CAAAA,QAAQ,CAAGV,cAAc,EAA/B,CACA,gBAAsFK,UAAU,EAAhG,CAAQM,OAAR,aAAQA,OAAR,CAAgCC,oBAAhC,aAAiBC,aAAjB,CAAiEC,gBAAjE,aAAsDC,SAAtD,CACA,iBAAwCZ,WAAW,EAAnD,CAAQa,2BAAR,cAAQA,2BAAR,CACA,GAAMC,CAAAA,WAAW,CAAGf,iBAAiB,EAArC,CAEA,GAAMgB,CAAAA,aAAa,CAAGP,OAAH,SAAGA,OAAH,iBAAGA,OAAO,CAAEQ,OAA/B,CACA,GAAMC,CAAAA,iBAAiB,CAAGT,OAAH,SAAGA,OAAH,mCAAGA,OAAO,CAAEQ,OAAZ,2CAAG,iBAAkBE,QAAlB,EAA1B,CACA,GAAMC,CAAAA,2BAA2B,CAAGX,OAAH,SAAGA,OAAH,iBAAGA,OAAO,CAAEY,iBAA7C,CAEA,GAAMC,CAAAA,+BAA+B,CAAG1B,OAAO,CAAC,UAAM,CACpD,GAAIoB,aAAJ,CAAmB,CACjB,MAAO,CACLC,OAAO,CAAEC,iBADJ,CAELG,iBAAiB,CAAED,2BAFd,CAGLG,WAAW,CAAEnB,WAAW,CAACoB,OAHpB,CAAP,CAKD,CACD,MAAO,KAAP,CACD,CAT8C,CAS5C,CAACN,iBAAD,CAAoBE,2BAApB,CAAiDJ,aAAjD,CAT4C,CAA/C,CAWA,GAAMS,CAAAA,yBAAyB,CAAGvB,gBAAgB,CAACgB,iBAAD,CAAlD,CAEA;AACA,GAAMQ,CAAAA,WAAW,CACfnB,OAAO,EACPO,2BAA2B,GAAKT,0BAA0B,CAACsB,aAD3D,EAEAjB,oBAFA,EAGA,CAACE,gBAJH,CAMA;AACA,GAAMgB,CAAAA,kBAAkB,CAAGH,yBAAyB,GAAKP,iBAA9B,EAAmD,CAACN,gBAA/E,CAEAjB,SAAS,CAAC,UAAM,CACd,GAAI,CAAC+B,WAAW,EAAIE,kBAAhB,GAAuC,CAAC/B,OAAO,CAACkB,WAAD,CAAnD,CAAkE,CAChEP,QAAQ,CAACT,aAAa,CAAC,CAAEQ,OAAO,CAAPA,OAAF,CAAWQ,WAAW,CAAXA,WAAX,CAAwBO,+BAA+B,CAA/BA,+BAAxB,CAAD,CAAd,CAAR,CACD,CACF,CAJQ,CAIN,CACDd,QADC,CAEDD,OAFC,CAGDmB,WAHC,CAIDE,kBAJC,CAKDV,iBALC,CAMDH,WANC,CAODO,+BAPC,CAJM,CAAT,CAaD,CA9CD,CAgDA,cAAehB,CAAAA,gBAAf","sourcesContent":["import { useEffect, useMemo } from 'react'\nimport isEmpty from 'lodash/isEmpty'\nimport { useAppDispatch } from 'state'\nimport { fetchUserNfts } from 'state/nftMarket/reducer'\nimport { useGetCollections, useUserNfts } from 'state/nftMarket/hooks'\nimport usePreviousValue from 'hooks/usePreviousValue'\nimport { useProfile } from 'state/profile/hooks'\nimport { NftLocation, UserNftInitializationState } from 'state/nftMarket/types'\n\n// We need to fetch collectibles for non-connected accounts, hence this hook accepts an account string.\nconst useFetchUserNfts = (account: string) => {\n  const dispatch = useAppDispatch()\n  const { profile, isInitialized: isProfileInitialized, isLoading: isProfileLoading } = useProfile()\n  const { userNftsInitializationState } = useUserNfts()\n  const collections = useGetCollections()\n\n  const hasProfileNft = profile?.tokenId\n  const profileNftTokenId = profile?.tokenId?.toString()\n  const profileNftCollectionAddress = profile?.collectionAddress\n\n  const profileNftWithCollectionAddress = useMemo(() => {\n    if (hasProfileNft) {\n      return {\n        tokenId: profileNftTokenId,\n        collectionAddress: profileNftCollectionAddress,\n        nftLocation: NftLocation.PROFILE,\n      }\n    }\n    return null\n  }, [profileNftTokenId, profileNftCollectionAddress, hasProfileNft])\n\n  const previousProfileNftTokenId = usePreviousValue(profileNftTokenId)\n\n  // Fetch on first load when profile fetch is resolved\n  const shouldFetch =\n    account &&\n    userNftsInitializationState === UserNftInitializationState.UNINITIALIZED &&\n    isProfileInitialized &&\n    !isProfileLoading\n\n  // Fetch on account / profile change, once profile fetch is resolved\n  const hasAccountSwitched = previousProfileNftTokenId !== profileNftTokenId && !isProfileLoading\n\n  useEffect(() => {\n    if ((shouldFetch || hasAccountSwitched) && !isEmpty(collections)) {\n      dispatch(fetchUserNfts({ account, collections, profileNftWithCollectionAddress }))\n    }\n  }, [\n    dispatch,\n    account,\n    shouldFetch,\n    hasAccountSwitched,\n    profileNftTokenId,\n    collections,\n    profileNftWithCollectionAddress,\n  ])\n}\n\nexport default useFetchUserNfts\n"]},"metadata":{},"sourceType":"module"}