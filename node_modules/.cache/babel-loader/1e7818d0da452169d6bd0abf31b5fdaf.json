{"ast":null,"code":"import { request, gql } from 'graphql-request';\nimport { GRAPH_API_NFTMARKET, API_NFT } from 'config/constants/endpoints';\nimport { getErc721Contract } from 'utils/contractHelpers';\nimport map from 'lodash/map';\nimport { pancakeBunniesAddress } from 'views/Nft/market/constants';\nimport { NftLocation } from './types';\nimport { getBaseNftFields, getBaseTransactionFields, getCollectionBaseFields } from './queries';\n/**\n * API HELPERS\n */\n\n/**\n * Fetch static data from all collections using the API\n * @returns\n */\n\nexport const getCollectionsApi = async () => {\n  const res = await fetch(`${API_NFT}/collections`);\n\n  if (res.ok) {\n    const json = await res.json();\n    return json.data;\n  }\n\n  console.error('Failed to fetch NFT collections', res.statusText);\n  return [];\n};\n/**\n * Fetch static data from a collection using the API\n * @returns\n */\n\nexport const getCollectionApi = async collectionAddress => {\n  const res = await fetch(`${API_NFT}/collections/${collectionAddress}`);\n\n  if (res.ok) {\n    const json = await res.json();\n    return json.data;\n  }\n\n  console.error(`API: Failed to fetch NFT collection ${collectionAddress}`, res.statusText);\n  return null;\n};\n/**\n * Fetch static data for all nfts in a collection using the API\n * @param collectionAddress\n * @returns\n */\n\nexport const getNftsFromCollectionApi = async collectionAddress => {\n  const res = await fetch(`${API_NFT}/collections/${collectionAddress}/tokens`);\n\n  if (res.ok) {\n    const data = await res.json();\n    return data;\n  }\n\n  console.error(`API: Failed to fetch NFT tokens for ${collectionAddress} collection`, res.statusText);\n  return null;\n};\n/**\n * Fetch a single NFT using the API\n * @param collectionAddress\n * @param tokenId\n * @returns NFT from API\n */\n\nexport const getNftApi = async (collectionAddress, tokenId) => {\n  const res = await fetch(`${API_NFT}/collections/${collectionAddress}/tokens/${tokenId}`);\n\n  if (res.ok) {\n    const json = await res.json();\n    return json.data;\n  }\n\n  console.error(`API: Can't fetch NFT token ${tokenId} in ${collectionAddress}`, res.status);\n  return null;\n};\n/**\n * Fetch a list of NFT from different collections\n * @param from Array of { collectionAddress: string; tokenId: string }\n * @returns Array of NFT from API\n */\n\nexport const getNftsFromDifferentCollectionsApi = async from => {\n  const promises = from.map(nft => getNftApi(nft.collectionAddress, nft.tokenId));\n  const responses = await Promise.all(promises); // Sometimes API can't find some tokens (e.g. 404 response)\n  // at least return the ones that returned successfully\n\n  return responses.filter(resp => resp).map((res, index) => {\n    var _res$image, _res$image2;\n\n    return {\n      tokenId: res.tokenId,\n      name: res.name,\n      collectionName: res.collection.name,\n      collectionAddress: from[index].collectionAddress,\n      description: res.description,\n      attributes: res.attributes,\n      createdAt: res.createdAt,\n      updatedAt: res.updatedAt,\n      image: {\n        original: (_res$image = res.image) === null || _res$image === void 0 ? void 0 : _res$image.original,\n        thumbnail: (_res$image2 = res.image) === null || _res$image2 === void 0 ? void 0 : _res$image2.thumbnail\n      }\n    };\n  });\n};\n/**\n * SUBGRAPH HELPERS\n */\n\n/**\n * Fetch market data from a collection using the Subgraph\n * @returns\n */\n\nexport const getCollectionSg = async collectionAddress => {\n  try {\n    const res = await request(GRAPH_API_NFTMARKET, gql`\n        query getCollectionData($collectionAddress: String!) {\n          collection(id: $collectionAddress) {\n            ${getCollectionBaseFields()}\n          }\n        }\n      `, {\n      collectionAddress: collectionAddress.toLowerCase()\n    });\n    return res.collection;\n  } catch (error) {\n    console.error('Failed to fetch collection', error);\n    return null;\n  }\n};\n/**\n * Fetch market data from all collections using the Subgraph\n * @returns\n */\n\nexport const getCollectionsSg = async () => {\n  try {\n    const res = await request(GRAPH_API_NFTMARKET, gql`\n        {\n          collections {\n            ${getCollectionBaseFields()}\n          }\n        }\n      `);\n    return res.collections;\n  } catch (error) {\n    console.error('Failed to fetch NFT collections', error);\n    return [];\n  }\n};\n/**\n * Fetch market data for all nfts in a collection using the Subgraph\n * @param collectionAddress\n * @returns\n */\n\nexport const getNftsFromCollectionSg = async collectionAddress => {\n  try {\n    const res = await request(GRAPH_API_NFTMARKET, gql`\n        query getNftCollectionMarketData($collectionAddress: String!) {\n          collection(id: $collectionAddress) {\n            id\n            nfts {\n             ${getBaseNftFields()}\n            }\n          }\n        }\n      `, {\n      collectionAddress: collectionAddress.toLowerCase()\n    });\n    return res.collection.nfts;\n  } catch (error) {\n    console.error('Failed to fetch NFTs from collection', error);\n    return [];\n  }\n};\n/**\n * Fetch market data for PancakeBunnies NFTs by bunny id using the Subgraph\n * @param bunnyId - bunny id to query\n * @param existingTokenIds - tokens that are already loaded into redux\n * @returns\n */\n\nexport const getNftsByBunnyIdSg = async (bunnyId, existingTokenIds, orderDirection) => {\n  try {\n    const where = existingTokenIds.length > 0 ? {\n      otherId: bunnyId,\n      isTradable: true,\n      tokenId_not_in: existingTokenIds\n    } : {\n      otherId: bunnyId,\n      isTradable: true\n    };\n    const res = await request(GRAPH_API_NFTMARKET, gql`\n        query getNftsByBunnyIdSg($collectionAddress: String!, $where: NFT_filter, $orderDirection: String!) {\n          nfts(first: 30, where: $where, orderBy: currentAskPrice, orderDirection: $orderDirection) {\n            ${getBaseNftFields()}\n          }\n        }\n      `, {\n      collectionAddress: pancakeBunniesAddress.toLowerCase(),\n      where,\n      orderDirection\n    });\n    return res.nfts;\n  } catch (error) {\n    console.error(`Failed to fetch collection NFTs for bunny id ${bunnyId}`, error);\n    return [];\n  }\n};\n/**\n * Fetch market data for PancakeBunnies NFTs by bunny id using the Subgraph\n * @param bunnyId - bunny id to query\n * @param existingTokenIds - tokens that are already loaded into redux\n * @returns\n */\n\nexport const getMarketDataForTokenIds = async (collectionAddress, existingTokenIds) => {\n  try {\n    if (existingTokenIds.length === 0) {\n      return [];\n    }\n\n    const res = await request(GRAPH_API_NFTMARKET, gql`\n        query getMarketDataForTokenIds($collectionAddress: String!, $where: NFT_filter) {\n          nfts(first: 1000, where: $where) {\n            ${getBaseNftFields()}\n          }\n        }\n      `, {\n      collectionAddress: collectionAddress.toLowerCase(),\n      where: {\n        tokenId_not_in: existingTokenIds\n      }\n    });\n    return res.nfts;\n  } catch (error) {\n    console.error(`Failed to fetch market data for NFTs stored tokens`, error);\n    return [];\n  }\n};\nexport const getNftsMarketData = async (where = {}, first = 1000, orderBy = 'id', orderDirection = 'desc', skip = 0) => {\n  try {\n    const res = await request(GRAPH_API_NFTMARKET, gql`\n        query getNftsMarketData($first: Int, $skip: Int!, $where: NFT_filter, $orderBy: NFT_orderBy, $orderDirection: OrderDirection) {\n          nfts(where: $where, orderBy: $orderBy, orderDirection: $orderDirection, skip: $skip) {\n            ${getBaseNftFields()}\n            transactionHistory {\n              ${getBaseTransactionFields()}\n            }\n          }\n        }\n      `, {\n      where,\n      first,\n      skip,\n      orderBy,\n      orderDirection\n    });\n    return res.nfts;\n  } catch (error) {\n    console.error('Failed to fetch NFTs market data', error);\n    return [];\n  }\n};\nexport const getAllPancakeBunniesLowestPrice = async bunnyIds => {\n  try {\n    const singlePancakeBunnySubQueries = bunnyIds.map(bunnyId => `b${bunnyId}:nfts(first: 1, where: { otherId: ${bunnyId}, isTradable: true }, orderBy: currentAskPrice, orderDirection: asc) {\n        currentAskPrice\n      }\n    `);\n    const rawResponse = await request(GRAPH_API_NFTMARKET, gql`\n        query getAllPancakeBunniesLowestPrice {\n          ${singlePancakeBunnySubQueries}\n        }\n      `);\n    return Object.keys(rawResponse).reduce((lowestPricesData, subQueryKey) => {\n      const bunnyId = subQueryKey.split('b')[1];\n      return { ...lowestPricesData,\n        [bunnyId]: rawResponse[subQueryKey].length > 0 ? parseFloat(rawResponse[subQueryKey][0].currentAskPrice) : Infinity\n      };\n    }, {});\n  } catch (error) {\n    console.error('Failed to fetch PancakeBunnies lowest prices', error);\n    return {};\n  }\n};\nexport const getAllPancakeBunniesRecentUpdatedAt = async bunnyIds => {\n  try {\n    const singlePancakeBunnySubQueries = bunnyIds.map(bunnyId => `b${bunnyId}:nfts(first: 1, where: { otherId: ${bunnyId}, isTradable: true }, orderBy: updatedAt, orderDirection: desc) {\n        updatedAt\n      }\n    `);\n    const rawResponse = await request(GRAPH_API_NFTMARKET, gql`\n        query getAllPancakeBunniesLowestPrice {\n          ${singlePancakeBunnySubQueries}\n        }\n      `);\n    return Object.keys(rawResponse).reduce((updatedAtData, subQueryKey) => {\n      const bunnyId = subQueryKey.split('b')[1];\n      return { ...updatedAtData,\n        [bunnyId]: rawResponse[subQueryKey].length > 0 ? Number(rawResponse[subQueryKey][0].updatedAt) : -Infinity\n      };\n    }, {});\n  } catch (error) {\n    console.error('Failed to fetch PancakeBunnies latest market updates', error);\n    return {};\n  }\n};\n/**\n * Returns the lowest price of any NFT in a collection\n */\n\nexport const getLowestPriceInCollection = async collectionAddress => {\n  try {\n    const response = await getNftsMarketData({\n      collection: collectionAddress.toLowerCase(),\n      isTradable: true\n    }, 1, 'currentAskPrice', 'asc');\n\n    if (response.length === 0) {\n      return 0;\n    }\n\n    const [nftSg] = response;\n    return parseFloat(nftSg.currentAskPrice);\n  } catch (error) {\n    console.error(`Failed to lowest price NFTs in collection ${collectionAddress}`, error);\n    return 0;\n  }\n};\n/**\n * Fetch user trading data for buyTradeHistory, sellTradeHistory and askOrderHistory from the Subgraph\n * @param where a User_filter where condition\n * @returns a UserActivity object\n */\n\nexport const getUserActivity = async address => {\n  try {\n    const res = await request(GRAPH_API_NFTMARKET, gql`\n        query getUserActivity($address: String!) {\n          user(id: $address) {\n            buyTradeHistory(first: 250, orderBy: timestamp, orderDirection: desc) {\n              ${getBaseTransactionFields()}\n              nft {\n                ${getBaseNftFields()}\n              }\n            }\n            sellTradeHistory(first: 250, orderBy: timestamp, orderDirection: desc) {\n              ${getBaseTransactionFields()}\n              nft {\n                ${getBaseNftFields()}\n              }\n            }\n            askOrderHistory(first: 500, orderBy: timestamp, orderDirection: desc) {\n              id\n              block\n              timestamp\n              orderType\n              askPrice\n              nft {\n                ${getBaseNftFields()}\n              }\n            }\n          }\n        }\n      `, {\n      address\n    });\n    return res.user || {\n      askOrderHistory: [],\n      buyTradeHistory: [],\n      sellTradeHistory: []\n    };\n  } catch (error) {\n    console.error('Failed to fetch user Activity', error);\n    return {\n      askOrderHistory: [],\n      buyTradeHistory: [],\n      sellTradeHistory: []\n    };\n  }\n};\n/**\n * Get the most recently listed NFTs\n * @param first Number of nfts to retrieve\n * @returns NftTokenSg[]\n */\n\nexport const getLatestListedNfts = async first => {\n  try {\n    const res = await request(GRAPH_API_NFTMARKET, gql`\n        query getLatestNftMarketData($first: Int) {\n          nfts(where: { isTradable: true }, orderBy: updatedAt , orderDirection: desc, first: $first) {\n            ${getBaseNftFields()}\n            collection {\n              id\n            }\n          }\n        }\n      `, {\n      first\n    });\n    return res.nfts;\n  } catch (error) {\n    console.error('Failed to fetch NFTs market data', error);\n    return [];\n  }\n};\n/**\n * OTHER HELPERS\n */\n\nexport const fetchWalletTokenIdsForCollections = async (account, collections) => {\n  const walletNftPromises = map(collections, async collection => {\n    const {\n      address: collectionAddress\n    } = collection;\n    const contract = getErc721Contract(collectionAddress);\n    let balanceOfResponse;\n\n    try {\n      balanceOfResponse = await contract.balanceOf(account);\n    } catch (e) {\n      console.error(e);\n      return [];\n    }\n\n    const balanceOf = balanceOfResponse.toNumber(); // User has no NFTs for this collection\n\n    if (balanceOfResponse.eq(0)) {\n      return [];\n    }\n\n    const getTokenId = async index => {\n      try {\n        const tokenIdBn = await contract.tokenOfOwnerByIndex(account, index);\n        const tokenId = tokenIdBn.toString();\n        return tokenId;\n      } catch (error) {\n        console.error('getTokenIdAndData', error);\n        return null;\n      }\n    };\n\n    const tokenIdPromises = []; // For each index get the tokenId\n\n    for (let i = 0; i < balanceOf; i++) {\n      tokenIdPromises.push(getTokenId(i));\n    }\n\n    const tokenIds = await Promise.all(tokenIdPromises);\n    const nftLocation = NftLocation.WALLET;\n    const tokensWithCollectionAddress = tokenIds.map(tokenId => {\n      return {\n        tokenId,\n        collectionAddress,\n        nftLocation\n      };\n    });\n    return tokensWithCollectionAddress;\n  });\n  const walletNfts = await Promise.all(walletNftPromises);\n  return walletNfts.flat();\n};\n/**\n * Helper to combine data from the collections' API and subgraph\n */\n\nexport const combineCollectionData = (collectionApiData, collectionSgData) => {\n  const collectionsMarketObj = collectionSgData.reduce((prev, current) => ({ ...prev,\n    [current.id]: { ...current\n    }\n  }), {});\n  return collectionApiData.reduce((accum, current) => {\n    const collectionMarket = collectionsMarketObj[current.address.toLowerCase()];\n    const collection = { ...current,\n      ...collectionMarket\n    };\n    return { ...accum,\n      [current.address]: collection\n    };\n  }, {});\n};\n/**\n * Evaluate whether a market NFT is in a users wallet, their profile picture, or on sale\n * @param tokenId string\n * @param tokenIdsInWallet array of tokenIds in wallet\n * @param tokenIdsForSale array of tokenIds on sale\n * @param profileNftId Optional tokenId of users' profile picture\n * @returns NftLocation enum value\n */\n\nexport const getNftLocationForMarketNft = (tokenId, tokenIdsInWallet, tokenIdsForSale, profileNftId) => {\n  if (tokenId === profileNftId) {\n    return NftLocation.PROFILE;\n  }\n\n  if (tokenIdsForSale.includes(tokenId)) {\n    return NftLocation.FORSALE;\n  }\n\n  if (tokenIdsInWallet.includes(tokenId)) {\n    return NftLocation.WALLET;\n  }\n\n  console.error(`Cannot determine location for tokenID ${tokenId}, defaulting to NftLocation.WALLET`);\n  return NftLocation.WALLET;\n};\n/**\n * Construct complete TokenMarketData entities with a users' wallet NFT ids and market data for their wallet NFTs\n * @param walletNfts TokenIdWithCollectionAddress\n * @param marketDataForWalletNfts TokenMarketData[]\n * @returns TokenMarketData[]\n */\n\nexport const attachMarketDataToWalletNfts = (walletNfts, marketDataForWalletNfts) => {\n  const walletNftsWithMarketData = walletNfts.map(walletNft => {\n    const marketData = marketDataForWalletNfts.find(marketNft => marketNft.tokenId === walletNft.tokenId);\n    return marketData !== null && marketData !== void 0 ? marketData : {\n      tokenId: walletNft.tokenId,\n      collection: {\n        id: walletNft.collectionAddress.toLowerCase()\n      },\n      nftLocation: walletNft.nftLocation,\n      metadataUrl: null,\n      transactionHistory: null,\n      currentSeller: null,\n      isTradable: null,\n      currentAskPrice: null,\n      latestTradedPriceInBNB: null,\n      tradeVolumeBNB: null,\n      totalTrades: null,\n      otherId: null\n    };\n  });\n  return walletNftsWithMarketData;\n};\n/**\n * Attach TokenMarketData and location to NftToken\n * @param nftsWithMetadata NftToken[] with API metadata\n * @param nftsForSale  market data for nfts that are on sale (i.e. not in a user's wallet)\n * @param walletNfts makret data for nfts in a user's wallet\n * @param tokenIdsInWallet array of token ids in user's wallet\n * @param tokenIdsForSale array of token ids of nfts that are on sale\n * @param profileNftId profile picture token id\n * @returns NFT[]\n */\n\nexport const combineNftMarketAndMetadata = (nftsWithMetadata, nftsForSale, walletNfts, tokenIdsInWallet, tokenIdsForSale, profileNftId) => {\n  const completeNftData = nftsWithMetadata.map(nft => {\n    // Get metadata object\n    const isOnSale = nftsForSale.filter(forSaleNft => forSaleNft.tokenId === nft.tokenId).length > 0;\n    let marketData;\n\n    if (isOnSale) {\n      marketData = nftsForSale.find(marketNft => marketNft.tokenId === nft.tokenId);\n    } else {\n      marketData = walletNfts.find(marketNft => marketNft.tokenId === nft.tokenId);\n    }\n\n    const location = getNftLocationForMarketNft(nft.tokenId, tokenIdsInWallet, tokenIdsForSale, profileNftId);\n    return { ...nft,\n      marketData,\n      location\n    };\n  });\n  return completeNftData;\n};\n/**\n * Get in-wallet, on-sale & profile pic NFT metadata, complete with market data for a given account\n * @param account\n * @param collections\n * @param profileNftWithCollectionAddress\n * @returns Promise<NftToken[]>\n */\n\nexport const getCompleteAccountNftData = async (account, collections, profileNftWithCollectionAddress) => {\n  const walletNftIds = await fetchWalletTokenIdsForCollections(account, collections);\n\n  if (profileNftWithCollectionAddress === null || profileNftWithCollectionAddress === void 0 ? void 0 : profileNftWithCollectionAddress.tokenId) {\n    walletNftIds.push(profileNftWithCollectionAddress);\n  }\n\n  const tokenIds = walletNftIds.map(nft => nft.tokenId);\n  const marketDataForWalletNfts = await getNftsMarketData({\n    tokenId_in: tokenIds\n  });\n  const walletNftsWithMarketData = attachMarketDataToWalletNfts(walletNftIds, marketDataForWalletNfts);\n  const tokenIdsInWallet = walletNftIds.filter(walletNft => {\n    // Profile Pic NFT is included in walletNftIds array, hence this filter\n    return (profileNftWithCollectionAddress === null || profileNftWithCollectionAddress === void 0 ? void 0 : profileNftWithCollectionAddress.tokenId) !== walletNft.tokenId;\n  }).map(nft => nft.tokenId);\n  const marketDataForSaleNfts = await getNftsMarketData({\n    currentSeller: account.toLowerCase()\n  });\n  const tokenIdsForSale = marketDataForSaleNfts.map(nft => nft.tokenId);\n  const forSaleNftIds = marketDataForSaleNfts.map(nft => {\n    return {\n      collectionAddress: nft.collection.id,\n      tokenId: nft.tokenId\n    };\n  });\n  const metadataForAllNfts = await getNftsFromDifferentCollectionsApi([...walletNftIds, ...forSaleNftIds]);\n  const completeNftData = combineNftMarketAndMetadata(metadataForAllNfts, marketDataForSaleNfts, walletNftsWithMarketData, tokenIdsInWallet, tokenIdsForSale, profileNftWithCollectionAddress === null || profileNftWithCollectionAddress === void 0 ? void 0 : profileNftWithCollectionAddress.tokenId);\n  return completeNftData;\n};","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/nftMarket/helpers.ts"],"names":["request","gql","GRAPH_API_NFTMARKET","API_NFT","getErc721Contract","map","pancakeBunniesAddress","NftLocation","getBaseNftFields","getBaseTransactionFields","getCollectionBaseFields","getCollectionsApi","res","fetch","ok","json","data","console","error","statusText","getCollectionApi","collectionAddress","getNftsFromCollectionApi","getNftApi","tokenId","status","getNftsFromDifferentCollectionsApi","from","promises","nft","responses","Promise","all","filter","resp","index","name","collectionName","collection","description","attributes","createdAt","updatedAt","image","original","thumbnail","getCollectionSg","toLowerCase","getCollectionsSg","collections","getNftsFromCollectionSg","nfts","getNftsByBunnyIdSg","bunnyId","existingTokenIds","orderDirection","where","length","otherId","isTradable","tokenId_not_in","getMarketDataForTokenIds","getNftsMarketData","first","orderBy","skip","getAllPancakeBunniesLowestPrice","bunnyIds","singlePancakeBunnySubQueries","rawResponse","Object","keys","reduce","lowestPricesData","subQueryKey","split","parseFloat","currentAskPrice","Infinity","getAllPancakeBunniesRecentUpdatedAt","updatedAtData","Number","getLowestPriceInCollection","response","nftSg","getUserActivity","address","user","askOrderHistory","buyTradeHistory","sellTradeHistory","getLatestListedNfts","fetchWalletTokenIdsForCollections","account","walletNftPromises","contract","balanceOfResponse","balanceOf","e","toNumber","eq","getTokenId","tokenIdBn","tokenOfOwnerByIndex","toString","tokenIdPromises","i","push","tokenIds","nftLocation","WALLET","tokensWithCollectionAddress","walletNfts","flat","combineCollectionData","collectionApiData","collectionSgData","collectionsMarketObj","prev","current","id","accum","collectionMarket","getNftLocationForMarketNft","tokenIdsInWallet","tokenIdsForSale","profileNftId","PROFILE","includes","FORSALE","attachMarketDataToWalletNfts","marketDataForWalletNfts","walletNftsWithMarketData","walletNft","marketData","find","marketNft","metadataUrl","transactionHistory","currentSeller","latestTradedPriceInBNB","tradeVolumeBNB","totalTrades","combineNftMarketAndMetadata","nftsWithMetadata","nftsForSale","completeNftData","isOnSale","forSaleNft","location","getCompleteAccountNftData","profileNftWithCollectionAddress","walletNftIds","tokenId_in","marketDataForSaleNfts","forSaleNftIds","metadataForAllNfts"],"mappings":"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","sourcesContent":["import { request, gql } from 'graphql-request'\nimport { GRAPH_API_NFTMARKET, API_NFT } from 'config/constants/endpoints'\nimport { getErc721Contract } from 'utils/contractHelpers'\nimport { ethers } from 'ethers'\nimport map from 'lodash/map'\nimport { pancakeBunniesAddress } from 'views/Nft/market/constants'\nimport {\n  TokenMarketData,\n  ApiCollections,\n  TokenIdWithCollectionAddress,\n  NftToken,\n  NftLocation,\n  Collection,\n  ApiResponseCollectionTokens,\n  ApiResponseSpecificToken,\n  ApiCollection,\n  CollectionMarketDataBaseFields,\n  Transaction,\n  AskOrder,\n} from './types'\nimport { getBaseNftFields, getBaseTransactionFields, getCollectionBaseFields } from './queries'\n\n/**\n * API HELPERS\n */\n\n/**\n * Fetch static data from all collections using the API\n * @returns\n */\nexport const getCollectionsApi = async (): Promise<ApiCollection[]> => {\n  const res = await fetch(`${API_NFT}/collections`)\n  if (res.ok) {\n    const json = await res.json()\n    return json.data\n  }\n  console.error('Failed to fetch NFT collections', res.statusText)\n  return []\n}\n\n/**\n * Fetch static data from a collection using the API\n * @returns\n */\nexport const getCollectionApi = async (collectionAddress: string): Promise<ApiCollection> => {\n  const res = await fetch(`${API_NFT}/collections/${collectionAddress}`)\n  if (res.ok) {\n    const json = await res.json()\n    return json.data\n  }\n  console.error(`API: Failed to fetch NFT collection ${collectionAddress}`, res.statusText)\n  return null\n}\n\n/**\n * Fetch static data for all nfts in a collection using the API\n * @param collectionAddress\n * @returns\n */\nexport const getNftsFromCollectionApi = async (collectionAddress: string): Promise<ApiResponseCollectionTokens> => {\n  const res = await fetch(`${API_NFT}/collections/${collectionAddress}/tokens`)\n  if (res.ok) {\n    const data = await res.json()\n    return data\n  }\n  console.error(`API: Failed to fetch NFT tokens for ${collectionAddress} collection`, res.statusText)\n  return null\n}\n\n/**\n * Fetch a single NFT using the API\n * @param collectionAddress\n * @param tokenId\n * @returns NFT from API\n */\nexport const getNftApi = async (\n  collectionAddress: string,\n  tokenId: string,\n): Promise<ApiResponseSpecificToken['data']> => {\n  const res = await fetch(`${API_NFT}/collections/${collectionAddress}/tokens/${tokenId}`)\n  if (res.ok) {\n    const json = await res.json()\n    return json.data\n  }\n\n  console.error(`API: Can't fetch NFT token ${tokenId} in ${collectionAddress}`, res.status)\n  return null\n}\n\n/**\n * Fetch a list of NFT from different collections\n * @param from Array of { collectionAddress: string; tokenId: string }\n * @returns Array of NFT from API\n */\nexport const getNftsFromDifferentCollectionsApi = async (\n  from: { collectionAddress: string; tokenId: string }[],\n): Promise<NftToken[]> => {\n  const promises = from.map((nft) => getNftApi(nft.collectionAddress, nft.tokenId))\n  const responses = await Promise.all(promises)\n  // Sometimes API can't find some tokens (e.g. 404 response)\n  // at least return the ones that returned successfully\n  return responses\n    .filter((resp) => resp)\n    .map((res, index) => ({\n      tokenId: res.tokenId,\n      name: res.name,\n      collectionName: res.collection.name,\n      collectionAddress: from[index].collectionAddress,\n      description: res.description,\n      attributes: res.attributes,\n      createdAt: res.createdAt,\n      updatedAt: res.updatedAt,\n      image: {\n        original: res.image?.original,\n        thumbnail: res.image?.thumbnail,\n      },\n    }))\n}\n\n/**\n * SUBGRAPH HELPERS\n */\n\n/**\n * Fetch market data from a collection using the Subgraph\n * @returns\n */\nexport const getCollectionSg = async (collectionAddress: string): Promise<CollectionMarketDataBaseFields> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getCollectionData($collectionAddress: String!) {\n          collection(id: $collectionAddress) {\n            ${getCollectionBaseFields()}\n          }\n        }\n      `,\n      { collectionAddress: collectionAddress.toLowerCase() },\n    )\n    return res.collection\n  } catch (error) {\n    console.error('Failed to fetch collection', error)\n    return null\n  }\n}\n\n/**\n * Fetch market data from all collections using the Subgraph\n * @returns\n */\nexport const getCollectionsSg = async (): Promise<CollectionMarketDataBaseFields[]> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        {\n          collections {\n            ${getCollectionBaseFields()}\n          }\n        }\n      `,\n    )\n    return res.collections\n  } catch (error) {\n    console.error('Failed to fetch NFT collections', error)\n    return []\n  }\n}\n\n/**\n * Fetch market data for all nfts in a collection using the Subgraph\n * @param collectionAddress\n * @returns\n */\nexport const getNftsFromCollectionSg = async (collectionAddress: string): Promise<TokenMarketData[]> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getNftCollectionMarketData($collectionAddress: String!) {\n          collection(id: $collectionAddress) {\n            id\n            nfts {\n             ${getBaseNftFields()}\n            }\n          }\n        }\n      `,\n      { collectionAddress: collectionAddress.toLowerCase() },\n    )\n    return res.collection.nfts\n  } catch (error) {\n    console.error('Failed to fetch NFTs from collection', error)\n    return []\n  }\n}\n\n/**\n * Fetch market data for PancakeBunnies NFTs by bunny id using the Subgraph\n * @param bunnyId - bunny id to query\n * @param existingTokenIds - tokens that are already loaded into redux\n * @returns\n */\nexport const getNftsByBunnyIdSg = async (\n  bunnyId: string,\n  existingTokenIds: string[],\n  orderDirection: 'asc' | 'desc',\n): Promise<TokenMarketData[]> => {\n  try {\n    const where =\n      existingTokenIds.length > 0\n        ? { otherId: bunnyId, isTradable: true, tokenId_not_in: existingTokenIds }\n        : { otherId: bunnyId, isTradable: true }\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getNftsByBunnyIdSg($collectionAddress: String!, $where: NFT_filter, $orderDirection: String!) {\n          nfts(first: 30, where: $where, orderBy: currentAskPrice, orderDirection: $orderDirection) {\n            ${getBaseNftFields()}\n          }\n        }\n      `,\n      {\n        collectionAddress: pancakeBunniesAddress.toLowerCase(),\n        where,\n        orderDirection,\n      },\n    )\n    return res.nfts\n  } catch (error) {\n    console.error(`Failed to fetch collection NFTs for bunny id ${bunnyId}`, error)\n    return []\n  }\n}\n\n/**\n * Fetch market data for PancakeBunnies NFTs by bunny id using the Subgraph\n * @param bunnyId - bunny id to query\n * @param existingTokenIds - tokens that are already loaded into redux\n * @returns\n */\nexport const getMarketDataForTokenIds = async (\n  collectionAddress: string,\n  existingTokenIds: string[],\n): Promise<TokenMarketData[]> => {\n  try {\n    if (existingTokenIds.length === 0) {\n      return []\n    }\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getMarketDataForTokenIds($collectionAddress: String!, $where: NFT_filter) {\n          nfts(first: 1000, where: $where) {\n            ${getBaseNftFields()}\n          }\n        }\n      `,\n      {\n        collectionAddress: collectionAddress.toLowerCase(),\n        where: { tokenId_not_in: existingTokenIds },\n      },\n    )\n    return res.nfts\n  } catch (error) {\n    console.error(`Failed to fetch market data for NFTs stored tokens`, error)\n    return []\n  }\n}\n\nexport const getNftsMarketData = async (\n  where = {},\n  first = 1000,\n  orderBy = 'id',\n  orderDirection: 'asc' | 'desc' = 'desc',\n  skip = 0,\n): Promise<TokenMarketData[]> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getNftsMarketData($first: Int, $skip: Int!, $where: NFT_filter, $orderBy: NFT_orderBy, $orderDirection: OrderDirection) {\n          nfts(where: $where, orderBy: $orderBy, orderDirection: $orderDirection, skip: $skip) {\n            ${getBaseNftFields()}\n            transactionHistory {\n              ${getBaseTransactionFields()}\n            }\n          }\n        }\n      `,\n      { where, first, skip, orderBy, orderDirection },\n    )\n\n    return res.nfts\n  } catch (error) {\n    console.error('Failed to fetch NFTs market data', error)\n    return []\n  }\n}\n\nexport const getAllPancakeBunniesLowestPrice = async (bunnyIds: string[]): Promise<Record<string, number>> => {\n  try {\n    const singlePancakeBunnySubQueries = bunnyIds.map(\n      (\n        bunnyId,\n      ) => `b${bunnyId}:nfts(first: 1, where: { otherId: ${bunnyId}, isTradable: true }, orderBy: currentAskPrice, orderDirection: asc) {\n        currentAskPrice\n      }\n    `,\n    )\n    const rawResponse: Record<string, { currentAskPrice: string }[]> = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getAllPancakeBunniesLowestPrice {\n          ${singlePancakeBunnySubQueries}\n        }\n      `,\n    )\n    return Object.keys(rawResponse).reduce((lowestPricesData, subQueryKey) => {\n      const bunnyId = subQueryKey.split('b')[1]\n      return {\n        ...lowestPricesData,\n        [bunnyId]:\n          rawResponse[subQueryKey].length > 0 ? parseFloat(rawResponse[subQueryKey][0].currentAskPrice) : Infinity,\n      }\n    }, {})\n  } catch (error) {\n    console.error('Failed to fetch PancakeBunnies lowest prices', error)\n    return {}\n  }\n}\n\nexport const getAllPancakeBunniesRecentUpdatedAt = async (bunnyIds: string[]): Promise<Record<string, number>> => {\n  try {\n    const singlePancakeBunnySubQueries = bunnyIds.map(\n      (\n        bunnyId,\n      ) => `b${bunnyId}:nfts(first: 1, where: { otherId: ${bunnyId}, isTradable: true }, orderBy: updatedAt, orderDirection: desc) {\n        updatedAt\n      }\n    `,\n    )\n    const rawResponse: Record<string, { updatedAt: string }[]> = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getAllPancakeBunniesLowestPrice {\n          ${singlePancakeBunnySubQueries}\n        }\n      `,\n    )\n    return Object.keys(rawResponse).reduce((updatedAtData, subQueryKey) => {\n      const bunnyId = subQueryKey.split('b')[1]\n      return {\n        ...updatedAtData,\n        [bunnyId]: rawResponse[subQueryKey].length > 0 ? Number(rawResponse[subQueryKey][0].updatedAt) : -Infinity,\n      }\n    }, {})\n  } catch (error) {\n    console.error('Failed to fetch PancakeBunnies latest market updates', error)\n    return {}\n  }\n}\n\n/**\n * Returns the lowest price of any NFT in a collection\n */\nexport const getLowestPriceInCollection = async (collectionAddress: string) => {\n  try {\n    const response = await getNftsMarketData(\n      { collection: collectionAddress.toLowerCase(), isTradable: true },\n      1,\n      'currentAskPrice',\n      'asc',\n    )\n\n    if (response.length === 0) {\n      return 0\n    }\n\n    const [nftSg] = response\n    return parseFloat(nftSg.currentAskPrice)\n  } catch (error) {\n    console.error(`Failed to lowest price NFTs in collection ${collectionAddress}`, error)\n    return 0\n  }\n}\n\n/**\n * Fetch user trading data for buyTradeHistory, sellTradeHistory and askOrderHistory from the Subgraph\n * @param where a User_filter where condition\n * @returns a UserActivity object\n */\nexport const getUserActivity = async (\n  address: string,\n): Promise<{ askOrderHistory: AskOrder[]; buyTradeHistory: Transaction[]; sellTradeHistory: Transaction[] }> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getUserActivity($address: String!) {\n          user(id: $address) {\n            buyTradeHistory(first: 250, orderBy: timestamp, orderDirection: desc) {\n              ${getBaseTransactionFields()}\n              nft {\n                ${getBaseNftFields()}\n              }\n            }\n            sellTradeHistory(first: 250, orderBy: timestamp, orderDirection: desc) {\n              ${getBaseTransactionFields()}\n              nft {\n                ${getBaseNftFields()}\n              }\n            }\n            askOrderHistory(first: 500, orderBy: timestamp, orderDirection: desc) {\n              id\n              block\n              timestamp\n              orderType\n              askPrice\n              nft {\n                ${getBaseNftFields()}\n              }\n            }\n          }\n        }\n      `,\n      { address },\n    )\n\n    return res.user || { askOrderHistory: [], buyTradeHistory: [], sellTradeHistory: [] }\n  } catch (error) {\n    console.error('Failed to fetch user Activity', error)\n    return {\n      askOrderHistory: [],\n      buyTradeHistory: [],\n      sellTradeHistory: [],\n    }\n  }\n}\n\n/**\n * Get the most recently listed NFTs\n * @param first Number of nfts to retrieve\n * @returns NftTokenSg[]\n */\nexport const getLatestListedNfts = async (first: number): Promise<TokenMarketData[]> => {\n  try {\n    const res = await request(\n      GRAPH_API_NFTMARKET,\n      gql`\n        query getLatestNftMarketData($first: Int) {\n          nfts(where: { isTradable: true }, orderBy: updatedAt , orderDirection: desc, first: $first) {\n            ${getBaseNftFields()}\n            collection {\n              id\n            }\n          }\n        }\n      `,\n      { first },\n    )\n\n    return res.nfts\n  } catch (error) {\n    console.error('Failed to fetch NFTs market data', error)\n    return []\n  }\n}\n\n/**\n * OTHER HELPERS\n */\n\nexport const fetchWalletTokenIdsForCollections = async (\n  account: string,\n  collections: ApiCollections,\n): Promise<TokenIdWithCollectionAddress[]> => {\n  const walletNftPromises = map(collections, async (collection): Promise<TokenIdWithCollectionAddress[]> => {\n    const { address: collectionAddress } = collection\n    const contract = getErc721Contract(collectionAddress)\n    let balanceOfResponse\n\n    try {\n      balanceOfResponse = await contract.balanceOf(account)\n    } catch (e) {\n      console.error(e)\n      return []\n    }\n\n    const balanceOf = balanceOfResponse.toNumber()\n\n    // User has no NFTs for this collection\n    if (balanceOfResponse.eq(0)) {\n      return []\n    }\n\n    const getTokenId = async (index: number) => {\n      try {\n        const tokenIdBn: ethers.BigNumber = await contract.tokenOfOwnerByIndex(account, index)\n        const tokenId = tokenIdBn.toString()\n        return tokenId\n      } catch (error) {\n        console.error('getTokenIdAndData', error)\n        return null\n      }\n    }\n\n    const tokenIdPromises = []\n\n    // For each index get the tokenId\n    for (let i = 0; i < balanceOf; i++) {\n      tokenIdPromises.push(getTokenId(i))\n    }\n\n    const tokenIds = await Promise.all(tokenIdPromises)\n    const nftLocation = NftLocation.WALLET\n    const tokensWithCollectionAddress = tokenIds.map((tokenId) => {\n      return { tokenId, collectionAddress, nftLocation }\n    })\n\n    return tokensWithCollectionAddress\n  })\n\n  const walletNfts = await Promise.all(walletNftPromises)\n  return walletNfts.flat()\n}\n\n/**\n * Helper to combine data from the collections' API and subgraph\n */\nexport const combineCollectionData = (\n  collectionApiData: ApiCollection[],\n  collectionSgData: CollectionMarketDataBaseFields[],\n): Record<string, Collection> => {\n  const collectionsMarketObj: Record<string, CollectionMarketDataBaseFields> = collectionSgData.reduce(\n    (prev, current) => ({ ...prev, [current.id]: { ...current } }),\n    {},\n  )\n\n  return collectionApiData.reduce((accum, current) => {\n    const collectionMarket = collectionsMarketObj[current.address.toLowerCase()]\n    const collection: Collection = {\n      ...current,\n      ...collectionMarket,\n    }\n\n    return {\n      ...accum,\n      [current.address]: collection,\n    }\n  }, {})\n}\n\n/**\n * Evaluate whether a market NFT is in a users wallet, their profile picture, or on sale\n * @param tokenId string\n * @param tokenIdsInWallet array of tokenIds in wallet\n * @param tokenIdsForSale array of tokenIds on sale\n * @param profileNftId Optional tokenId of users' profile picture\n * @returns NftLocation enum value\n */\nexport const getNftLocationForMarketNft = (\n  tokenId: string,\n  tokenIdsInWallet: string[],\n  tokenIdsForSale: string[],\n  profileNftId?: string,\n): NftLocation => {\n  if (tokenId === profileNftId) {\n    return NftLocation.PROFILE\n  }\n  if (tokenIdsForSale.includes(tokenId)) {\n    return NftLocation.FORSALE\n  }\n  if (tokenIdsInWallet.includes(tokenId)) {\n    return NftLocation.WALLET\n  }\n  console.error(`Cannot determine location for tokenID ${tokenId}, defaulting to NftLocation.WALLET`)\n  return NftLocation.WALLET\n}\n\n/**\n * Construct complete TokenMarketData entities with a users' wallet NFT ids and market data for their wallet NFTs\n * @param walletNfts TokenIdWithCollectionAddress\n * @param marketDataForWalletNfts TokenMarketData[]\n * @returns TokenMarketData[]\n */\nexport const attachMarketDataToWalletNfts = (\n  walletNfts: TokenIdWithCollectionAddress[],\n  marketDataForWalletNfts: TokenMarketData[],\n): TokenMarketData[] => {\n  const walletNftsWithMarketData = walletNfts.map((walletNft) => {\n    const marketData = marketDataForWalletNfts.find((marketNft) => marketNft.tokenId === walletNft.tokenId)\n    return (\n      marketData ?? {\n        tokenId: walletNft.tokenId,\n        collection: {\n          id: walletNft.collectionAddress.toLowerCase(),\n        },\n        nftLocation: walletNft.nftLocation,\n        metadataUrl: null,\n        transactionHistory: null,\n        currentSeller: null,\n        isTradable: null,\n        currentAskPrice: null,\n        latestTradedPriceInBNB: null,\n        tradeVolumeBNB: null,\n        totalTrades: null,\n        otherId: null,\n      }\n    )\n  })\n  return walletNftsWithMarketData\n}\n\n/**\n * Attach TokenMarketData and location to NftToken\n * @param nftsWithMetadata NftToken[] with API metadata\n * @param nftsForSale  market data for nfts that are on sale (i.e. not in a user's wallet)\n * @param walletNfts makret data for nfts in a user's wallet\n * @param tokenIdsInWallet array of token ids in user's wallet\n * @param tokenIdsForSale array of token ids of nfts that are on sale\n * @param profileNftId profile picture token id\n * @returns NFT[]\n */\nexport const combineNftMarketAndMetadata = (\n  nftsWithMetadata: NftToken[],\n  nftsForSale: TokenMarketData[],\n  walletNfts: TokenMarketData[],\n  tokenIdsInWallet: string[],\n  tokenIdsForSale: string[],\n  profileNftId?: string,\n): NftToken[] => {\n  const completeNftData = nftsWithMetadata.map<NftToken>((nft) => {\n    // Get metadata object\n    const isOnSale = nftsForSale.filter((forSaleNft) => forSaleNft.tokenId === nft.tokenId).length > 0\n    let marketData\n    if (isOnSale) {\n      marketData = nftsForSale.find((marketNft) => marketNft.tokenId === nft.tokenId)\n    } else {\n      marketData = walletNfts.find((marketNft) => marketNft.tokenId === nft.tokenId)\n    }\n    const location = getNftLocationForMarketNft(nft.tokenId, tokenIdsInWallet, tokenIdsForSale, profileNftId)\n    return { ...nft, marketData, location }\n  })\n  return completeNftData\n}\n\n/**\n * Get in-wallet, on-sale & profile pic NFT metadata, complete with market data for a given account\n * @param account\n * @param collections\n * @param profileNftWithCollectionAddress\n * @returns Promise<NftToken[]>\n */\nexport const getCompleteAccountNftData = async (\n  account: string,\n  collections: ApiCollections,\n  profileNftWithCollectionAddress?: TokenIdWithCollectionAddress,\n): Promise<NftToken[]> => {\n  const walletNftIds = await fetchWalletTokenIdsForCollections(account, collections)\n  if (profileNftWithCollectionAddress?.tokenId) {\n    walletNftIds.push(profileNftWithCollectionAddress)\n  }\n  const tokenIds = walletNftIds.map((nft) => nft.tokenId)\n\n  const marketDataForWalletNfts = await getNftsMarketData({ tokenId_in: tokenIds })\n  const walletNftsWithMarketData = attachMarketDataToWalletNfts(walletNftIds, marketDataForWalletNfts)\n\n  const tokenIdsInWallet = walletNftIds\n    .filter((walletNft) => {\n      // Profile Pic NFT is included in walletNftIds array, hence this filter\n      return profileNftWithCollectionAddress?.tokenId !== walletNft.tokenId\n    })\n    .map((nft) => nft.tokenId)\n\n  const marketDataForSaleNfts = await getNftsMarketData({ currentSeller: account.toLowerCase() })\n  const tokenIdsForSale = marketDataForSaleNfts.map((nft) => nft.tokenId)\n\n  const forSaleNftIds = marketDataForSaleNfts.map((nft) => {\n    return { collectionAddress: nft.collection.id, tokenId: nft.tokenId }\n  })\n\n  const metadataForAllNfts = await getNftsFromDifferentCollectionsApi([...walletNftIds, ...forSaleNftIds])\n\n  const completeNftData = combineNftMarketAndMetadata(\n    metadataForAllNfts,\n    marketDataForSaleNfts,\n    walletNftsWithMarketData,\n    tokenIdsInWallet,\n    tokenIdsForSale,\n    profileNftWithCollectionAddress?.tokenId,\n  )\n\n  return completeNftData\n}\n"]},"metadata":{},"sourceType":"module"}