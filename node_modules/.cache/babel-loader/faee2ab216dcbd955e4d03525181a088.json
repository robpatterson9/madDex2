{"ast":null,"code":"import { ONE_DAY_UNIX, PCS_V2_START } from 'config/constants/info';\nimport { getUnixTime } from 'date-fns';\nimport { TransactionType } from 'state/info/types';\nexport const mapMints = mint => {\n  return {\n    type: TransactionType.MINT,\n    hash: mint.id.split('-')[0],\n    timestamp: mint.timestamp,\n    sender: mint.to,\n    token0Symbol: mint.pair.token0.symbol,\n    token1Symbol: mint.pair.token1.symbol,\n    token0Address: mint.pair.token0.id,\n    token1Address: mint.pair.token1.id,\n    amountUSD: parseFloat(mint.amountUSD),\n    amountToken0: parseFloat(mint.amount0),\n    amountToken1: parseFloat(mint.amount1)\n  };\n};\nexport const mapBurns = burn => {\n  return {\n    type: TransactionType.BURN,\n    hash: burn.id.split('-')[0],\n    timestamp: burn.timestamp,\n    sender: burn.sender,\n    token0Symbol: burn.pair.token0.symbol,\n    token1Symbol: burn.pair.token1.symbol,\n    token0Address: burn.pair.token0.id,\n    token1Address: burn.pair.token1.id,\n    amountUSD: parseFloat(burn.amountUSD),\n    amountToken0: parseFloat(burn.amount0),\n    amountToken1: parseFloat(burn.amount1)\n  };\n};\nexport const mapSwaps = swap => {\n  return {\n    type: TransactionType.SWAP,\n    hash: swap.id.split('-')[0],\n    timestamp: swap.timestamp,\n    sender: swap.from,\n    token0Symbol: swap.pair.token0.symbol,\n    token1Symbol: swap.pair.token1.symbol,\n    token0Address: swap.pair.token0.id,\n    token1Address: swap.pair.token1.id,\n    amountUSD: parseFloat(swap.amountUSD),\n    amountToken0: parseFloat(swap.amount0In) - parseFloat(swap.amount0Out),\n    amountToken1: parseFloat(swap.amount1In) - parseFloat(swap.amount1Out)\n  };\n};\nexport const mapDayData = tokenDayData => ({\n  date: tokenDayData.date,\n  volumeUSD: parseFloat(tokenDayData.dailyVolumeUSD),\n  liquidityUSD: parseFloat(tokenDayData.totalLiquidityUSD)\n});\nexport const mapPairDayData = pairDayData => ({\n  date: pairDayData.date,\n  volumeUSD: parseFloat(pairDayData.dailyVolumeUSD),\n  liquidityUSD: parseFloat(pairDayData.reserveUSD)\n});\n// Common helper function to retrieve chart data\n// Used for both Pool and Token charts\nexport const fetchChartData = async (getEntityDayDatas, address) => {\n  var _firstAvailableDayDat, _firstAvailableDayDat2;\n\n  let chartEntries = [];\n  let error = false;\n  let skip = 0;\n  let allFound = false;\n\n  while (!allFound) {\n    // eslint-disable-next-line no-await-in-loop\n    const {\n      data,\n      error: fetchError\n    } = await getEntityDayDatas(skip, address);\n    skip += 1000;\n    allFound = data.length < 1000;\n    error = fetchError;\n\n    if (data) {\n      chartEntries = chartEntries.concat(data);\n    }\n  }\n\n  if (error || chartEntries.length === 0) {\n    return {\n      error: true\n    };\n  }\n\n  const formattedDayDatas = chartEntries.reduce((accum, dayData) => {\n    // At this stage we track unix day ordinal for each data point to check for empty days later\n    const dayOrdinal = parseInt((dayData.date / ONE_DAY_UNIX).toFixed(0));\n    return {\n      [dayOrdinal]: dayData,\n      ...accum\n    };\n  }, {});\n  const availableDays = Object.keys(formattedDayDatas).map(dayOrdinal => parseInt(dayOrdinal, 10));\n  const firstAvailableDayData = formattedDayDatas[availableDays[0]]; // fill in empty days ( there will be no day datas if no trades made that day )\n\n  let timestamp = (_firstAvailableDayDat = firstAvailableDayData === null || firstAvailableDayData === void 0 ? void 0 : firstAvailableDayData.date) !== null && _firstAvailableDayDat !== void 0 ? _firstAvailableDayDat : PCS_V2_START;\n  let latestLiquidityUSD = (_firstAvailableDayDat2 = firstAvailableDayData === null || firstAvailableDayData === void 0 ? void 0 : firstAvailableDayData.liquidityUSD) !== null && _firstAvailableDayDat2 !== void 0 ? _firstAvailableDayDat2 : 0;\n  const endTimestamp = getUnixTime(new Date());\n\n  while (timestamp < endTimestamp - ONE_DAY_UNIX) {\n    timestamp += ONE_DAY_UNIX;\n    const dayOrdinal = parseInt((timestamp / ONE_DAY_UNIX).toFixed(0), 10);\n\n    if (!Object.keys(formattedDayDatas).includes(dayOrdinal.toString())) {\n      formattedDayDatas[dayOrdinal] = {\n        date: timestamp,\n        volumeUSD: 0,\n        liquidityUSD: latestLiquidityUSD\n      };\n    } else {\n      latestLiquidityUSD = formattedDayDatas[dayOrdinal].liquidityUSD;\n    }\n  }\n\n  return {\n    data: Object.values(formattedDayDatas),\n    error: false\n  };\n};","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/info/queries/helpers.ts"],"names":["ONE_DAY_UNIX","PCS_V2_START","getUnixTime","TransactionType","mapMints","mint","type","MINT","hash","id","split","timestamp","sender","to","token0Symbol","pair","token0","symbol","token1Symbol","token1","token0Address","token1Address","amountUSD","parseFloat","amountToken0","amount0","amountToken1","amount1","mapBurns","burn","BURN","mapSwaps","swap","SWAP","from","amount0In","amount0Out","amount1In","amount1Out","mapDayData","tokenDayData","date","volumeUSD","dailyVolumeUSD","liquidityUSD","totalLiquidityUSD","mapPairDayData","pairDayData","reserveUSD","fetchChartData","getEntityDayDatas","address","chartEntries","error","skip","allFound","data","fetchError","length","concat","formattedDayDatas","reduce","accum","dayData","dayOrdinal","parseInt","toFixed","availableDays","Object","keys","map","firstAvailableDayData","latestLiquidityUSD","endTimestamp","Date","includes","toString","values"],"mappings":"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","sourcesContent":["import { ONE_DAY_UNIX, PCS_V2_START } from 'config/constants/info'\nimport { getUnixTime } from 'date-fns'\nimport { TransactionType } from 'state/info/types'\nimport { ChartEntry } from '../types'\nimport { MintResponse, SwapResponse, BurnResponse, TokenDayData, PairDayData, PancakeDayData } from './types'\n\nexport const mapMints = (mint: MintResponse) => {\n  return {\n    type: TransactionType.MINT,\n    hash: mint.id.split('-')[0],\n    timestamp: mint.timestamp,\n    sender: mint.to,\n    token0Symbol: mint.pair.token0.symbol,\n    token1Symbol: mint.pair.token1.symbol,\n    token0Address: mint.pair.token0.id,\n    token1Address: mint.pair.token1.id,\n    amountUSD: parseFloat(mint.amountUSD),\n    amountToken0: parseFloat(mint.amount0),\n    amountToken1: parseFloat(mint.amount1),\n  }\n}\n\nexport const mapBurns = (burn: BurnResponse) => {\n  return {\n    type: TransactionType.BURN,\n    hash: burn.id.split('-')[0],\n    timestamp: burn.timestamp,\n    sender: burn.sender,\n    token0Symbol: burn.pair.token0.symbol,\n    token1Symbol: burn.pair.token1.symbol,\n    token0Address: burn.pair.token0.id,\n    token1Address: burn.pair.token1.id,\n    amountUSD: parseFloat(burn.amountUSD),\n    amountToken0: parseFloat(burn.amount0),\n    amountToken1: parseFloat(burn.amount1),\n  }\n}\n\nexport const mapSwaps = (swap: SwapResponse) => {\n  return {\n    type: TransactionType.SWAP,\n    hash: swap.id.split('-')[0],\n    timestamp: swap.timestamp,\n    sender: swap.from,\n    token0Symbol: swap.pair.token0.symbol,\n    token1Symbol: swap.pair.token1.symbol,\n    token0Address: swap.pair.token0.id,\n    token1Address: swap.pair.token1.id,\n    amountUSD: parseFloat(swap.amountUSD),\n    amountToken0: parseFloat(swap.amount0In) - parseFloat(swap.amount0Out),\n    amountToken1: parseFloat(swap.amount1In) - parseFloat(swap.amount1Out),\n  }\n}\n\nexport const mapDayData = (tokenDayData: TokenDayData | PancakeDayData): ChartEntry => ({\n  date: tokenDayData.date,\n  volumeUSD: parseFloat(tokenDayData.dailyVolumeUSD),\n  liquidityUSD: parseFloat(tokenDayData.totalLiquidityUSD),\n})\n\nexport const mapPairDayData = (pairDayData: PairDayData): ChartEntry => ({\n  date: pairDayData.date,\n  volumeUSD: parseFloat(pairDayData.dailyVolumeUSD),\n  liquidityUSD: parseFloat(pairDayData.reserveUSD),\n})\n\ntype PoolOrTokenFetchFn = (skip: number, address: string) => Promise<{ data?: ChartEntry[]; error: boolean }>\ntype OverviewFetchFn = (skip: number) => Promise<{ data?: ChartEntry[]; error: boolean }>\n\n// Common helper function to retrieve chart data\n// Used for both Pool and Token charts\nexport const fetchChartData = async (\n  getEntityDayDatas: PoolOrTokenFetchFn | OverviewFetchFn,\n  address?: string,\n): Promise<{ data?: ChartEntry[]; error: boolean }> => {\n  let chartEntries: ChartEntry[] = []\n  let error = false\n  let skip = 0\n  let allFound = false\n\n  while (!allFound) {\n    // eslint-disable-next-line no-await-in-loop\n    const { data, error: fetchError } = await getEntityDayDatas(skip, address)\n    skip += 1000\n    allFound = data.length < 1000\n    error = fetchError\n    if (data) {\n      chartEntries = chartEntries.concat(data)\n    }\n  }\n\n  if (error || chartEntries.length === 0) {\n    return {\n      error: true,\n    }\n  }\n\n  const formattedDayDatas = chartEntries.reduce((accum: { [date: number]: ChartEntry }, dayData) => {\n    // At this stage we track unix day ordinal for each data point to check for empty days later\n    const dayOrdinal = parseInt((dayData.date / ONE_DAY_UNIX).toFixed(0))\n    return {\n      [dayOrdinal]: dayData,\n      ...accum,\n    }\n  }, {})\n\n  const availableDays = Object.keys(formattedDayDatas).map((dayOrdinal) => parseInt(dayOrdinal, 10))\n\n  const firstAvailableDayData = formattedDayDatas[availableDays[0]]\n  // fill in empty days ( there will be no day datas if no trades made that day )\n  let timestamp = firstAvailableDayData?.date ?? PCS_V2_START\n  let latestLiquidityUSD = firstAvailableDayData?.liquidityUSD ?? 0\n  const endTimestamp = getUnixTime(new Date())\n  while (timestamp < endTimestamp - ONE_DAY_UNIX) {\n    timestamp += ONE_DAY_UNIX\n    const dayOrdinal = parseInt((timestamp / ONE_DAY_UNIX).toFixed(0), 10)\n    if (!Object.keys(formattedDayDatas).includes(dayOrdinal.toString())) {\n      formattedDayDatas[dayOrdinal] = {\n        date: timestamp,\n        volumeUSD: 0,\n        liquidityUSD: latestLiquidityUSD,\n      }\n    } else {\n      latestLiquidityUSD = formattedDayDatas[dayOrdinal].liquidityUSD\n    }\n  }\n\n  return {\n    data: Object.values(formattedDayDatas),\n    error: false,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}