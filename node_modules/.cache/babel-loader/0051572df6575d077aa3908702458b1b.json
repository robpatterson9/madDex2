{"ast":null,"code":"import { request, gql } from 'graphql-request';\nimport { GRAPH_API_PREDICTION } from 'config/constants/endpoints';\nimport { ethers } from 'ethers';\nimport { BetPosition, PredictionStatus, HistoryFilter } from 'state/types';\nimport { multicallv2 } from 'utils/multicall';\nimport { getPredictionsContract } from 'utils/contractHelpers';\nimport predictionsAbi from 'config/abi/predictions.json';\nimport { getPredictionsAddress } from 'utils/addressHelpers';\nimport { getRoundBaseFields, getBetBaseFields, getUserBaseFields } from './queries';\nimport { ROUNDS_PER_PAGE } from './config';\nexport let Result;\n\n(function (Result) {\n  Result[\"WIN\"] = \"win\";\n  Result[\"LOSE\"] = \"lose\";\n  Result[\"CANCELED\"] = \"canceled\";\n  Result[\"HOUSE\"] = \"house\";\n  Result[\"LIVE\"] = \"live\";\n})(Result || (Result = {}));\n\nexport const numberOrNull = value => {\n  if (value === null) {\n    return null;\n  }\n\n  const valueNum = Number(value);\n  return Number.isNaN(valueNum) ? null : valueNum;\n};\n\nconst getRoundPosition = positionResponse => {\n  if (positionResponse === 'Bull') {\n    return BetPosition.BULL;\n  }\n\n  if (positionResponse === 'Bear') {\n    return BetPosition.BEAR;\n  }\n\n  if (positionResponse === 'House') {\n    return BetPosition.HOUSE;\n  }\n\n  return null;\n};\n\nexport const transformBetResponse = betResponse => {\n  const bet = {\n    id: betResponse.id,\n    hash: betResponse.hash,\n    block: numberOrNull(betResponse.block),\n    amount: betResponse.amount ? parseFloat(betResponse.amount) : 0,\n    position: betResponse.position === 'Bull' ? BetPosition.BULL : BetPosition.BEAR,\n    claimed: betResponse.claimed,\n    claimedAt: numberOrNull(betResponse.claimedAt),\n    claimedBlock: numberOrNull(betResponse.claimedBlock),\n    claimedHash: betResponse.claimedHash,\n    claimedBNB: betResponse.claimedBNB ? parseFloat(betResponse.claimedBNB) : 0,\n    claimedNetBNB: betResponse.claimedNetBNB ? parseFloat(betResponse.claimedNetBNB) : 0,\n    createdAt: numberOrNull(betResponse.createdAt),\n    updatedAt: numberOrNull(betResponse.updatedAt)\n  };\n\n  if (betResponse.user) {\n    bet.user = transformUserResponse(betResponse.user);\n  }\n\n  if (betResponse.round) {\n    bet.round = transformRoundResponse(betResponse.round);\n  }\n\n  return bet;\n};\nexport const transformUserResponse = userResponse => {\n  const {\n    id,\n    createdAt,\n    updatedAt,\n    block,\n    totalBets,\n    totalBetsBull,\n    totalBetsBear,\n    totalBNB,\n    totalBNBBull,\n    totalBNBBear,\n    totalBetsClaimed,\n    totalBNBClaimed,\n    winRate,\n    averageBNB,\n    netBNB\n  } = userResponse;\n  return {\n    id,\n    createdAt: numberOrNull(createdAt),\n    updatedAt: numberOrNull(updatedAt),\n    block: numberOrNull(block),\n    totalBets: numberOrNull(totalBets),\n    totalBetsBull: numberOrNull(totalBetsBull),\n    totalBetsBear: numberOrNull(totalBetsBear),\n    totalBNB: totalBNB ? parseFloat(totalBNB) : 0,\n    totalBNBBull: totalBNBBull ? parseFloat(totalBNBBull) : 0,\n    totalBNBBear: totalBNBBear ? parseFloat(totalBNBBear) : 0,\n    totalBetsClaimed: numberOrNull(totalBetsClaimed),\n    totalBNBClaimed: totalBNBClaimed ? parseFloat(totalBNBClaimed) : 0,\n    winRate: winRate ? parseFloat(winRate) : 0,\n    averageBNB: averageBNB ? parseFloat(averageBNB) : 0,\n    netBNB: netBNB ? parseFloat(netBNB) : 0\n  };\n};\nexport const transformRoundResponse = roundResponse => {\n  const {\n    id,\n    epoch,\n    failed,\n    position,\n    startAt,\n    startBlock,\n    startHash,\n    lockAt,\n    lockBlock,\n    lockHash,\n    lockPrice,\n    lockRoundId,\n    closeAt,\n    closeBlock,\n    closeHash,\n    closePrice,\n    closeRoundId,\n    totalBets,\n    totalAmount,\n    bullBets,\n    bullAmount,\n    bearBets,\n    bearAmount,\n    bets = []\n  } = roundResponse;\n  return {\n    id,\n    failed,\n    startHash,\n    lockHash,\n    lockRoundId,\n    closeRoundId,\n    closeHash,\n    position: getRoundPosition(position),\n    epoch: numberOrNull(epoch),\n    startAt: numberOrNull(startAt),\n    startBlock: numberOrNull(startBlock),\n    lockAt: numberOrNull(lockAt),\n    lockBlock: numberOrNull(lockBlock),\n    lockPrice: lockPrice ? parseFloat(lockPrice) : 0,\n    closeAt: numberOrNull(closeAt),\n    closeBlock: numberOrNull(closeBlock),\n    closePrice: closePrice ? parseFloat(closePrice) : 0,\n    totalBets: numberOrNull(totalBets),\n    totalAmount: totalAmount ? parseFloat(totalAmount) : 0,\n    bullBets: numberOrNull(bullBets),\n    bullAmount: bullAmount ? parseFloat(bullAmount) : 0,\n    bearBets: numberOrNull(bearBets),\n    bearAmount: bearAmount ? parseFloat(bearAmount) : 0,\n    bets: bets.map(transformBetResponse)\n  };\n};\nexport const getRoundResult = (bet, currentEpoch) => {\n  const {\n    round\n  } = bet;\n\n  if (round.failed) {\n    return Result.CANCELED;\n  }\n\n  if (round.epoch >= currentEpoch - 1) {\n    return Result.LIVE;\n  }\n\n  if (bet.round.position === BetPosition.HOUSE) {\n    return Result.HOUSE;\n  }\n\n  const roundResultPosition = round.closePrice > round.lockPrice ? BetPosition.BULL : BetPosition.BEAR;\n  return bet.position === roundResultPosition ? Result.WIN : Result.LOSE;\n};\nexport const getFilteredBets = (bets, filter) => {\n  switch (filter) {\n    case HistoryFilter.COLLECTED:\n      return bets.filter(bet => bet.claimed === true);\n\n    case HistoryFilter.UNCOLLECTED:\n      return bets.filter(bet => {\n        return !bet.claimed && (bet.position === bet.round.position || bet.round.failed === true);\n      });\n\n    case HistoryFilter.ALL:\n    default:\n      return bets;\n  }\n};\nexport const getTotalWon = async () => {\n  const {\n    market\n  } = await request(GRAPH_API_PREDICTION, gql`\n      query getTotalWonData {\n        market(id: 1) {\n          totalBNB\n          totalBNBTreasury\n        }\n      }\n    `);\n  const totalBNB = market.totalBNB ? parseFloat(market.totalBNB) : 0;\n  const totalBNBTreasury = market.totalBNBTreasury ? parseFloat(market.totalBNBTreasury) : 0;\n  return Math.max(totalBNB - totalBNBTreasury, 0);\n};\nexport const getBetHistory = async (where = {}, first = 1000, skip = 0) => {\n  const response = await request(GRAPH_API_PREDICTION, gql`\n      query getBetHistory($first: Int!, $skip: Int!, $where: Bet_filter) {\n        bets(first: $first, skip: $skip, where: $where, order: createdAt, orderDirection: desc) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n    `, {\n    first,\n    skip,\n    where\n  });\n  return response.bets;\n};\nexport const getBet = async betId => {\n  const response = await request(GRAPH_API_PREDICTION, gql`\n      query getBet($id: ID!) {\n        bet(id: $id) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n  `, {\n    id: betId.toLowerCase()\n  });\n  return response.bet;\n};\nexport const getLedgerData = async (account, epochs) => {\n  const address = getPredictionsAddress();\n  const ledgerCalls = epochs.map(epoch => ({\n    address,\n    name: 'ledger',\n    params: [epoch, account]\n  }));\n  const response = await multicallv2(predictionsAbi, ledgerCalls);\n  return response;\n};\nexport const LEADERBOARD_RESULTS_PER_PAGE = 20;\nconst defaultPredictionUserOptions = {\n  skip: 0,\n  first: LEADERBOARD_RESULTS_PER_PAGE,\n  orderBy: 'createdAt',\n  orderDir: 'desc'\n};\nexport const getPredictionUsers = async (options = {}) => {\n  const {\n    first,\n    skip,\n    where,\n    orderBy,\n    orderDir\n  } = { ...defaultPredictionUserOptions,\n    ...options\n  };\n  const response = await request(GRAPH_API_PREDICTION, gql`\n      query getUsers($first: Int!, $skip: Int!, $where: User_filter, $orderBy: User_orderBy, $orderDir: OrderDirection) {\n        users(first: $first, skip: $skip, where: $where, orderBy: $orderBy, orderDirection: $orderDir) {\n          ${getUserBaseFields()} \n        }\n      }\n    `, {\n    first,\n    skip,\n    where,\n    orderBy,\n    orderDir\n  });\n  return response.users;\n};\nexport const getPredictionUser = async account => {\n  const response = await request(GRAPH_API_PREDICTION, gql`\n      query getUser($id: ID!) {\n        user(id: $id) {\n          ${getUserBaseFields()}\n        }\n      }\n  `, {\n    id: account.toLowerCase()\n  });\n  return response.user;\n};\nexport const getClaimStatuses = async (account, epochs) => {\n  const address = getPredictionsAddress();\n  const claimableCalls = epochs.map(epoch => ({\n    address,\n    name: 'claimable',\n    params: [epoch, account]\n  }));\n  const claimableResponses = await multicallv2(predictionsAbi, claimableCalls);\n  return claimableResponses.reduce((accum, claimableResponse, index) => {\n    const epoch = epochs[index];\n    const [claimable] = claimableResponse;\n    return { ...accum,\n      [epoch]: claimable\n    };\n  }, {});\n};\nexport const getPredictionData = async () => {\n  const address = getPredictionsAddress();\n  const staticCalls = ['currentEpoch', 'intervalSeconds', 'minBetAmount', 'paused', 'bufferSeconds'].map(method => ({\n    address,\n    name: method\n  }));\n  const [[currentEpoch], [intervalSeconds], [minBetAmount], [paused], [bufferSeconds]] = await multicallv2(predictionsAbi, staticCalls);\n  return {\n    status: paused ? PredictionStatus.PAUSED : PredictionStatus.LIVE,\n    currentEpoch: currentEpoch.toNumber(),\n    intervalSeconds: intervalSeconds.toNumber(),\n    minBetAmount: minBetAmount.toString(),\n    bufferSeconds: bufferSeconds.toNumber()\n  };\n};\nexport const getRoundsData = async epochs => {\n  const address = getPredictionsAddress();\n  const calls = epochs.map(epoch => ({\n    address,\n    name: 'rounds',\n    params: [epoch]\n  }));\n  const response = await multicallv2(predictionsAbi, calls);\n  return response;\n};\nexport const makeFutureRoundResponse = (epoch, startTimestamp) => {\n  return {\n    epoch,\n    startTimestamp,\n    lockTimestamp: null,\n    closeTimestamp: null,\n    lockPrice: null,\n    closePrice: null,\n    totalAmount: ethers.BigNumber.from(0).toJSON(),\n    bullAmount: ethers.BigNumber.from(0).toJSON(),\n    bearAmount: ethers.BigNumber.from(0).toJSON(),\n    rewardBaseCalAmount: ethers.BigNumber.from(0).toJSON(),\n    rewardAmount: ethers.BigNumber.from(0).toJSON(),\n    oracleCalled: false,\n    lockOracleId: null,\n    closeOracleId: null\n  };\n};\nexport const makeRoundData = rounds => {\n  return rounds.reduce((accum, round) => {\n    return { ...accum,\n      [round.epoch.toString()]: round\n    };\n  }, {});\n};\nexport const serializePredictionsLedgerResponse = ledgerResponse => ({\n  position: ledgerResponse.position === 0 ? BetPosition.BULL : BetPosition.BEAR,\n  amount: ledgerResponse.amount.toJSON(),\n  claimed: ledgerResponse.claimed\n});\nexport const makeLedgerData = (account, ledgers, epochs) => {\n  return ledgers.reduce((accum, ledgerResponse, index) => {\n    if (!ledgerResponse) {\n      return accum;\n    } // If the amount is zero that means the user did not bet\n\n\n    if (ledgerResponse.amount.eq(0)) {\n      return accum;\n    }\n\n    const epoch = epochs[index].toString();\n    return { ...accum,\n      [account]: { ...accum[account],\n        [epoch]: serializePredictionsLedgerResponse(ledgerResponse)\n      }\n    };\n  }, {});\n};\n/**\n * Serializes the return from the \"rounds\" call for redux\n */\n\nexport const serializePredictionsRoundsResponse = response => {\n  const {\n    epoch,\n    startTimestamp,\n    lockTimestamp,\n    closeTimestamp,\n    lockPrice,\n    closePrice,\n    totalAmount,\n    bullAmount,\n    bearAmount,\n    rewardBaseCalAmount,\n    rewardAmount,\n    oracleCalled,\n    lockOracleId,\n    closeOracleId\n  } = response;\n  return {\n    oracleCalled,\n    epoch: epoch.toNumber(),\n    startTimestamp: startTimestamp.eq(0) ? null : startTimestamp.toNumber(),\n    lockTimestamp: lockTimestamp.eq(0) ? null : lockTimestamp.toNumber(),\n    closeTimestamp: closeTimestamp.eq(0) ? null : closeTimestamp.toNumber(),\n    lockPrice: lockPrice.eq(0) ? null : lockPrice.toJSON(),\n    closePrice: closePrice.eq(0) ? null : closePrice.toJSON(),\n    totalAmount: totalAmount.toJSON(),\n    bullAmount: bullAmount.toJSON(),\n    bearAmount: bearAmount.toJSON(),\n    rewardBaseCalAmount: rewardBaseCalAmount.toJSON(),\n    rewardAmount: rewardAmount.toJSON(),\n    lockOracleId: lockOracleId.toString(),\n    closeOracleId: closeOracleId.toString()\n  };\n};\n/**\n * Parse serialized values back into ethers.BigNumber\n * ethers.BigNumber values are stored with the \"toJSON()\" method, e.g  { type: \"BigNumber\", hex: string }\n */\n\nexport const parseBigNumberObj = data => {\n  return Object.keys(data).reduce((accum, key) => {\n    const value = data[key];\n\n    if (value && (value === null || value === void 0 ? void 0 : value.type) === 'BigNumber') {\n      return { ...accum,\n        [key]: ethers.BigNumber.from(value)\n      };\n    }\n\n    return { ...accum,\n      [key]: value\n    };\n  }, {});\n};\nexport const fetchUsersRoundsLength = async account => {\n  try {\n    const contract = getPredictionsContract();\n    const length = await contract.getUserRoundsLength(account);\n    return length;\n  } catch {\n    return ethers.BigNumber.from(0);\n  }\n};\n/**\n * Fetches rounds a user has participated in\n */\n\nexport const fetchUserRounds = async (account, cursor = 0, size = ROUNDS_PER_PAGE) => {\n  const contract = getPredictionsContract();\n\n  try {\n    const [rounds, ledgers] = await contract.getUserRounds(account, cursor, size);\n    return rounds.reduce((accum, round, index) => {\n      return { ...accum,\n        [round.toString()]: serializePredictionsLedgerResponse(ledgers[index])\n      };\n    }, {});\n  } catch {\n    // When the results run out the contract throws an error.\n    return null;\n  }\n};","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/predictions/helpers.ts"],"names":["request","gql","GRAPH_API_PREDICTION","ethers","BetPosition","PredictionStatus","HistoryFilter","multicallv2","getPredictionsContract","predictionsAbi","getPredictionsAddress","getRoundBaseFields","getBetBaseFields","getUserBaseFields","ROUNDS_PER_PAGE","Result","numberOrNull","value","valueNum","Number","isNaN","getRoundPosition","positionResponse","BULL","BEAR","HOUSE","transformBetResponse","betResponse","bet","id","hash","block","amount","parseFloat","position","claimed","claimedAt","claimedBlock","claimedHash","claimedBNB","claimedNetBNB","createdAt","updatedAt","user","transformUserResponse","round","transformRoundResponse","userResponse","totalBets","totalBetsBull","totalBetsBear","totalBNB","totalBNBBull","totalBNBBear","totalBetsClaimed","totalBNBClaimed","winRate","averageBNB","netBNB","roundResponse","epoch","failed","startAt","startBlock","startHash","lockAt","lockBlock","lockHash","lockPrice","lockRoundId","closeAt","closeBlock","closeHash","closePrice","closeRoundId","totalAmount","bullBets","bullAmount","bearBets","bearAmount","bets","map","getRoundResult","currentEpoch","CANCELED","LIVE","roundResultPosition","WIN","LOSE","getFilteredBets","filter","COLLECTED","UNCOLLECTED","ALL","getTotalWon","market","totalBNBTreasury","Math","max","getBetHistory","where","first","skip","response","getBet","betId","toLowerCase","getLedgerData","account","epochs","address","ledgerCalls","name","params","LEADERBOARD_RESULTS_PER_PAGE","defaultPredictionUserOptions","orderBy","orderDir","getPredictionUsers","options","users","getPredictionUser","getClaimStatuses","claimableCalls","claimableResponses","reduce","accum","claimableResponse","index","claimable","getPredictionData","staticCalls","method","intervalSeconds","minBetAmount","paused","bufferSeconds","status","PAUSED","toNumber","toString","getRoundsData","calls","makeFutureRoundResponse","startTimestamp","lockTimestamp","closeTimestamp","BigNumber","from","toJSON","rewardBaseCalAmount","rewardAmount","oracleCalled","lockOracleId","closeOracleId","makeRoundData","rounds","serializePredictionsLedgerResponse","ledgerResponse","makeLedgerData","ledgers","eq","serializePredictionsRoundsResponse","parseBigNumberObj","data","Object","keys","key","type","fetchUsersRoundsLength","contract","length","getUserRoundsLength","fetchUserRounds","cursor","size","getUserRounds"],"mappings":"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","sourcesContent":["import { request, gql } from 'graphql-request'\nimport { GRAPH_API_PREDICTION } from 'config/constants/endpoints'\nimport { ethers } from 'ethers'\nimport {\n  Bet,\n  LedgerData,\n  BetPosition,\n  PredictionsState,\n  PredictionStatus,\n  ReduxNodeLedger,\n  ReduxNodeRound,\n  Round,\n  RoundData,\n  PredictionUser,\n  HistoryFilter,\n} from 'state/types'\nimport { multicallv2 } from 'utils/multicall'\nimport { getPredictionsContract } from 'utils/contractHelpers'\nimport predictionsAbi from 'config/abi/predictions.json'\nimport { getPredictionsAddress } from 'utils/addressHelpers'\nimport { PredictionsClaimableResponse, PredictionsLedgerResponse, PredictionsRoundsResponse } from 'utils/types'\nimport {\n  BetResponse,\n  getRoundBaseFields,\n  getBetBaseFields,\n  getUserBaseFields,\n  RoundResponse,\n  TotalWonMarketResponse,\n  UserResponse,\n} from './queries'\nimport { ROUNDS_PER_PAGE } from './config'\n\nexport enum Result {\n  WIN = 'win',\n  LOSE = 'lose',\n  CANCELED = 'canceled',\n  HOUSE = 'house',\n  LIVE = 'live',\n}\n\nexport const numberOrNull = (value: string) => {\n  if (value === null) {\n    return null\n  }\n\n  const valueNum = Number(value)\n  return Number.isNaN(valueNum) ? null : valueNum\n}\n\nconst getRoundPosition = (positionResponse: string) => {\n  if (positionResponse === 'Bull') {\n    return BetPosition.BULL\n  }\n\n  if (positionResponse === 'Bear') {\n    return BetPosition.BEAR\n  }\n\n  if (positionResponse === 'House') {\n    return BetPosition.HOUSE\n  }\n\n  return null\n}\n\nexport const transformBetResponse = (betResponse: BetResponse): Bet => {\n  const bet = {\n    id: betResponse.id,\n    hash: betResponse.hash,\n    block: numberOrNull(betResponse.block),\n    amount: betResponse.amount ? parseFloat(betResponse.amount) : 0,\n    position: betResponse.position === 'Bull' ? BetPosition.BULL : BetPosition.BEAR,\n    claimed: betResponse.claimed,\n    claimedAt: numberOrNull(betResponse.claimedAt),\n    claimedBlock: numberOrNull(betResponse.claimedBlock),\n    claimedHash: betResponse.claimedHash,\n    claimedBNB: betResponse.claimedBNB ? parseFloat(betResponse.claimedBNB) : 0,\n    claimedNetBNB: betResponse.claimedNetBNB ? parseFloat(betResponse.claimedNetBNB) : 0,\n    createdAt: numberOrNull(betResponse.createdAt),\n    updatedAt: numberOrNull(betResponse.updatedAt),\n  } as Bet\n\n  if (betResponse.user) {\n    bet.user = transformUserResponse(betResponse.user)\n  }\n\n  if (betResponse.round) {\n    bet.round = transformRoundResponse(betResponse.round)\n  }\n\n  return bet\n}\n\nexport const transformUserResponse = (userResponse: UserResponse): PredictionUser => {\n  const {\n    id,\n    createdAt,\n    updatedAt,\n    block,\n    totalBets,\n    totalBetsBull,\n    totalBetsBear,\n    totalBNB,\n    totalBNBBull,\n    totalBNBBear,\n    totalBetsClaimed,\n    totalBNBClaimed,\n    winRate,\n    averageBNB,\n    netBNB,\n  } = userResponse\n\n  return {\n    id,\n    createdAt: numberOrNull(createdAt),\n    updatedAt: numberOrNull(updatedAt),\n    block: numberOrNull(block),\n    totalBets: numberOrNull(totalBets),\n    totalBetsBull: numberOrNull(totalBetsBull),\n    totalBetsBear: numberOrNull(totalBetsBear),\n    totalBNB: totalBNB ? parseFloat(totalBNB) : 0,\n    totalBNBBull: totalBNBBull ? parseFloat(totalBNBBull) : 0,\n    totalBNBBear: totalBNBBear ? parseFloat(totalBNBBear) : 0,\n    totalBetsClaimed: numberOrNull(totalBetsClaimed),\n    totalBNBClaimed: totalBNBClaimed ? parseFloat(totalBNBClaimed) : 0,\n    winRate: winRate ? parseFloat(winRate) : 0,\n    averageBNB: averageBNB ? parseFloat(averageBNB) : 0,\n    netBNB: netBNB ? parseFloat(netBNB) : 0,\n  }\n}\n\nexport const transformRoundResponse = (roundResponse: RoundResponse): Round => {\n  const {\n    id,\n    epoch,\n    failed,\n    position,\n    startAt,\n    startBlock,\n    startHash,\n    lockAt,\n    lockBlock,\n    lockHash,\n    lockPrice,\n    lockRoundId,\n    closeAt,\n    closeBlock,\n    closeHash,\n    closePrice,\n    closeRoundId,\n    totalBets,\n    totalAmount,\n    bullBets,\n    bullAmount,\n    bearBets,\n    bearAmount,\n    bets = [],\n  } = roundResponse\n\n  return {\n    id,\n    failed,\n    startHash,\n    lockHash,\n    lockRoundId,\n    closeRoundId,\n    closeHash,\n    position: getRoundPosition(position),\n    epoch: numberOrNull(epoch),\n    startAt: numberOrNull(startAt),\n    startBlock: numberOrNull(startBlock),\n    lockAt: numberOrNull(lockAt),\n    lockBlock: numberOrNull(lockBlock),\n    lockPrice: lockPrice ? parseFloat(lockPrice) : 0,\n    closeAt: numberOrNull(closeAt),\n    closeBlock: numberOrNull(closeBlock),\n    closePrice: closePrice ? parseFloat(closePrice) : 0,\n    totalBets: numberOrNull(totalBets),\n    totalAmount: totalAmount ? parseFloat(totalAmount) : 0,\n    bullBets: numberOrNull(bullBets),\n    bullAmount: bullAmount ? parseFloat(bullAmount) : 0,\n    bearBets: numberOrNull(bearBets),\n    bearAmount: bearAmount ? parseFloat(bearAmount) : 0,\n    bets: bets.map(transformBetResponse),\n  }\n}\n\nexport const getRoundResult = (bet: Bet, currentEpoch: number): Result => {\n  const { round } = bet\n  if (round.failed) {\n    return Result.CANCELED\n  }\n\n  if (round.epoch >= currentEpoch - 1) {\n    return Result.LIVE\n  }\n\n  if (bet.round.position === BetPosition.HOUSE) {\n    return Result.HOUSE\n  }\n\n  const roundResultPosition = round.closePrice > round.lockPrice ? BetPosition.BULL : BetPosition.BEAR\n\n  return bet.position === roundResultPosition ? Result.WIN : Result.LOSE\n}\n\nexport const getFilteredBets = (bets: Bet[], filter: HistoryFilter) => {\n  switch (filter) {\n    case HistoryFilter.COLLECTED:\n      return bets.filter((bet) => bet.claimed === true)\n    case HistoryFilter.UNCOLLECTED:\n      return bets.filter((bet) => {\n        return !bet.claimed && (bet.position === bet.round.position || bet.round.failed === true)\n      })\n    case HistoryFilter.ALL:\n    default:\n      return bets\n  }\n}\n\nexport const getTotalWon = async (): Promise<number> => {\n  const { market } = (await request(\n    GRAPH_API_PREDICTION,\n    gql`\n      query getTotalWonData {\n        market(id: 1) {\n          totalBNB\n          totalBNBTreasury\n        }\n      }\n    `,\n  )) as { market: TotalWonMarketResponse }\n\n  const totalBNB = market.totalBNB ? parseFloat(market.totalBNB) : 0\n  const totalBNBTreasury = market.totalBNBTreasury ? parseFloat(market.totalBNBTreasury) : 0\n\n  return Math.max(totalBNB - totalBNBTreasury, 0)\n}\n\ntype WhereClause = Record<string, string | number | boolean | string[]>\n\nexport const getBetHistory = async (where: WhereClause = {}, first = 1000, skip = 0): Promise<BetResponse[]> => {\n  const response = await request(\n    GRAPH_API_PREDICTION,\n    gql`\n      query getBetHistory($first: Int!, $skip: Int!, $where: Bet_filter) {\n        bets(first: $first, skip: $skip, where: $where, order: createdAt, orderDirection: desc) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n    `,\n    { first, skip, where },\n  )\n  return response.bets\n}\n\nexport const getBet = async (betId: string): Promise<BetResponse> => {\n  const response = await request(\n    GRAPH_API_PREDICTION,\n    gql`\n      query getBet($id: ID!) {\n        bet(id: $id) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n  `,\n    {\n      id: betId.toLowerCase(),\n    },\n  )\n  return response.bet\n}\n\nexport const getLedgerData = async (account: string, epochs: number[]) => {\n  const address = getPredictionsAddress()\n  const ledgerCalls = epochs.map((epoch) => ({\n    address,\n    name: 'ledger',\n    params: [epoch, account],\n  }))\n  const response = await multicallv2<PredictionsLedgerResponse[]>(predictionsAbi, ledgerCalls)\n  return response\n}\n\nexport const LEADERBOARD_RESULTS_PER_PAGE = 20\n\ninterface GetPredictionUsersOptions {\n  skip?: number\n  first?: number\n  orderBy?: string\n  orderDir?: string\n  where?: WhereClause\n}\n\nconst defaultPredictionUserOptions = {\n  skip: 0,\n  first: LEADERBOARD_RESULTS_PER_PAGE,\n  orderBy: 'createdAt',\n  orderDir: 'desc',\n}\n\nexport const getPredictionUsers = async (options: GetPredictionUsersOptions = {}): Promise<UserResponse[]> => {\n  const { first, skip, where, orderBy, orderDir } = { ...defaultPredictionUserOptions, ...options }\n  const response = await request(\n    GRAPH_API_PREDICTION,\n    gql`\n      query getUsers($first: Int!, $skip: Int!, $where: User_filter, $orderBy: User_orderBy, $orderDir: OrderDirection) {\n        users(first: $first, skip: $skip, where: $where, orderBy: $orderBy, orderDirection: $orderDir) {\n          ${getUserBaseFields()} \n        }\n      }\n    `,\n    { first, skip, where, orderBy, orderDir },\n  )\n  return response.users\n}\n\nexport const getPredictionUser = async (account: string): Promise<UserResponse> => {\n  const response = await request(\n    GRAPH_API_PREDICTION,\n    gql`\n      query getUser($id: ID!) {\n        user(id: $id) {\n          ${getUserBaseFields()}\n        }\n      }\n  `,\n    {\n      id: account.toLowerCase(),\n    },\n  )\n  return response.user\n}\n\nexport const getClaimStatuses = async (\n  account: string,\n  epochs: number[],\n): Promise<PredictionsState['claimableStatuses']> => {\n  const address = getPredictionsAddress()\n  const claimableCalls = epochs.map((epoch) => ({\n    address,\n    name: 'claimable',\n    params: [epoch, account],\n  }))\n  const claimableResponses = await multicallv2<[PredictionsClaimableResponse][]>(predictionsAbi, claimableCalls)\n\n  return claimableResponses.reduce((accum, claimableResponse, index) => {\n    const epoch = epochs[index]\n    const [claimable] = claimableResponse\n\n    return {\n      ...accum,\n      [epoch]: claimable,\n    }\n  }, {})\n}\n\nexport type MarketData = Pick<\n  PredictionsState,\n  'status' | 'currentEpoch' | 'intervalSeconds' | 'minBetAmount' | 'bufferSeconds'\n>\nexport const getPredictionData = async (): Promise<MarketData> => {\n  const address = getPredictionsAddress()\n  const staticCalls = ['currentEpoch', 'intervalSeconds', 'minBetAmount', 'paused', 'bufferSeconds'].map((method) => ({\n    address,\n    name: method,\n  }))\n  const [[currentEpoch], [intervalSeconds], [minBetAmount], [paused], [bufferSeconds]] = await multicallv2(\n    predictionsAbi,\n    staticCalls,\n  )\n\n  return {\n    status: paused ? PredictionStatus.PAUSED : PredictionStatus.LIVE,\n    currentEpoch: currentEpoch.toNumber(),\n    intervalSeconds: intervalSeconds.toNumber(),\n    minBetAmount: minBetAmount.toString(),\n    bufferSeconds: bufferSeconds.toNumber(),\n  }\n}\n\nexport const getRoundsData = async (epochs: number[]): Promise<PredictionsRoundsResponse[]> => {\n  const address = getPredictionsAddress()\n  const calls = epochs.map((epoch) => ({\n    address,\n    name: 'rounds',\n    params: [epoch],\n  }))\n  const response = await multicallv2<PredictionsRoundsResponse[]>(predictionsAbi, calls)\n  return response\n}\n\nexport const makeFutureRoundResponse = (epoch: number, startTimestamp: number): ReduxNodeRound => {\n  return {\n    epoch,\n    startTimestamp,\n    lockTimestamp: null,\n    closeTimestamp: null,\n    lockPrice: null,\n    closePrice: null,\n    totalAmount: ethers.BigNumber.from(0).toJSON(),\n    bullAmount: ethers.BigNumber.from(0).toJSON(),\n    bearAmount: ethers.BigNumber.from(0).toJSON(),\n    rewardBaseCalAmount: ethers.BigNumber.from(0).toJSON(),\n    rewardAmount: ethers.BigNumber.from(0).toJSON(),\n    oracleCalled: false,\n    lockOracleId: null,\n    closeOracleId: null,\n  }\n}\n\nexport const makeRoundData = (rounds: ReduxNodeRound[]): RoundData => {\n  return rounds.reduce((accum, round) => {\n    return {\n      ...accum,\n      [round.epoch.toString()]: round,\n    }\n  }, {})\n}\n\nexport const serializePredictionsLedgerResponse = (ledgerResponse: PredictionsLedgerResponse): ReduxNodeLedger => ({\n  position: ledgerResponse.position === 0 ? BetPosition.BULL : BetPosition.BEAR,\n  amount: ledgerResponse.amount.toJSON(),\n  claimed: ledgerResponse.claimed,\n})\n\nexport const makeLedgerData = (account: string, ledgers: PredictionsLedgerResponse[], epochs: number[]): LedgerData => {\n  return ledgers.reduce((accum, ledgerResponse, index) => {\n    if (!ledgerResponse) {\n      return accum\n    }\n\n    // If the amount is zero that means the user did not bet\n    if (ledgerResponse.amount.eq(0)) {\n      return accum\n    }\n\n    const epoch = epochs[index].toString()\n\n    return {\n      ...accum,\n      [account]: {\n        ...accum[account],\n        [epoch]: serializePredictionsLedgerResponse(ledgerResponse),\n      },\n    }\n  }, {})\n}\n\n/**\n * Serializes the return from the \"rounds\" call for redux\n */\nexport const serializePredictionsRoundsResponse = (response: PredictionsRoundsResponse): ReduxNodeRound => {\n  const {\n    epoch,\n    startTimestamp,\n    lockTimestamp,\n    closeTimestamp,\n    lockPrice,\n    closePrice,\n    totalAmount,\n    bullAmount,\n    bearAmount,\n    rewardBaseCalAmount,\n    rewardAmount,\n    oracleCalled,\n    lockOracleId,\n    closeOracleId,\n  } = response\n\n  return {\n    oracleCalled,\n    epoch: epoch.toNumber(),\n    startTimestamp: startTimestamp.eq(0) ? null : startTimestamp.toNumber(),\n    lockTimestamp: lockTimestamp.eq(0) ? null : lockTimestamp.toNumber(),\n    closeTimestamp: closeTimestamp.eq(0) ? null : closeTimestamp.toNumber(),\n    lockPrice: lockPrice.eq(0) ? null : lockPrice.toJSON(),\n    closePrice: closePrice.eq(0) ? null : closePrice.toJSON(),\n    totalAmount: totalAmount.toJSON(),\n    bullAmount: bullAmount.toJSON(),\n    bearAmount: bearAmount.toJSON(),\n    rewardBaseCalAmount: rewardBaseCalAmount.toJSON(),\n    rewardAmount: rewardAmount.toJSON(),\n    lockOracleId: lockOracleId.toString(),\n    closeOracleId: closeOracleId.toString(),\n  }\n}\n\n/**\n * Parse serialized values back into ethers.BigNumber\n * ethers.BigNumber values are stored with the \"toJSON()\" method, e.g  { type: \"BigNumber\", hex: string }\n */\nexport const parseBigNumberObj = <T = Record<string, any>, K = Record<string, any>>(data: T): K => {\n  return Object.keys(data).reduce((accum, key) => {\n    const value = data[key]\n\n    if (value && value?.type === 'BigNumber') {\n      return {\n        ...accum,\n        [key]: ethers.BigNumber.from(value),\n      }\n    }\n\n    return {\n      ...accum,\n      [key]: value,\n    }\n  }, {}) as K\n}\n\nexport const fetchUsersRoundsLength = async (account: string) => {\n  try {\n    const contract = getPredictionsContract()\n    const length = await contract.getUserRoundsLength(account)\n    return length\n  } catch {\n    return ethers.BigNumber.from(0)\n  }\n}\n\n/**\n * Fetches rounds a user has participated in\n */\nexport const fetchUserRounds = async (\n  account: string,\n  cursor = 0,\n  size = ROUNDS_PER_PAGE,\n): Promise<{ [key: string]: ReduxNodeLedger }> => {\n  const contract = getPredictionsContract()\n\n  try {\n    const [rounds, ledgers] = await contract.getUserRounds(account, cursor, size)\n\n    return rounds.reduce((accum, round, index) => {\n      return {\n        ...accum,\n        [round.toString()]: serializePredictionsLedgerResponse(ledgers[index]),\n      }\n    }, {})\n  } catch {\n    // When the results run out the contract throws an error.\n    return null\n  }\n}\n"]},"metadata":{},"sourceType":"module"}