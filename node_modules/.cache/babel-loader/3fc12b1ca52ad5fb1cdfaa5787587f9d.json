{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useMemo } from 'react';\nimport isEmpty from 'lodash/isEmpty';\nimport { useAppDispatch } from 'state';\nimport { fetchUserNfts } from 'state/nftMarket/reducer';\nimport { useGetCollections, useUserNfts } from 'state/nftMarket/hooks';\nimport usePreviousValue from 'hooks/usePreviousValue';\nimport { useProfile } from 'state/profile/hooks';\nimport { NftLocation, UserNftInitializationState } from 'state/nftMarket/types'; // We need to fetch collectibles for non-connected accounts, hence this hook accepts an account string.\n\nconst useFetchUserNfts = account => {\n  _s();\n\n  var _profile$tokenId;\n\n  const dispatch = useAppDispatch();\n  const {\n    profile,\n    isInitialized: isProfileInitialized,\n    isLoading: isProfileLoading\n  } = useProfile();\n  const {\n    userNftsInitializationState\n  } = useUserNfts();\n  const collections = useGetCollections();\n  const hasProfileNft = profile === null || profile === void 0 ? void 0 : profile.tokenId;\n  const profileNftTokenId = profile === null || profile === void 0 ? void 0 : (_profile$tokenId = profile.tokenId) === null || _profile$tokenId === void 0 ? void 0 : _profile$tokenId.toString();\n  const profileNftCollectionAddress = profile === null || profile === void 0 ? void 0 : profile.collectionAddress;\n  const profileNftWithCollectionAddress = useMemo(() => {\n    if (hasProfileNft) {\n      return {\n        tokenId: profileNftTokenId,\n        collectionAddress: profileNftCollectionAddress,\n        nftLocation: NftLocation.PROFILE\n      };\n    }\n\n    return null;\n  }, [profileNftTokenId, profileNftCollectionAddress, hasProfileNft]);\n  const previousProfileNftTokenId = usePreviousValue(profileNftTokenId); // Fetch on first load when profile fetch is resolved\n\n  const shouldFetch = account && userNftsInitializationState === UserNftInitializationState.UNINITIALIZED && isProfileInitialized && !isProfileLoading; // Fetch on account / profile change, once profile fetch is resolved\n\n  const hasAccountSwitched = previousProfileNftTokenId !== profileNftTokenId && !isProfileLoading;\n  useEffect(() => {\n    if ((shouldFetch || hasAccountSwitched) && !isEmpty(collections)) {\n      dispatch(fetchUserNfts({\n        account,\n        collections,\n        profileNftWithCollectionAddress\n      }));\n    }\n  }, [dispatch, account, shouldFetch, hasAccountSwitched, profileNftTokenId, collections, profileNftWithCollectionAddress]);\n};\n\n_s(useFetchUserNfts, \"X+m8Ooh1fZAWmJA7po+mAbTZOAU=\", false, function () {\n  return [useAppDispatch, useProfile, useUserNfts, useGetCollections, usePreviousValue];\n});\n\nexport default useFetchUserNfts;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/views/Nft/market/Profile/hooks/useFetchUserNfts.tsx"],"names":["useEffect","useMemo","isEmpty","useAppDispatch","fetchUserNfts","useGetCollections","useUserNfts","usePreviousValue","useProfile","NftLocation","UserNftInitializationState","useFetchUserNfts","account","dispatch","profile","isInitialized","isProfileInitialized","isLoading","isProfileLoading","userNftsInitializationState","collections","hasProfileNft","tokenId","profileNftTokenId","toString","profileNftCollectionAddress","collectionAddress","profileNftWithCollectionAddress","nftLocation","PROFILE","previousProfileNftTokenId","shouldFetch","UNINITIALIZED","hasAccountSwitched"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,OAApB,QAAmC,OAAnC;AACA,OAAOC,OAAP,MAAoB,gBAApB;AACA,SAASC,cAAT,QAA+B,OAA/B;AACA,SAASC,aAAT,QAA8B,yBAA9B;AACA,SAASC,iBAAT,EAA4BC,WAA5B,QAA+C,uBAA/C;AACA,OAAOC,gBAAP,MAA6B,wBAA7B;AACA,SAASC,UAAT,QAA2B,qBAA3B;AACA,SAASC,WAAT,EAAsBC,0BAAtB,QAAwD,uBAAxD,C,CAEA;;AACA,MAAMC,gBAAgB,GAAIC,OAAD,IAAqB;AAAA;;AAAA;;AAC5C,QAAMC,QAAQ,GAAGV,cAAc,EAA/B;AACA,QAAM;AAAEW,IAAAA,OAAF;AAAWC,IAAAA,aAAa,EAAEC,oBAA1B;AAAgDC,IAAAA,SAAS,EAAEC;AAA3D,MAAgFV,UAAU,EAAhG;AACA,QAAM;AAAEW,IAAAA;AAAF,MAAkCb,WAAW,EAAnD;AACA,QAAMc,WAAW,GAAGf,iBAAiB,EAArC;AAEA,QAAMgB,aAAa,GAAGP,OAAH,aAAGA,OAAH,uBAAGA,OAAO,CAAEQ,OAA/B;AACA,QAAMC,iBAAiB,GAAGT,OAAH,aAAGA,OAAH,2CAAGA,OAAO,CAAEQ,OAAZ,qDAAG,iBAAkBE,QAAlB,EAA1B;AACA,QAAMC,2BAA2B,GAAGX,OAAH,aAAGA,OAAH,uBAAGA,OAAO,CAAEY,iBAA7C;AAEA,QAAMC,+BAA+B,GAAG1B,OAAO,CAAC,MAAM;AACpD,QAAIoB,aAAJ,EAAmB;AACjB,aAAO;AACLC,QAAAA,OAAO,EAAEC,iBADJ;AAELG,QAAAA,iBAAiB,EAAED,2BAFd;AAGLG,QAAAA,WAAW,EAAEnB,WAAW,CAACoB;AAHpB,OAAP;AAKD;;AACD,WAAO,IAAP;AACD,GAT8C,EAS5C,CAACN,iBAAD,EAAoBE,2BAApB,EAAiDJ,aAAjD,CAT4C,CAA/C;AAWA,QAAMS,yBAAyB,GAAGvB,gBAAgB,CAACgB,iBAAD,CAAlD,CArB4C,CAuB5C;;AACA,QAAMQ,WAAW,GACfnB,OAAO,IACPO,2BAA2B,KAAKT,0BAA0B,CAACsB,aAD3D,IAEAhB,oBAFA,IAGA,CAACE,gBAJH,CAxB4C,CA8B5C;;AACA,QAAMe,kBAAkB,GAAGH,yBAAyB,KAAKP,iBAA9B,IAAmD,CAACL,gBAA/E;AAEAlB,EAAAA,SAAS,CAAC,MAAM;AACd,QAAI,CAAC+B,WAAW,IAAIE,kBAAhB,KAAuC,CAAC/B,OAAO,CAACkB,WAAD,CAAnD,EAAkE;AAChEP,MAAAA,QAAQ,CAACT,aAAa,CAAC;AAAEQ,QAAAA,OAAF;AAAWQ,QAAAA,WAAX;AAAwBO,QAAAA;AAAxB,OAAD,CAAd,CAAR;AACD;AACF,GAJQ,EAIN,CACDd,QADC,EAEDD,OAFC,EAGDmB,WAHC,EAIDE,kBAJC,EAKDV,iBALC,EAMDH,WANC,EAODO,+BAPC,CAJM,CAAT;AAaD,CA9CD;;GAAMhB,gB;UACaR,c,EACqEK,U,EAC9CF,W,EACpBD,iB,EAiBcE,gB;;;AA2BpC,eAAeI,gBAAf","sourcesContent":["import { useEffect, useMemo } from 'react'\nimport isEmpty from 'lodash/isEmpty'\nimport { useAppDispatch } from 'state'\nimport { fetchUserNfts } from 'state/nftMarket/reducer'\nimport { useGetCollections, useUserNfts } from 'state/nftMarket/hooks'\nimport usePreviousValue from 'hooks/usePreviousValue'\nimport { useProfile } from 'state/profile/hooks'\nimport { NftLocation, UserNftInitializationState } from 'state/nftMarket/types'\n\n// We need to fetch collectibles for non-connected accounts, hence this hook accepts an account string.\nconst useFetchUserNfts = (account: string) => {\n  const dispatch = useAppDispatch()\n  const { profile, isInitialized: isProfileInitialized, isLoading: isProfileLoading } = useProfile()\n  const { userNftsInitializationState } = useUserNfts()\n  const collections = useGetCollections()\n\n  const hasProfileNft = profile?.tokenId\n  const profileNftTokenId = profile?.tokenId?.toString()\n  const profileNftCollectionAddress = profile?.collectionAddress\n\n  const profileNftWithCollectionAddress = useMemo(() => {\n    if (hasProfileNft) {\n      return {\n        tokenId: profileNftTokenId,\n        collectionAddress: profileNftCollectionAddress,\n        nftLocation: NftLocation.PROFILE,\n      }\n    }\n    return null\n  }, [profileNftTokenId, profileNftCollectionAddress, hasProfileNft])\n\n  const previousProfileNftTokenId = usePreviousValue(profileNftTokenId)\n\n  // Fetch on first load when profile fetch is resolved\n  const shouldFetch =\n    account &&\n    userNftsInitializationState === UserNftInitializationState.UNINITIALIZED &&\n    isProfileInitialized &&\n    !isProfileLoading\n\n  // Fetch on account / profile change, once profile fetch is resolved\n  const hasAccountSwitched = previousProfileNftTokenId !== profileNftTokenId && !isProfileLoading\n\n  useEffect(() => {\n    if ((shouldFetch || hasAccountSwitched) && !isEmpty(collections)) {\n      dispatch(fetchUserNfts({ account, collections, profileNftWithCollectionAddress }))\n    }\n  }, [\n    dispatch,\n    account,\n    shouldFetch,\n    hasAccountSwitched,\n    profileNftTokenId,\n    collections,\n    profileNftWithCollectionAddress,\n  ])\n}\n\nexport default useFetchUserNfts\n"]},"metadata":{},"sourceType":"module"}