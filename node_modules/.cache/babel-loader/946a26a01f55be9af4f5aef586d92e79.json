{"ast":null,"code":"import { request, gql } from 'graphql-request';\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints';\nimport { getRoundIdsArray, fetchMultipleLotteries } from './helpers';\nexport const MAX_LOTTERIES_REQUEST_SIZE = 100;\n/* eslint-disable camelcase */\n\nconst applyNodeDataToLotteriesGraphResponse = (nodeData, graphResponse) => {\n  //   If no graph response - return node data\n  if (graphResponse.length === 0) {\n    return nodeData.map(nodeRound => {\n      return {\n        endTime: nodeRound.endTime,\n        finalNumber: nodeRound.finalNumber.toString(),\n        startTime: nodeRound.startTime,\n        status: nodeRound.status,\n        id: nodeRound.lotteryId.toString(),\n        ticketPrice: nodeRound.priceTicketInCake,\n        totalTickets: '',\n        totalUsers: '',\n        winningTickets: ''\n      };\n    });\n  } // Populate all nodeRound data with supplementary graphResponse round data when available\n\n\n  const nodeRoundsWithGraphData = nodeData.map(nodeRoundData => {\n    const graphRoundData = graphResponse.find(graphResponseRound => graphResponseRound.id === nodeRoundData.lotteryId);\n    return {\n      endTime: nodeRoundData.endTime,\n      finalNumber: nodeRoundData.finalNumber.toString(),\n      startTime: nodeRoundData.startTime,\n      status: nodeRoundData.status,\n      id: nodeRoundData.lotteryId,\n      ticketPrice: graphRoundData === null || graphRoundData === void 0 ? void 0 : graphRoundData.ticketPrice,\n      totalTickets: graphRoundData === null || graphRoundData === void 0 ? void 0 : graphRoundData.totalTickets,\n      totalUsers: graphRoundData === null || graphRoundData === void 0 ? void 0 : graphRoundData.totalUsers,\n      winningTickets: graphRoundData === null || graphRoundData === void 0 ? void 0 : graphRoundData.winningTickets\n    };\n  }); // Return the rounds with combined node + subgraph data, plus all remaining subgraph rounds.\n\n  const [lastCombinedDataRound] = nodeRoundsWithGraphData.slice(-1);\n  const lastCombinedDataRoundIndex = graphResponse.map(graphRound => graphRound === null || graphRound === void 0 ? void 0 : graphRound.id).indexOf(lastCombinedDataRound === null || lastCombinedDataRound === void 0 ? void 0 : lastCombinedDataRound.id);\n  const remainingSubgraphRounds = graphResponse ? graphResponse.splice(lastCombinedDataRoundIndex + 1) : [];\n  const mergedResponse = [...nodeRoundsWithGraphData, ...remainingSubgraphRounds];\n  return mergedResponse;\n};\n\nexport const getGraphLotteries = async (first = MAX_LOTTERIES_REQUEST_SIZE, skip = 0, where = {}) => {\n  try {\n    const response = await request(GRAPH_API_LOTTERY, gql`\n        query getLotteries($first: Int!, $skip: Int!, $where: Lottery_filter) {\n          lotteries(first: $first, skip: $skip, where: $where, orderDirection: desc, orderBy: block) {\n            id\n            totalUsers\n            totalTickets\n            winningTickets\n            status\n            finalNumber\n            startTime\n            endTime\n            ticketPrice\n          }\n        }\n      `, {\n      skip,\n      first,\n      where\n    });\n    return response.lotteries;\n  } catch (error) {\n    console.error(error);\n    return [];\n  }\n};\n\nconst getLotteriesData = async currentLotteryId => {\n  const idsForNodesCall = getRoundIdsArray(currentLotteryId);\n  const nodeData = await fetchMultipleLotteries(idsForNodesCall);\n  const graphResponse = await getGraphLotteries();\n  const mergedData = applyNodeDataToLotteriesGraphResponse(nodeData, graphResponse);\n  return mergedData;\n};\n\nexport default getLotteriesData;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/lottery/getLotteriesData.ts"],"names":["request","gql","GRAPH_API_LOTTERY","getRoundIdsArray","fetchMultipleLotteries","MAX_LOTTERIES_REQUEST_SIZE","applyNodeDataToLotteriesGraphResponse","nodeData","graphResponse","length","map","nodeRound","endTime","finalNumber","toString","startTime","status","id","lotteryId","ticketPrice","priceTicketInCake","totalTickets","totalUsers","winningTickets","nodeRoundsWithGraphData","nodeRoundData","graphRoundData","find","graphResponseRound","lastCombinedDataRound","slice","lastCombinedDataRoundIndex","graphRound","indexOf","remainingSubgraphRounds","splice","mergedResponse","getGraphLotteries","first","skip","where","response","lotteries","error","console","getLotteriesData","currentLotteryId","idsForNodesCall","mergedData"],"mappings":"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","sourcesContent":["import { request, gql } from 'graphql-request'\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints'\nimport { LotteryRoundGraphEntity, LotteryResponse } from 'state/types'\nimport { getRoundIdsArray, fetchMultipleLotteries } from './helpers'\n\nexport const MAX_LOTTERIES_REQUEST_SIZE = 100\n\n/* eslint-disable camelcase */\ntype LotteriesWhere = { id_in?: string[] }\n\nconst applyNodeDataToLotteriesGraphResponse = (\n  nodeData: LotteryResponse[],\n  graphResponse: LotteryRoundGraphEntity[],\n): LotteryRoundGraphEntity[] => {\n  //   If no graph response - return node data\n  if (graphResponse.length === 0) {\n    return nodeData.map((nodeRound) => {\n      return {\n        endTime: nodeRound.endTime,\n        finalNumber: nodeRound.finalNumber.toString(),\n        startTime: nodeRound.startTime,\n        status: nodeRound.status,\n        id: nodeRound.lotteryId.toString(),\n        ticketPrice: nodeRound.priceTicketInCake,\n        totalTickets: '',\n        totalUsers: '',\n        winningTickets: '',\n      }\n    })\n  }\n\n  // Populate all nodeRound data with supplementary graphResponse round data when available\n  const nodeRoundsWithGraphData = nodeData.map((nodeRoundData) => {\n    const graphRoundData = graphResponse.find((graphResponseRound) => graphResponseRound.id === nodeRoundData.lotteryId)\n    return {\n      endTime: nodeRoundData.endTime,\n      finalNumber: nodeRoundData.finalNumber.toString(),\n      startTime: nodeRoundData.startTime,\n      status: nodeRoundData.status,\n      id: nodeRoundData.lotteryId,\n      ticketPrice: graphRoundData?.ticketPrice,\n      totalTickets: graphRoundData?.totalTickets,\n      totalUsers: graphRoundData?.totalUsers,\n      winningTickets: graphRoundData?.winningTickets,\n    }\n  })\n\n  // Return the rounds with combined node + subgraph data, plus all remaining subgraph rounds.\n  const [lastCombinedDataRound] = nodeRoundsWithGraphData.slice(-1)\n  const lastCombinedDataRoundIndex = graphResponse\n    .map((graphRound) => graphRound?.id)\n    .indexOf(lastCombinedDataRound?.id)\n\n  const remainingSubgraphRounds = graphResponse ? graphResponse.splice(lastCombinedDataRoundIndex + 1) : []\n  const mergedResponse = [...nodeRoundsWithGraphData, ...remainingSubgraphRounds]\n  return mergedResponse\n}\n\nexport const getGraphLotteries = async (\n  first = MAX_LOTTERIES_REQUEST_SIZE,\n  skip = 0,\n  where: LotteriesWhere = {},\n): Promise<LotteryRoundGraphEntity[]> => {\n  try {\n    const response = await request(\n      GRAPH_API_LOTTERY,\n      gql`\n        query getLotteries($first: Int!, $skip: Int!, $where: Lottery_filter) {\n          lotteries(first: $first, skip: $skip, where: $where, orderDirection: desc, orderBy: block) {\n            id\n            totalUsers\n            totalTickets\n            winningTickets\n            status\n            finalNumber\n            startTime\n            endTime\n            ticketPrice\n          }\n        }\n      `,\n      { skip, first, where },\n    )\n    return response.lotteries\n  } catch (error) {\n    console.error(error)\n    return []\n  }\n}\n\nconst getLotteriesData = async (currentLotteryId: string): Promise<LotteryRoundGraphEntity[]> => {\n  const idsForNodesCall = getRoundIdsArray(currentLotteryId)\n  const nodeData = await fetchMultipleLotteries(idsForNodesCall)\n  const graphResponse = await getGraphLotteries()\n  const mergedData = applyNodeDataToLotteriesGraphResponse(nodeData, graphResponse)\n  return mergedData\n}\n\nexport default getLotteriesData\n"]},"metadata":{},"sourceType":"module"}