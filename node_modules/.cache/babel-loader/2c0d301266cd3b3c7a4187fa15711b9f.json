{"ast":null,"code":"import _objectSpread from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _regeneratorRuntime from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{createAsyncThunk,createSlice}from'@reduxjs/toolkit';import{ProfileAvatarFetchStatus}from'state/types';import{getProfile,getProfileAvatar,getUsername}from'./helpers';var initialState={isInitialized:false,isLoading:true,hasRegistered:false,data:null,profileAvatars:{}};export var fetchProfileAvatar=createAsyncThunk('profile/fetchProfileAvatar',/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(account){var _yield$getProfileAvat,nft,hasRegistered;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return getProfileAvatar(account);case 2:_yield$getProfileAvat=_context.sent;nft=_yield$getProfileAvat.nft;hasRegistered=_yield$getProfileAvat.hasRegistered;return _context.abrupt(\"return\",{account:account,nft:nft,hasRegistered:hasRegistered});case 6:case\"end\":return _context.stop();}}},_callee);}));return function(_x){return _ref.apply(this,arguments);};}());export var fetchProfileUsername=createAsyncThunk('profile/fetchProfileUsername',/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2){var account,hasRegistered,username;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:account=_ref2.account,hasRegistered=_ref2.hasRegistered;if(hasRegistered){_context2.next=3;break;}return _context2.abrupt(\"return\",{account:account,username:''});case 3:_context2.next=5;return getUsername(account);case 5:username=_context2.sent;return _context2.abrupt(\"return\",{account:account,username:username});case 7:case\"end\":return _context2.stop();}}},_callee2);}));return function(_x2){return _ref3.apply(this,arguments);};}());export var profileSlice=createSlice({name:'profile',initialState:initialState,reducers:{profileFetchStart:function profileFetchStart(state){state.isLoading=true;},profileFetchSucceeded:function profileFetchSucceeded(state,action){var _action$payload=action.payload,profile=_action$payload.profile,hasRegistered=_action$payload.hasRegistered;state.isInitialized=true;state.isLoading=false;state.hasRegistered=hasRegistered;state.data=profile;},profileFetchFailed:function profileFetchFailed(state){state.isLoading=false;state.isInitialized=true;},profileClear:function profileClear(){return _objectSpread(_objectSpread({},initialState),{},{isLoading:false});},addPoints:function addPoints(state,action){state.data.points+=action.payload;}},extraReducers:function extraReducers(builder){builder.addCase(fetchProfileUsername.pending,function(state,action){var account=action.meta.arg.account;if(state.profileAvatars[account]){state.profileAvatars[account]=_objectSpread(_objectSpread({},state.profileAvatars[account]),{},{usernameFetchStatus:ProfileAvatarFetchStatus.FETCHING});}else{state.profileAvatars[account]={hasRegistered:false,username:null,nft:null,// I think in theory this else should never be reached since we only check for username after we checked for profile/avatar\n// just in case I set isFetchingAvatar will be ProfileAvatarFetchStatus.FETCHED at this point to avoid refetching\nusernameFetchStatus:ProfileAvatarFetchStatus.FETCHING,avatarFetchStatus:ProfileAvatarFetchStatus.FETCHED};}});builder.addCase(fetchProfileUsername.fulfilled,function(state,action){var _action$payload2=action.payload,account=_action$payload2.account,username=_action$payload2.username;if(state.profileAvatars[account]){state.profileAvatars[account]=_objectSpread(_objectSpread({},state.profileAvatars[account]),{},{username:username,usernameFetchStatus:ProfileAvatarFetchStatus.FETCHED});}else{state.profileAvatars[account]={username:username,nft:null,hasRegistered:true,usernameFetchStatus:ProfileAvatarFetchStatus.FETCHED,// I think in theory this else should never be reached since we only check for username after we checked for profile/avatar\n// just in case I set isFetchingAvatar will be ProfileAvatarFetchStatus.FETCHED at this point to avoid refetching\navatarFetchStatus:ProfileAvatarFetchStatus.FETCHED};}});builder.addCase(fetchProfileUsername.rejected,function(state,action){var account=action.meta.arg.account;if(state.profileAvatars[account]){state.profileAvatars[account]=_objectSpread(_objectSpread({},state.profileAvatars[account]),{},{username:'',usernameFetchStatus:ProfileAvatarFetchStatus.FETCHED});}else{state.profileAvatars[account]={hasRegistered:false,username:'',nft:null,usernameFetchStatus:ProfileAvatarFetchStatus.FETCHED,avatarFetchStatus:ProfileAvatarFetchStatus.FETCHED};}});builder.addCase(fetchProfileAvatar.pending,function(state,action){var account=action.meta.arg;if(state.profileAvatars[account]){state.profileAvatars[account]=_objectSpread(_objectSpread({},state.profileAvatars[account]),{},{hasRegistered:false,avatarFetchStatus:ProfileAvatarFetchStatus.FETCHING});}else{state.profileAvatars[account]={username:null,nft:null,hasRegistered:false,usernameFetchStatus:ProfileAvatarFetchStatus.NOT_FETCHED,avatarFetchStatus:ProfileAvatarFetchStatus.FETCHING};}});builder.addCase(fetchProfileAvatar.fulfilled,function(state,action){var _action$payload3=action.payload,account=_action$payload3.account,nft=_action$payload3.nft,hasRegistered=_action$payload3.hasRegistered;if(state.profileAvatars[account]){state.profileAvatars[account]=_objectSpread(_objectSpread({},state.profileAvatars[account]),{},{nft:nft,hasRegistered:hasRegistered,avatarFetchStatus:ProfileAvatarFetchStatus.FETCHED});}else{state.profileAvatars[account]={username:null,nft:nft,hasRegistered:hasRegistered,usernameFetchStatus:ProfileAvatarFetchStatus.NOT_FETCHED,avatarFetchStatus:ProfileAvatarFetchStatus.FETCHED};}});builder.addCase(fetchProfileAvatar.rejected,function(state,action){var account=action.meta.arg;if(state.profileAvatars[account]){state.profileAvatars[account]=_objectSpread(_objectSpread({},state.profileAvatars[account]),{},{nft:null,hasRegistered:false,avatarFetchStatus:ProfileAvatarFetchStatus.FETCHED});}else{state.profileAvatars[account]={username:null,nft:null,hasRegistered:false,usernameFetchStatus:ProfileAvatarFetchStatus.NOT_FETCHED,avatarFetchStatus:ProfileAvatarFetchStatus.FETCHED};}});}});// Actions\nvar _profileSlice$actions=profileSlice.actions,profileFetchStart=_profileSlice$actions.profileFetchStart,profileFetchSucceeded=_profileSlice$actions.profileFetchSucceeded,profileFetchFailed=_profileSlice$actions.profileFetchFailed,profileClear=_profileSlice$actions.profileClear,addPoints=_profileSlice$actions.addPoints;// Thunks\n// TODO: this should be an AsyncThunk\nexport{profileFetchStart,profileFetchSucceeded,profileFetchFailed,profileClear,addPoints};export var fetchProfile=function fetchProfile(address){return/*#__PURE__*/function(){var _ref4=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(dispatch){var response;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.prev=0;dispatch(profileFetchStart());_context3.next=4;return getProfile(address);case 4:response=_context3.sent;dispatch(profileFetchSucceeded(response));_context3.next=12;break;case 8:_context3.prev=8;_context3.t0=_context3[\"catch\"](0);console.error(_context3.t0);dispatch(profileFetchFailed());case 12:case\"end\":return _context3.stop();}}},_callee3,null,[[0,8]]);}));return function(_x3){return _ref4.apply(this,arguments);};}();};export default profileSlice.reducer;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/profile/index.tsx"],"names":["createAsyncThunk","createSlice","ProfileAvatarFetchStatus","getProfile","getProfileAvatar","getUsername","initialState","isInitialized","isLoading","hasRegistered","data","profileAvatars","fetchProfileAvatar","account","nft","fetchProfileUsername","username","profileSlice","name","reducers","profileFetchStart","state","profileFetchSucceeded","action","payload","profile","profileFetchFailed","profileClear","addPoints","points","extraReducers","builder","addCase","pending","meta","arg","usernameFetchStatus","FETCHING","avatarFetchStatus","FETCHED","fulfilled","rejected","NOT_FETCHED","actions","fetchProfile","address","dispatch","response","console","error","reducer"],"mappings":"ocAAA,OAASA,gBAAT,CAA2BC,WAA3B,KAA6D,kBAA7D,CACA,OAAuBC,wBAAvB,KAAuD,aAAvD,CAGA,OAASC,UAAT,CAAqBC,gBAArB,CAA2DC,WAA3D,KAA8E,WAA9E,CAEA,GAAMC,CAAAA,YAA0B,CAAG,CACjCC,aAAa,CAAE,KADkB,CAEjCC,SAAS,CAAE,IAFsB,CAGjCC,aAAa,CAAE,KAHkB,CAIjCC,IAAI,CAAE,IAJ2B,CAKjCC,cAAc,CAAE,EALiB,CAAnC,CAQA,MAAO,IAAMC,CAAAA,kBAAkB,CAAGZ,gBAAgB,CAChD,4BADgD,0FAEhD,iBAAOa,OAAP,oLACuCT,CAAAA,gBAAgB,CAACS,OAAD,CADvD,4CACUC,GADV,uBACUA,GADV,CACeL,aADf,uBACeA,aADf,iCAES,CAAEI,OAAO,CAAPA,OAAF,CAAWC,GAAG,CAAHA,GAAX,CAAgBL,aAAa,CAAbA,aAAhB,CAFT,wDAFgD,+DAA3C,CAQP,MAAO,IAAMM,CAAAA,oBAAoB,CAAGf,gBAAgB,CAGlD,8BAHkD,2FAGlB,gLAASa,OAAT,OAASA,OAAT,CAAkBJ,aAAlB,OAAkBA,aAAlB,IAC3BA,aAD2B,2DAEvB,CAAEI,OAAO,CAAPA,OAAF,CAAWG,QAAQ,CAAE,EAArB,CAFuB,gCAITX,CAAAA,WAAW,CAACQ,OAAD,CAJF,QAI1BG,QAJ0B,iDAKzB,CAAEH,OAAO,CAAPA,OAAF,CAAWG,QAAQ,CAARA,QAAX,CALyB,0DAHkB,iEAA7C,CAWP,MAAO,IAAMC,CAAAA,YAAY,CAAGhB,WAAW,CAAC,CACtCiB,IAAI,CAAE,SADgC,CAEtCZ,YAAY,CAAZA,YAFsC,CAGtCa,QAAQ,CAAE,CACRC,iBAAiB,CAAE,2BAACC,KAAD,CAAW,CAC5BA,KAAK,CAACb,SAAN,CAAkB,IAAlB,CACD,CAHO,CAIRc,qBAAqB,CAAE,+BAACD,KAAD,CAAQE,MAAR,CAAsD,CAC3E,oBAAmCA,MAAM,CAACC,OAA1C,CAAQC,OAAR,iBAAQA,OAAR,CAAiBhB,aAAjB,iBAAiBA,aAAjB,CAEAY,KAAK,CAACd,aAAN,CAAsB,IAAtB,CACAc,KAAK,CAACb,SAAN,CAAkB,KAAlB,CACAa,KAAK,CAACZ,aAAN,CAAsBA,aAAtB,CACAY,KAAK,CAACX,IAAN,CAAae,OAAb,CACD,CAXO,CAYRC,kBAAkB,CAAE,4BAACL,KAAD,CAAW,CAC7BA,KAAK,CAACb,SAAN,CAAkB,KAAlB,CACAa,KAAK,CAACd,aAAN,CAAsB,IAAtB,CACD,CAfO,CAgBRoB,YAAY,CAAE,8DACTrB,YADS,MAEZE,SAAS,CAAE,KAFC,IAhBN,CAoBRoB,SAAS,CAAE,mBAACP,KAAD,CAAQE,MAAR,CAA0C,CACnDF,KAAK,CAACX,IAAN,CAAWmB,MAAX,EAAqBN,MAAM,CAACC,OAA5B,CACD,CAtBO,CAH4B,CA2BtCM,aAAa,CAAE,uBAACC,OAAD,CAAa,CAC1BA,OAAO,CAACC,OAAR,CAAgBjB,oBAAoB,CAACkB,OAArC,CAA8C,SAACZ,KAAD,CAAQE,MAAR,CAAmB,CAC/D,GAAQV,CAAAA,OAAR,CAAoBU,MAAM,CAACW,IAAP,CAAYC,GAAhC,CAAQtB,OAAR,CACA,GAAIQ,KAAK,CAACV,cAAN,CAAqBE,OAArB,CAAJ,CAAmC,CACjCQ,KAAK,CAACV,cAAN,CAAqBE,OAArB,iCACKQ,KAAK,CAACV,cAAN,CAAqBE,OAArB,CADL,MAEEuB,mBAAmB,CAAElC,wBAAwB,CAACmC,QAFhD,GAID,CALD,IAKO,CACLhB,KAAK,CAACV,cAAN,CAAqBE,OAArB,EAAgC,CAC9BJ,aAAa,CAAE,KADe,CAE9BO,QAAQ,CAAE,IAFoB,CAG9BF,GAAG,CAAE,IAHyB,CAI9B;AACA;AACAsB,mBAAmB,CAAElC,wBAAwB,CAACmC,QANhB,CAO9BC,iBAAiB,CAAEpC,wBAAwB,CAACqC,OAPd,CAAhC,CASD,CACF,CAlBD,EAmBAR,OAAO,CAACC,OAAR,CAAgBjB,oBAAoB,CAACyB,SAArC,CAAgD,SAACnB,KAAD,CAAQE,MAAR,CAAmB,CACjE,qBAA8BA,MAAM,CAACC,OAArC,CAAQX,OAAR,kBAAQA,OAAR,CAAiBG,QAAjB,kBAAiBA,QAAjB,CAEA,GAAIK,KAAK,CAACV,cAAN,CAAqBE,OAArB,CAAJ,CAAmC,CACjCQ,KAAK,CAACV,cAAN,CAAqBE,OAArB,iCACKQ,KAAK,CAACV,cAAN,CAAqBE,OAArB,CADL,MAEEG,QAAQ,CAARA,QAFF,CAGEoB,mBAAmB,CAAElC,wBAAwB,CAACqC,OAHhD,GAKD,CAND,IAMO,CACLlB,KAAK,CAACV,cAAN,CAAqBE,OAArB,EAAgC,CAC9BG,QAAQ,CAARA,QAD8B,CAE9BF,GAAG,CAAE,IAFyB,CAG9BL,aAAa,CAAE,IAHe,CAI9B2B,mBAAmB,CAAElC,wBAAwB,CAACqC,OAJhB,CAK9B;AACA;AACAD,iBAAiB,CAAEpC,wBAAwB,CAACqC,OAPd,CAAhC,CASD,CACF,CApBD,EAqBAR,OAAO,CAACC,OAAR,CAAgBjB,oBAAoB,CAAC0B,QAArC,CAA+C,SAACpB,KAAD,CAAQE,MAAR,CAAmB,CAChE,GAAQV,CAAAA,OAAR,CAAoBU,MAAM,CAACW,IAAP,CAAYC,GAAhC,CAAQtB,OAAR,CACA,GAAIQ,KAAK,CAACV,cAAN,CAAqBE,OAArB,CAAJ,CAAmC,CACjCQ,KAAK,CAACV,cAAN,CAAqBE,OAArB,iCACKQ,KAAK,CAACV,cAAN,CAAqBE,OAArB,CADL,MAEEG,QAAQ,CAAE,EAFZ,CAGEoB,mBAAmB,CAAElC,wBAAwB,CAACqC,OAHhD,GAKD,CAND,IAMO,CACLlB,KAAK,CAACV,cAAN,CAAqBE,OAArB,EAAgC,CAC9BJ,aAAa,CAAE,KADe,CAE9BO,QAAQ,CAAE,EAFoB,CAG9BF,GAAG,CAAE,IAHyB,CAI9BsB,mBAAmB,CAAElC,wBAAwB,CAACqC,OAJhB,CAK9BD,iBAAiB,CAAEpC,wBAAwB,CAACqC,OALd,CAAhC,CAOD,CACF,CAjBD,EAkBAR,OAAO,CAACC,OAAR,CAAgBpB,kBAAkB,CAACqB,OAAnC,CAA4C,SAACZ,KAAD,CAAQE,MAAR,CAAmB,CAC7D,GAAMV,CAAAA,OAAO,CAAGU,MAAM,CAACW,IAAP,CAAYC,GAA5B,CACA,GAAId,KAAK,CAACV,cAAN,CAAqBE,OAArB,CAAJ,CAAmC,CACjCQ,KAAK,CAACV,cAAN,CAAqBE,OAArB,iCACKQ,KAAK,CAACV,cAAN,CAAqBE,OAArB,CADL,MAEEJ,aAAa,CAAE,KAFjB,CAGE6B,iBAAiB,CAAEpC,wBAAwB,CAACmC,QAH9C,GAKD,CAND,IAMO,CACLhB,KAAK,CAACV,cAAN,CAAqBE,OAArB,EAAgC,CAC9BG,QAAQ,CAAE,IADoB,CAE9BF,GAAG,CAAE,IAFyB,CAG9BL,aAAa,CAAE,KAHe,CAI9B2B,mBAAmB,CAAElC,wBAAwB,CAACwC,WAJhB,CAK9BJ,iBAAiB,CAAEpC,wBAAwB,CAACmC,QALd,CAAhC,CAOD,CACF,CAjBD,EAkBAN,OAAO,CAACC,OAAR,CAAgBpB,kBAAkB,CAAC4B,SAAnC,CAA8C,SAACnB,KAAD,CAAQE,MAAR,CAAmB,CAC/D,qBAAwCA,MAAM,CAACC,OAA/C,CAAQX,OAAR,kBAAQA,OAAR,CAAiBC,GAAjB,kBAAiBA,GAAjB,CAAsBL,aAAtB,kBAAsBA,aAAtB,CAEA,GAAIY,KAAK,CAACV,cAAN,CAAqBE,OAArB,CAAJ,CAAmC,CACjCQ,KAAK,CAACV,cAAN,CAAqBE,OAArB,iCACKQ,KAAK,CAACV,cAAN,CAAqBE,OAArB,CADL,MAEEC,GAAG,CAAHA,GAFF,CAGEL,aAAa,CAAbA,aAHF,CAIE6B,iBAAiB,CAAEpC,wBAAwB,CAACqC,OAJ9C,GAMD,CAPD,IAOO,CACLlB,KAAK,CAACV,cAAN,CAAqBE,OAArB,EAAgC,CAC9BG,QAAQ,CAAE,IADoB,CAE9BF,GAAG,CAAHA,GAF8B,CAG9BL,aAAa,CAAbA,aAH8B,CAI9B2B,mBAAmB,CAAElC,wBAAwB,CAACwC,WAJhB,CAK9BJ,iBAAiB,CAAEpC,wBAAwB,CAACqC,OALd,CAAhC,CAOD,CACF,CAnBD,EAoBAR,OAAO,CAACC,OAAR,CAAgBpB,kBAAkB,CAAC6B,QAAnC,CAA6C,SAACpB,KAAD,CAAQE,MAAR,CAAmB,CAC9D,GAAMV,CAAAA,OAAO,CAAGU,MAAM,CAACW,IAAP,CAAYC,GAA5B,CAEA,GAAId,KAAK,CAACV,cAAN,CAAqBE,OAArB,CAAJ,CAAmC,CACjCQ,KAAK,CAACV,cAAN,CAAqBE,OAArB,iCACKQ,KAAK,CAACV,cAAN,CAAqBE,OAArB,CADL,MAEEC,GAAG,CAAE,IAFP,CAGEL,aAAa,CAAE,KAHjB,CAIE6B,iBAAiB,CAAEpC,wBAAwB,CAACqC,OAJ9C,GAMD,CAPD,IAOO,CACLlB,KAAK,CAACV,cAAN,CAAqBE,OAArB,EAAgC,CAC9BG,QAAQ,CAAE,IADoB,CAE9BF,GAAG,CAAE,IAFyB,CAG9BL,aAAa,CAAE,KAHe,CAI9B2B,mBAAmB,CAAElC,wBAAwB,CAACwC,WAJhB,CAK9BJ,iBAAiB,CAAEpC,wBAAwB,CAACqC,OALd,CAAhC,CAOD,CACF,CAnBD,EAoBD,CAhJqC,CAAD,CAAhC,CAmJP;AACO,0BACLtB,YAAY,CAAC0B,OADR,CAAQvB,iBAAR,uBAAQA,iBAAR,CAA2BE,qBAA3B,uBAA2BA,qBAA3B,CAAkDI,kBAAlD,uBAAkDA,kBAAlD,CAAsEC,YAAtE,uBAAsEA,YAAtE,CAAoFC,SAApF,uBAAoFA,SAApF,CAGP;AACA;0FACA,MAAO,IAAMgB,CAAAA,YAAY,CAAG,QAAfA,CAAAA,YAAe,CAACC,OAAD,kGAAqB,kBAAOC,QAAP,oJAE7CA,QAAQ,CAAC1B,iBAAiB,EAAlB,CAAR,CAF6C,uBAGtBjB,CAAAA,UAAU,CAAC0C,OAAD,CAHY,QAGvCE,QAHuC,gBAI7CD,QAAQ,CAACxB,qBAAqB,CAACyB,QAAD,CAAtB,CAAR,CAJ6C,mFAM7CC,OAAO,CAACC,KAAR,eACAH,QAAQ,CAACpB,kBAAkB,EAAnB,CAAR,CAP6C,sEAArB,kEAArB,CAWP,cAAeT,CAAAA,YAAY,CAACiC,OAA5B","sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport { ProfileState, ProfileAvatarFetchStatus } from 'state/types'\nimport type { AppDispatch } from 'state'\nimport { NftToken } from 'state/nftMarket/types'\nimport { getProfile, getProfileAvatar, GetProfileResponse, getUsername } from './helpers'\n\nconst initialState: ProfileState = {\n  isInitialized: false,\n  isLoading: true,\n  hasRegistered: false,\n  data: null,\n  profileAvatars: {},\n}\n\nexport const fetchProfileAvatar = createAsyncThunk<{ account: string; nft: NftToken; hasRegistered: boolean }, string>(\n  'profile/fetchProfileAvatar',\n  async (account) => {\n    const { nft, hasRegistered } = await getProfileAvatar(account)\n    return { account, nft, hasRegistered }\n  },\n)\n\nexport const fetchProfileUsername = createAsyncThunk<\n  { account: string; username: string },\n  { account: string; hasRegistered: boolean }\n>('profile/fetchProfileUsername', async ({ account, hasRegistered }) => {\n  if (!hasRegistered) {\n    return { account, username: '' }\n  }\n  const username = await getUsername(account)\n  return { account, username }\n})\n\nexport const profileSlice = createSlice({\n  name: 'profile',\n  initialState,\n  reducers: {\n    profileFetchStart: (state) => {\n      state.isLoading = true\n    },\n    profileFetchSucceeded: (state, action: PayloadAction<GetProfileResponse>) => {\n      const { profile, hasRegistered } = action.payload\n\n      state.isInitialized = true\n      state.isLoading = false\n      state.hasRegistered = hasRegistered\n      state.data = profile\n    },\n    profileFetchFailed: (state) => {\n      state.isLoading = false\n      state.isInitialized = true\n    },\n    profileClear: () => ({\n      ...initialState,\n      isLoading: false,\n    }),\n    addPoints: (state, action: PayloadAction<number>) => {\n      state.data.points += action.payload\n    },\n  },\n  extraReducers: (builder) => {\n    builder.addCase(fetchProfileUsername.pending, (state, action) => {\n      const { account } = action.meta.arg\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = {\n          ...state.profileAvatars[account],\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHING,\n        }\n      } else {\n        state.profileAvatars[account] = {\n          hasRegistered: false,\n          username: null,\n          nft: null,\n          // I think in theory this else should never be reached since we only check for username after we checked for profile/avatar\n          // just in case I set isFetchingAvatar will be ProfileAvatarFetchStatus.FETCHED at this point to avoid refetching\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHING,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      }\n    })\n    builder.addCase(fetchProfileUsername.fulfilled, (state, action) => {\n      const { account, username } = action.payload\n\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = {\n          ...state.profileAvatars[account],\n          username,\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      } else {\n        state.profileAvatars[account] = {\n          username,\n          nft: null,\n          hasRegistered: true,\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n          // I think in theory this else should never be reached since we only check for username after we checked for profile/avatar\n          // just in case I set isFetchingAvatar will be ProfileAvatarFetchStatus.FETCHED at this point to avoid refetching\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      }\n    })\n    builder.addCase(fetchProfileUsername.rejected, (state, action) => {\n      const { account } = action.meta.arg\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = {\n          ...state.profileAvatars[account],\n          username: '',\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      } else {\n        state.profileAvatars[account] = {\n          hasRegistered: false,\n          username: '',\n          nft: null,\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      }\n    })\n    builder.addCase(fetchProfileAvatar.pending, (state, action) => {\n      const account = action.meta.arg\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = {\n          ...state.profileAvatars[account],\n          hasRegistered: false,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHING,\n        }\n      } else {\n        state.profileAvatars[account] = {\n          username: null,\n          nft: null,\n          hasRegistered: false,\n          usernameFetchStatus: ProfileAvatarFetchStatus.NOT_FETCHED,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHING,\n        }\n      }\n    })\n    builder.addCase(fetchProfileAvatar.fulfilled, (state, action) => {\n      const { account, nft, hasRegistered } = action.payload\n\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = {\n          ...state.profileAvatars[account],\n          nft,\n          hasRegistered,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      } else {\n        state.profileAvatars[account] = {\n          username: null,\n          nft,\n          hasRegistered,\n          usernameFetchStatus: ProfileAvatarFetchStatus.NOT_FETCHED,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      }\n    })\n    builder.addCase(fetchProfileAvatar.rejected, (state, action) => {\n      const account = action.meta.arg\n\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = {\n          ...state.profileAvatars[account],\n          nft: null,\n          hasRegistered: false,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      } else {\n        state.profileAvatars[account] = {\n          username: null,\n          nft: null,\n          hasRegistered: false,\n          usernameFetchStatus: ProfileAvatarFetchStatus.NOT_FETCHED,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      }\n    })\n  },\n})\n\n// Actions\nexport const { profileFetchStart, profileFetchSucceeded, profileFetchFailed, profileClear, addPoints } =\n  profileSlice.actions\n\n// Thunks\n// TODO: this should be an AsyncThunk\nexport const fetchProfile = (address: string) => async (dispatch: AppDispatch) => {\n  try {\n    dispatch(profileFetchStart())\n    const response = await getProfile(address)\n    dispatch(profileFetchSucceeded(response))\n  } catch (e) {\n    console.error(e)\n    dispatch(profileFetchFailed())\n  }\n}\n\nexport default profileSlice.reducer\n"]},"metadata":{},"sourceType":"module"}