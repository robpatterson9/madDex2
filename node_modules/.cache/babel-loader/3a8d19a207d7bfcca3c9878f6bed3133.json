{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { useEffect, useState } from 'react';\nimport { getNftsMarketData } from 'state/nftMarket/helpers';\nimport { pancakeBunniesAddress } from '../constants';\n\nconst getBunnyIdFromNft = nft => {\n  var _nft$attributes, _nft$attributes$find;\n\n  const bunnyId = (_nft$attributes = nft.attributes) === null || _nft$attributes === void 0 ? void 0 : (_nft$attributes$find = _nft$attributes.find(attr => attr.traitType === 'bunnyId')) === null || _nft$attributes$find === void 0 ? void 0 : _nft$attributes$find.value;\n  return bunnyId ? bunnyId.toString() : null;\n};\n\nexport const useGetLowestPriceFromBunnyId = bunnyId => {\n  _s();\n\n  const [isFetching, setIsFetching] = useState(false);\n  const [lowestPrice, setLowestPrice] = useState(null);\n  useEffect(() => {\n    const fetchLowestPrice = async () => {\n      try {\n        setIsFetching(true);\n        const response = await getNftsMarketData({\n          otherId: bunnyId,\n          isTradable: true\n        }, 1, 'currentAskPrice', 'asc');\n\n        if (response.length > 0) {\n          const [tokenMarketData] = response;\n          setLowestPrice(parseFloat(tokenMarketData.currentAskPrice));\n        }\n      } finally {\n        setIsFetching(false);\n      }\n    };\n\n    if (bunnyId) {\n      fetchLowestPrice();\n    }\n  }, [bunnyId]);\n  return {\n    isFetching,\n    lowestPrice\n  };\n};\n\n_s(useGetLowestPriceFromBunnyId, \"aO5FG6wOntatL5XQYfrlLyq/HCI=\");\n\nexport const useGetLowestPriceFromNft = nft => {\n  _s2();\n\n  var _nft$collectionAddres;\n\n  const [isFetching, setIsFetching] = useState(false);\n  const [lowestPrice, setLowestPrice] = useState(null);\n  const isPancakeBunny = ((_nft$collectionAddres = nft.collectionAddress) === null || _nft$collectionAddres === void 0 ? void 0 : _nft$collectionAddres.toLowerCase()) === pancakeBunniesAddress.toLowerCase();\n  useEffect(() => {\n    const fetchLowestPrice = async () => {\n      const bunnyIdAttr = getBunnyIdFromNft(nft);\n\n      try {\n        setIsFetching(true);\n        const response = await getNftsMarketData({\n          otherId: bunnyIdAttr,\n          isTradable: true\n        }, 1, 'currentAskPrice', 'asc');\n\n        if (response.length > 0) {\n          const [tokenMarketData] = response;\n          setLowestPrice(parseFloat(tokenMarketData.currentAskPrice));\n        }\n      } finally {\n        setIsFetching(false);\n      }\n    };\n\n    if (isPancakeBunny && nft) {\n      fetchLowestPrice();\n    }\n  }, [isPancakeBunny, nft]);\n  return {\n    isFetching,\n    lowestPrice\n  };\n};\n\n_s2(useGetLowestPriceFromNft, \"aO5FG6wOntatL5XQYfrlLyq/HCI=\");","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/views/Nft/market/hooks/useGetLowestPrice.ts"],"names":["useEffect","useState","getNftsMarketData","pancakeBunniesAddress","getBunnyIdFromNft","nft","bunnyId","attributes","find","attr","traitType","value","toString","useGetLowestPriceFromBunnyId","isFetching","setIsFetching","lowestPrice","setLowestPrice","fetchLowestPrice","response","otherId","isTradable","length","tokenMarketData","parseFloat","currentAskPrice","useGetLowestPriceFromNft","isPancakeBunny","collectionAddress","toLowerCase","bunnyIdAttr"],"mappings":"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","sourcesContent":["import { useEffect, useState } from 'react'\nimport { getNftsMarketData } from 'state/nftMarket/helpers'\nimport { NftToken } from 'state/nftMarket/types'\nimport { pancakeBunniesAddress } from '../constants'\n\nexport interface LowestNftPrice {\n  isFetching: boolean\n  lowestPrice: number\n}\n\nconst getBunnyIdFromNft = (nft: NftToken): string => {\n  const bunnyId = nft.attributes?.find((attr) => attr.traitType === 'bunnyId')?.value\n  return bunnyId ? bunnyId.toString() : null\n}\n\nexport const useGetLowestPriceFromBunnyId = (bunnyId: string): LowestNftPrice => {\n  const [isFetching, setIsFetching] = useState<boolean>(false)\n  const [lowestPrice, setLowestPrice] = useState<number>(null)\n\n  useEffect(() => {\n    const fetchLowestPrice = async () => {\n      try {\n        setIsFetching(true)\n        const response = await getNftsMarketData({ otherId: bunnyId, isTradable: true }, 1, 'currentAskPrice', 'asc')\n\n        if (response.length > 0) {\n          const [tokenMarketData] = response\n          setLowestPrice(parseFloat(tokenMarketData.currentAskPrice))\n        }\n      } finally {\n        setIsFetching(false)\n      }\n    }\n\n    if (bunnyId) {\n      fetchLowestPrice()\n    }\n  }, [bunnyId])\n\n  return { isFetching, lowestPrice }\n}\n\nexport const useGetLowestPriceFromNft = (nft: NftToken): LowestNftPrice => {\n  const [isFetching, setIsFetching] = useState<boolean>(false)\n  const [lowestPrice, setLowestPrice] = useState<number>(null)\n  const isPancakeBunny = nft.collectionAddress?.toLowerCase() === pancakeBunniesAddress.toLowerCase()\n\n  useEffect(() => {\n    const fetchLowestPrice = async () => {\n      const bunnyIdAttr = getBunnyIdFromNft(nft)\n      try {\n        setIsFetching(true)\n        const response = await getNftsMarketData(\n          { otherId: bunnyIdAttr, isTradable: true },\n          1,\n          'currentAskPrice',\n          'asc',\n        )\n\n        if (response.length > 0) {\n          const [tokenMarketData] = response\n          setLowestPrice(parseFloat(tokenMarketData.currentAskPrice))\n        }\n      } finally {\n        setIsFetching(false)\n      }\n    }\n\n    if (isPancakeBunny && nft) {\n      fetchLowestPrice()\n    }\n  }, [isPancakeBunny, nft])\n\n  return { isFetching, lowestPrice }\n}\n"]},"metadata":{},"sourceType":"module"}