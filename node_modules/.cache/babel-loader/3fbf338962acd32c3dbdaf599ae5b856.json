{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { useEffect, useMemo } from 'react';\nimport useFetchProtocolData from 'state/info/queries/protocol/overview';\nimport useFetchGlobalChartData from 'state/info/queries/protocol/chart';\nimport fetchTopTransactions from 'state/info/queries/protocol/transactions';\nimport useTopPoolAddresses from 'state/info/queries/pools/topPools';\nimport usePoolDatas from 'state/info/queries/pools/poolData';\nimport useFetchedTokenDatas from 'state/info/queries/tokens/tokenData';\nimport useTopTokenAddresses from 'state/info/queries/tokens/topTokens';\nimport { useProtocolData, useProtocolChartData, useProtocolTransactions, useUpdatePoolData, useAllPoolData, useAddPoolKeys, useAllTokenData, useUpdateTokenData, useAddTokenKeys } from './hooks';\nexport const ProtocolUpdater = () => {\n  _s();\n\n  const [protocolData, setProtocolData] = useProtocolData();\n  const {\n    data: fetchedProtocolData,\n    error\n  } = useFetchProtocolData();\n  const [chartData, updateChartData] = useProtocolChartData();\n  const {\n    data: fetchedChartData,\n    error: chartError\n  } = useFetchGlobalChartData();\n  const [transactions, updateTransactions] = useProtocolTransactions(); // update overview data if available and not set\n\n  useEffect(() => {\n    if (protocolData === undefined && fetchedProtocolData && !error) {\n      setProtocolData(fetchedProtocolData);\n    }\n  }, [error, fetchedProtocolData, protocolData, setProtocolData]); // update global chart data if available and not set\n\n  useEffect(() => {\n    if (chartData === undefined && fetchedChartData && !chartError) {\n      updateChartData(fetchedChartData);\n    }\n  }, [chartData, chartError, fetchedChartData, updateChartData]);\n  useEffect(() => {\n    const fetch = async () => {\n      const data = await fetchTopTransactions();\n\n      if (data) {\n        updateTransactions(data);\n      }\n    };\n\n    if (!transactions) {\n      fetch();\n    }\n  }, [transactions, updateTransactions]);\n  return null;\n};\n\n_s(ProtocolUpdater, \"iotW+MeGjeGfNm8/taLut7gXrmI=\", false, function () {\n  return [useProtocolData, useFetchProtocolData, useProtocolChartData, useFetchGlobalChartData, useProtocolTransactions];\n});\n\n_c = ProtocolUpdater;\nexport const PoolUpdater = () => {\n  _s2();\n\n  const updatePoolData = useUpdatePoolData();\n  const addPoolKeys = useAddPoolKeys();\n  const allPoolData = useAllPoolData();\n  const addresses = useTopPoolAddresses(); // add top pools on first load\n\n  useEffect(() => {\n    if (addresses.length > 0) {\n      addPoolKeys(addresses);\n    }\n  }, [addPoolKeys, addresses]); // detect for which addresses we havent loaded pool data yet\n\n  const unfetchedPoolAddresses = useMemo(() => {\n    return Object.keys(allPoolData).reduce((accum, address) => {\n      const poolData = allPoolData[address];\n\n      if (!poolData.data) {\n        accum.push(address);\n      }\n\n      return accum;\n    }, []);\n  }, [allPoolData]); // fetch data for unfetched pools and update them\n\n  const {\n    error: poolDataError,\n    data: poolDatas\n  } = usePoolDatas(unfetchedPoolAddresses);\n  useEffect(() => {\n    if (poolDatas && !poolDataError) {\n      updatePoolData(Object.values(poolDatas));\n    }\n  }, [poolDataError, poolDatas, updatePoolData]);\n  return null;\n};\n\n_s2(PoolUpdater, \"KHWJGUiH1uyq0mqNoyTMCYpJYAA=\", false, function () {\n  return [useUpdatePoolData, useAddPoolKeys, useAllPoolData, useTopPoolAddresses, usePoolDatas];\n});\n\n_c2 = PoolUpdater;\nexport const TokenUpdater = () => {\n  _s3();\n\n  const updateTokenDatas = useUpdateTokenData();\n  const addTokenKeys = useAddTokenKeys();\n  const allTokenData = useAllTokenData();\n  const addresses = useTopTokenAddresses(); // add top tokens on first load\n\n  useEffect(() => {\n    if (addresses.length > 0) {\n      addTokenKeys(addresses);\n    }\n  }, [addTokenKeys, addresses]); // detect for which addresses we havent loaded token data yet\n\n  const unfetchedTokenAddresses = useMemo(() => {\n    return Object.keys(allTokenData).reduce((accum, key) => {\n      const tokenData = allTokenData[key];\n\n      if (!tokenData.data) {\n        accum.push(key);\n      }\n\n      return accum;\n    }, []);\n  }, [allTokenData]); // fetch data for unfetched tokens and update them\n\n  const {\n    error: tokenDataError,\n    data: tokenDatas\n  } = useFetchedTokenDatas(unfetchedTokenAddresses);\n  useEffect(() => {\n    if (tokenDatas && !tokenDataError) {\n      updateTokenDatas(Object.values(tokenDatas));\n    }\n  }, [tokenDataError, tokenDatas, updateTokenDatas]);\n  return null;\n};\n\n_s3(TokenUpdater, \"4xWEJ5UsCXxX5INA1uvqPuK8wFM=\", false, function () {\n  return [useUpdateTokenData, useAddTokenKeys, useAllTokenData, useTopTokenAddresses, useFetchedTokenDatas];\n});\n\n_c3 = TokenUpdater;\n\nvar _c, _c2, _c3;\n\n$RefreshReg$(_c, \"ProtocolUpdater\");\n$RefreshReg$(_c2, \"PoolUpdater\");\n$RefreshReg$(_c3, \"TokenUpdater\");","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/info/updaters.ts"],"names":["useEffect","useMemo","useFetchProtocolData","useFetchGlobalChartData","fetchTopTransactions","useTopPoolAddresses","usePoolDatas","useFetchedTokenDatas","useTopTokenAddresses","useProtocolData","useProtocolChartData","useProtocolTransactions","useUpdatePoolData","useAllPoolData","useAddPoolKeys","useAllTokenData","useUpdateTokenData","useAddTokenKeys","ProtocolUpdater","protocolData","setProtocolData","data","fetchedProtocolData","error","chartData","updateChartData","fetchedChartData","chartError","transactions","updateTransactions","undefined","fetch","PoolUpdater","updatePoolData","addPoolKeys","allPoolData","addresses","length","unfetchedPoolAddresses","Object","keys","reduce","accum","address","poolData","push","poolDataError","poolDatas","values","TokenUpdater","updateTokenDatas","addTokenKeys","allTokenData","unfetchedTokenAddresses","key","tokenData","tokenDataError","tokenDatas"],"mappings":"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","sourcesContent":["import React, { useEffect, useMemo } from 'react'\nimport useFetchProtocolData from 'state/info/queries/protocol/overview'\nimport useFetchGlobalChartData from 'state/info/queries/protocol/chart'\nimport fetchTopTransactions from 'state/info/queries/protocol/transactions'\nimport useTopPoolAddresses from 'state/info/queries/pools/topPools'\nimport usePoolDatas from 'state/info/queries/pools/poolData'\nimport useFetchedTokenDatas from 'state/info/queries/tokens/tokenData'\nimport useTopTokenAddresses from 'state/info/queries/tokens/topTokens'\nimport {\n  useProtocolData,\n  useProtocolChartData,\n  useProtocolTransactions,\n  useUpdatePoolData,\n  useAllPoolData,\n  useAddPoolKeys,\n  useAllTokenData,\n  useUpdateTokenData,\n  useAddTokenKeys,\n} from './hooks'\n\nexport const ProtocolUpdater: React.FC = () => {\n  const [protocolData, setProtocolData] = useProtocolData()\n  const { data: fetchedProtocolData, error } = useFetchProtocolData()\n\n  const [chartData, updateChartData] = useProtocolChartData()\n  const { data: fetchedChartData, error: chartError } = useFetchGlobalChartData()\n\n  const [transactions, updateTransactions] = useProtocolTransactions()\n\n  // update overview data if available and not set\n  useEffect(() => {\n    if (protocolData === undefined && fetchedProtocolData && !error) {\n      setProtocolData(fetchedProtocolData)\n    }\n  }, [error, fetchedProtocolData, protocolData, setProtocolData])\n\n  // update global chart data if available and not set\n  useEffect(() => {\n    if (chartData === undefined && fetchedChartData && !chartError) {\n      updateChartData(fetchedChartData)\n    }\n  }, [chartData, chartError, fetchedChartData, updateChartData])\n\n  useEffect(() => {\n    const fetch = async () => {\n      const data = await fetchTopTransactions()\n      if (data) {\n        updateTransactions(data)\n      }\n    }\n    if (!transactions) {\n      fetch()\n    }\n  }, [transactions, updateTransactions])\n\n  return null\n}\n\nexport const PoolUpdater: React.FC = () => {\n  const updatePoolData = useUpdatePoolData()\n  const addPoolKeys = useAddPoolKeys()\n\n  const allPoolData = useAllPoolData()\n  const addresses = useTopPoolAddresses()\n\n  // add top pools on first load\n  useEffect(() => {\n    if (addresses.length > 0) {\n      addPoolKeys(addresses)\n    }\n  }, [addPoolKeys, addresses])\n\n  // detect for which addresses we havent loaded pool data yet\n  const unfetchedPoolAddresses = useMemo(() => {\n    return Object.keys(allPoolData).reduce((accum: string[], address) => {\n      const poolData = allPoolData[address]\n      if (!poolData.data) {\n        accum.push(address)\n      }\n      return accum\n    }, [])\n  }, [allPoolData])\n\n  // fetch data for unfetched pools and update them\n  const { error: poolDataError, data: poolDatas } = usePoolDatas(unfetchedPoolAddresses)\n  useEffect(() => {\n    if (poolDatas && !poolDataError) {\n      updatePoolData(Object.values(poolDatas))\n    }\n  }, [poolDataError, poolDatas, updatePoolData])\n\n  return null\n}\n\nexport const TokenUpdater = (): null => {\n  const updateTokenDatas = useUpdateTokenData()\n  const addTokenKeys = useAddTokenKeys()\n\n  const allTokenData = useAllTokenData()\n  const addresses = useTopTokenAddresses()\n\n  // add top tokens on first load\n  useEffect(() => {\n    if (addresses.length > 0) {\n      addTokenKeys(addresses)\n    }\n  }, [addTokenKeys, addresses])\n\n  // detect for which addresses we havent loaded token data yet\n  const unfetchedTokenAddresses = useMemo(() => {\n    return Object.keys(allTokenData).reduce((accum: string[], key) => {\n      const tokenData = allTokenData[key]\n      if (!tokenData.data) {\n        accum.push(key)\n      }\n      return accum\n    }, [])\n  }, [allTokenData])\n\n  // fetch data for unfetched tokens and update them\n  const { error: tokenDataError, data: tokenDatas } = useFetchedTokenDatas(unfetchedTokenAddresses)\n  useEffect(() => {\n    if (tokenDatas && !tokenDataError) {\n      updateTokenDatas(Object.values(tokenDatas))\n    }\n  }, [tokenDataError, tokenDatas, updateTokenDatas])\n\n  return null\n}\n"]},"metadata":{},"sourceType":"module"}