{"ast":null,"code":"import{useMemo}from'react';import{isAddress}from'../../utils';export function filterTokens(tokens,search){if(search.length===0)return tokens;var searchingAddress=isAddress(search);if(searchingAddress){return tokens.filter(function(token){return token.address===searchingAddress;});}var lowerSearchParts=search.toLowerCase().split(/\\s+/).filter(function(s){return s.length>0;});if(lowerSearchParts.length===0){return tokens;}var matchesSearch=function matchesSearch(s){var sParts=s.toLowerCase().split(/\\s+/).filter(function(s_){return s_.length>0;});return lowerSearchParts.every(function(p){return p.length===0||sParts.some(function(sp){return sp.startsWith(p)||sp.endsWith(p);});});};return tokens.filter(function(token){var symbol=token.symbol,name=token.name;return symbol&&matchesSearch(symbol)||name&&matchesSearch(name);});}export function useSortedTokensByQuery(tokens,searchQuery){return useMemo(function(){if(!tokens){return[];}var symbolMatch=searchQuery.toLowerCase().split(/\\s+/).filter(function(s){return s.length>0;});if(symbolMatch.length>1){return tokens;}var exactMatches=[];var symbolSubstrings=[];var rest=[];// sort tokens by exact match -> substring on symbol match -> rest\ntokens.map(function(token){var _token$symbol,_token$symbol2;if(((_token$symbol=token.symbol)===null||_token$symbol===void 0?void 0:_token$symbol.toLowerCase())===symbolMatch[0]){return exactMatches.push(token);}if((_token$symbol2=token.symbol)===null||_token$symbol2===void 0?void 0:_token$symbol2.toLowerCase().startsWith(searchQuery.toLowerCase().trim())){return symbolSubstrings.push(token);}return rest.push(token);});return[].concat(exactMatches,symbolSubstrings,rest);},[tokens,searchQuery]);}","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/components/SearchModal/filtering.ts"],"names":["useMemo","isAddress","filterTokens","tokens","search","length","searchingAddress","filter","token","address","lowerSearchParts","toLowerCase","split","s","matchesSearch","sParts","s_","every","p","some","sp","startsWith","endsWith","symbol","name","useSortedTokensByQuery","searchQuery","symbolMatch","exactMatches","symbolSubstrings","rest","map","push","trim"],"mappings":"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","sourcesContent":["import { useMemo } from 'react'\nimport { Token } from '@pancakeswap/sdk'\nimport { isAddress } from '../../utils'\n\nexport function filterTokens(tokens: Token[], search: string): Token[] {\n  if (search.length === 0) return tokens\n\n  const searchingAddress = isAddress(search)\n\n  if (searchingAddress) {\n    return tokens.filter((token) => token.address === searchingAddress)\n  }\n\n  const lowerSearchParts = search\n    .toLowerCase()\n    .split(/\\s+/)\n    .filter((s) => s.length > 0)\n\n  if (lowerSearchParts.length === 0) {\n    return tokens\n  }\n\n  const matchesSearch = (s: string): boolean => {\n    const sParts = s\n      .toLowerCase()\n      .split(/\\s+/)\n      .filter((s_) => s_.length > 0)\n\n    return lowerSearchParts.every((p) => p.length === 0 || sParts.some((sp) => sp.startsWith(p) || sp.endsWith(p)))\n  }\n\n  return tokens.filter((token) => {\n    const { symbol, name } = token\n    return (symbol && matchesSearch(symbol)) || (name && matchesSearch(name))\n  })\n}\n\nexport function useSortedTokensByQuery(tokens: Token[] | undefined, searchQuery: string): Token[] {\n  return useMemo(() => {\n    if (!tokens) {\n      return []\n    }\n\n    const symbolMatch = searchQuery\n      .toLowerCase()\n      .split(/\\s+/)\n      .filter((s) => s.length > 0)\n\n    if (symbolMatch.length > 1) {\n      return tokens\n    }\n\n    const exactMatches: Token[] = []\n    const symbolSubstrings: Token[] = []\n    const rest: Token[] = []\n\n    // sort tokens by exact match -> substring on symbol match -> rest\n    tokens.map((token) => {\n      if (token.symbol?.toLowerCase() === symbolMatch[0]) {\n        return exactMatches.push(token)\n      }\n      if (token.symbol?.toLowerCase().startsWith(searchQuery.toLowerCase().trim())) {\n        return symbolSubstrings.push(token)\n      }\n      return rest.push(token)\n    })\n\n    return [...exactMatches, ...symbolSubstrings, ...rest]\n  }, [tokens, searchQuery])\n}\n"]},"metadata":{},"sourceType":"module"}