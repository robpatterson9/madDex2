{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport { request, gql } from 'graphql-request';\nimport { INFO_CLIENT } from 'config/constants/endpoints';\nimport { useTokenDatas, usePoolDatas } from 'state/info/hooks';\nimport { MINIMUM_SEARCH_CHARACTERS } from 'config/constants/info';\nconst TOKEN_SEARCH = gql`\n  query tokens($symbol: String, $name: String, $id: String) {\n    asSymbol: tokens(first: 10, where: { symbol_contains: $symbol }, orderBy: tradeVolumeUSD, orderDirection: desc) {\n      id\n    }\n    asName: tokens(first: 10, where: { name_contains: $name }, orderBy: tradeVolumeUSD, orderDirection: desc) {\n      id\n    }\n    asAddress: tokens(first: 1, where: { id: $id }, orderBy: tradeVolumeUSD, orderDirection: desc) {\n      id\n    }\n  }\n`;\nconst POOL_SEARCH = gql`\n  query pools($tokens: [Bytes]!, $id: String) {\n    as0: pairs(first: 10, where: { token0_in: $tokens }) {\n      id\n    }\n    as1: pairs(first: 10, where: { token1_in: $tokens }) {\n      id\n    }\n    asAddress: pairs(first: 1, where: { id: $id }) {\n      id\n    }\n  }\n`;\n\nconst getIds = entityArrays => {\n  const ids = entityArrays.reduce((entities, currentTokenArray) => [...entities, ...currentTokenArray], []).map(entity => entity.id);\n  return Array.from(new Set(ids));\n};\n\nconst useFetchSearchResults = searchString => {\n  _s();\n\n  const [searchResults, setSearchResults] = useState({\n    tokens: [],\n    // Token ids found by search query\n    pools: [],\n    // Pool ids found by search query\n    loading: false,\n    // Search query is in progress\n    error: false // GraphQL returned error\n\n  });\n  const searchStringTooShort = searchString.length < MINIMUM_SEARCH_CHARACTERS; // New value received, reset state\n\n  useEffect(() => {\n    setSearchResults({\n      tokens: [],\n      pools: [],\n      loading: !searchStringTooShort,\n      error: false\n    });\n  }, [searchString, searchStringTooShort]);\n  useEffect(() => {\n    const search = async () => {\n      try {\n        const tokens = await request(INFO_CLIENT, TOKEN_SEARCH, {\n          symbol: searchString.toUpperCase(),\n          // Most well known tokens have first letter capitalized\n          name: searchString.charAt(0).toUpperCase() + searchString.slice(1),\n          id: searchString.toLowerCase()\n        });\n        const tokenIds = getIds([tokens.asAddress, tokens.asSymbol, tokens.asName]);\n        const pools = await request(INFO_CLIENT, POOL_SEARCH, {\n          tokens: tokenIds,\n          id: searchString.toLowerCase()\n        });\n        setSearchResults({\n          tokens: tokenIds,\n          pools: getIds([pools.asAddress, pools.as0, pools.as1]),\n          loading: false,\n          error: false\n        });\n      } catch (error) {\n        console.error(`Search failed for ${searchString}`, error);\n        setSearchResults({\n          tokens: [],\n          pools: [],\n          loading: false,\n          error: true\n        });\n      }\n    };\n\n    if (!searchStringTooShort) {\n      search();\n    }\n  }, [searchString, searchStringTooShort]); // Save ids to Redux\n  // Token and Pool updater will then go fetch full data for these addresses\n  // These hooks in turn will return data of tokens that have been fetched\n\n  const tokenDatasFull = useTokenDatas(searchResults.tokens);\n  const poolDatasFull = usePoolDatas(searchResults.pools); // If above hooks returned not all tokens/pools it means\n  // that some requests for full data are in progress\n\n  const tokensLoading = tokenDatasFull.length !== searchResults.tokens.length || searchResults.loading;\n  const poolsLoading = poolDatasFull.length !== searchResults.pools.length || searchResults.loading;\n  return {\n    tokens: tokenDatasFull,\n    pools: poolDatasFull,\n    tokensLoading,\n    poolsLoading,\n    error: searchResults.error\n  };\n};\n\n_s(useFetchSearchResults, \"tj3nITV3glQ1qDhDQ3PZLuXjYl0=\", false, function () {\n  return [useTokenDatas, usePoolDatas];\n});\n\nexport default useFetchSearchResults;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/info/queries/search/index.ts"],"names":["useState","useEffect","request","gql","INFO_CLIENT","useTokenDatas","usePoolDatas","MINIMUM_SEARCH_CHARACTERS","TOKEN_SEARCH","POOL_SEARCH","getIds","entityArrays","ids","reduce","entities","currentTokenArray","map","entity","id","Array","from","Set","useFetchSearchResults","searchString","searchResults","setSearchResults","tokens","pools","loading","error","searchStringTooShort","length","search","symbol","toUpperCase","name","charAt","slice","toLowerCase","tokenIds","asAddress","asSymbol","asName","as0","as1","console","tokenDatasFull","poolDatasFull","tokensLoading","poolsLoading"],"mappings":"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","sourcesContent":["import { useState, useEffect } from 'react'\nimport { request, gql } from 'graphql-request'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\nimport { useTokenDatas, usePoolDatas } from 'state/info/hooks'\nimport { TokenData, PoolData } from 'state/info/types'\nimport { MINIMUM_SEARCH_CHARACTERS } from 'config/constants/info'\n\nconst TOKEN_SEARCH = gql`\n  query tokens($symbol: String, $name: String, $id: String) {\n    asSymbol: tokens(first: 10, where: { symbol_contains: $symbol }, orderBy: tradeVolumeUSD, orderDirection: desc) {\n      id\n    }\n    asName: tokens(first: 10, where: { name_contains: $name }, orderBy: tradeVolumeUSD, orderDirection: desc) {\n      id\n    }\n    asAddress: tokens(first: 1, where: { id: $id }, orderBy: tradeVolumeUSD, orderDirection: desc) {\n      id\n    }\n  }\n`\n\nconst POOL_SEARCH = gql`\n  query pools($tokens: [Bytes]!, $id: String) {\n    as0: pairs(first: 10, where: { token0_in: $tokens }) {\n      id\n    }\n    as1: pairs(first: 10, where: { token1_in: $tokens }) {\n      id\n    }\n    asAddress: pairs(first: 1, where: { id: $id }) {\n      id\n    }\n  }\n`\n\ninterface SingleQueryResponse {\n  id: string[]\n}\n\ninterface TokenSearchResponse {\n  asSymbol: SingleQueryResponse[]\n  asName: SingleQueryResponse[]\n  asAddress: SingleQueryResponse[]\n}\ninterface PoolSearchResponse {\n  as0: SingleQueryResponse[]\n  as1: SingleQueryResponse[]\n  asAddress: SingleQueryResponse[]\n}\n\nconst getIds = (entityArrays: SingleQueryResponse[][]) => {\n  const ids = entityArrays\n    .reduce((entities, currentTokenArray) => [...entities, ...currentTokenArray], [])\n    .map((entity) => entity.id)\n  return Array.from(new Set(ids))\n}\n\nconst useFetchSearchResults = (\n  searchString: string,\n): {\n  tokens: TokenData[]\n  pools: PoolData[]\n  tokensLoading: boolean\n  poolsLoading: boolean\n  error: boolean\n} => {\n  const [searchResults, setSearchResults] = useState({\n    tokens: [], // Token ids found by search query\n    pools: [], // Pool ids found by search query\n    loading: false, // Search query is in progress\n    error: false, // GraphQL returned error\n  })\n\n  const searchStringTooShort = searchString.length < MINIMUM_SEARCH_CHARACTERS\n\n  // New value received, reset state\n  useEffect(() => {\n    setSearchResults({\n      tokens: [],\n      pools: [],\n      loading: !searchStringTooShort,\n      error: false,\n    })\n  }, [searchString, searchStringTooShort])\n\n  useEffect(() => {\n    const search = async () => {\n      try {\n        const tokens = await request<TokenSearchResponse>(INFO_CLIENT, TOKEN_SEARCH, {\n          symbol: searchString.toUpperCase(),\n          // Most well known tokens have first letter capitalized\n          name: searchString.charAt(0).toUpperCase() + searchString.slice(1),\n          id: searchString.toLowerCase(),\n        })\n        const tokenIds = getIds([tokens.asAddress, tokens.asSymbol, tokens.asName])\n        const pools = await request<PoolSearchResponse>(INFO_CLIENT, POOL_SEARCH, {\n          tokens: tokenIds,\n          id: searchString.toLowerCase(),\n        })\n        setSearchResults({\n          tokens: tokenIds,\n          pools: getIds([pools.asAddress, pools.as0, pools.as1]),\n          loading: false,\n          error: false,\n        })\n      } catch (error) {\n        console.error(`Search failed for ${searchString}`, error)\n        setSearchResults({\n          tokens: [],\n          pools: [],\n          loading: false,\n          error: true,\n        })\n      }\n    }\n    if (!searchStringTooShort) {\n      search()\n    }\n  }, [searchString, searchStringTooShort])\n\n  // Save ids to Redux\n  // Token and Pool updater will then go fetch full data for these addresses\n  // These hooks in turn will return data of tokens that have been fetched\n  const tokenDatasFull = useTokenDatas(searchResults.tokens)\n  const poolDatasFull = usePoolDatas(searchResults.pools)\n\n  // If above hooks returned not all tokens/pools it means\n  // that some requests for full data are in progress\n  const tokensLoading = tokenDatasFull.length !== searchResults.tokens.length || searchResults.loading\n  const poolsLoading = poolDatasFull.length !== searchResults.pools.length || searchResults.loading\n\n  return {\n    tokens: tokenDatasFull,\n    pools: poolDatasFull,\n    tokensLoading,\n    poolsLoading,\n    error: searchResults.error,\n  }\n}\n\nexport default useFetchSearchResults\n"]},"metadata":{},"sourceType":"module"}