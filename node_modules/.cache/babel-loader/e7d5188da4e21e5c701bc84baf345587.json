{"ast":null,"code":"import _slicedToArray from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _regeneratorRuntime from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{ethers}from'ethers';import{getMulticallContract}from'utils/contractHelpers';var multicall=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(abi,calls){var multi,itf,calldata,_yield$multi$aggregat,returnData,res;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.prev=0;multi=getMulticallContract();itf=new ethers.utils.Interface(abi);calldata=calls.map(function(call){return[call.address.toLowerCase(),itf.encodeFunctionData(call.name,call.params)];});_context.next=6;return multi.aggregate(calldata);case 6:_yield$multi$aggregat=_context.sent;returnData=_yield$multi$aggregat.returnData;res=returnData.map(function(call,i){return itf.decodeFunctionResult(calls[i].name,call);});return _context.abrupt(\"return\",res);case 12:_context.prev=12;_context.t0=_context[\"catch\"](0);throw new Error(_context.t0);case 15:case\"end\":return _context.stop();}}},_callee,null,[[0,12]]);}));return function multicall(_x,_x2){return _ref.apply(this,arguments);};}();/**\n * Multicall V2 uses the new \"tryAggregate\" function. It is different in 2 ways\n *\n * 1. If \"requireSuccess\" is false multicall will not bail out if one of the calls fails\n * 2. The return includes a boolean whether the call was successful e.g. [wasSuccessful, callResult]\n */export var multicallv2=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(abi,calls){var options,requireSuccess,multi,itf,calldata,returnData,res,_args2=arguments;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:options=_args2.length>2&&_args2[2]!==undefined?_args2[2]:{requireSuccess:true};requireSuccess=options.requireSuccess;multi=getMulticallContract();itf=new ethers.utils.Interface(abi);calldata=calls.map(function(call){return[call.address.toLowerCase(),itf.encodeFunctionData(call.name,call.params)];});_context2.next=7;return multi.tryAggregate(requireSuccess,calldata);case 7:returnData=_context2.sent;res=returnData.map(function(call,i){var _call=_slicedToArray(call,2),result=_call[0],data=_call[1];return result?itf.decodeFunctionResult(calls[i].name,data):null;});return _context2.abrupt(\"return\",res);case 10:case\"end\":return _context2.stop();}}},_callee2);}));return function multicallv2(_x3,_x4){return _ref2.apply(this,arguments);};}();export default multicall;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/utils/multicall.ts"],"names":["ethers","getMulticallContract","multicall","abi","calls","multi","itf","utils","Interface","calldata","map","call","address","toLowerCase","encodeFunctionData","name","params","aggregate","returnData","res","i","decodeFunctionResult","Error","multicallv2","options","requireSuccess","tryAggregate","result","data"],"mappings":"qcAAA,OAASA,MAAT,KAAuB,QAAvB,CACA,OAASC,oBAAT,KAAqC,uBAArC,CAaA,GAAMC,CAAAA,SAAS,0FAAG,iBAAgBC,GAAhB,CAA4BC,KAA5B,8LAERC,KAFQ,CAEAJ,oBAAoB,EAFpB,CAGRK,GAHQ,CAGF,GAAIN,CAAAA,MAAM,CAACO,KAAP,CAAaC,SAAjB,CAA2BL,GAA3B,CAHE,CAKRM,QALQ,CAKGL,KAAK,CAACM,GAAN,CAAU,SAACC,IAAD,QAAU,CAACA,IAAI,CAACC,OAAL,CAAaC,WAAb,EAAD,CAA6BP,GAAG,CAACQ,kBAAJ,CAAuBH,IAAI,CAACI,IAA5B,CAAkCJ,IAAI,CAACK,MAAvC,CAA7B,CAAV,EAAV,CALH,uBAMeX,CAAAA,KAAK,CAACY,SAAN,CAAgBR,QAAhB,CANf,4CAMNS,UANM,uBAMNA,UANM,CAQRC,GARQ,CAQFD,UAAU,CAACR,GAAX,CAAe,SAACC,IAAD,CAAOS,CAAP,QAAad,CAAAA,GAAG,CAACe,oBAAJ,CAAyBjB,KAAK,CAACgB,CAAD,CAAL,CAASL,IAAlC,CAAwCJ,IAAxC,CAAb,EAAf,CARE,iCAUPQ,GAVO,iEAYR,IAAIG,CAAAA,KAAJ,aAZQ,sEAAH,kBAATpB,CAAAA,SAAS,gDAAf,CAgBA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,IAAMqB,CAAAA,WAAW,2FAAG,kBACzBpB,GADyB,CAEzBC,KAFyB,oMAGzBoB,OAHyB,kDAGG,CAAEC,cAAc,CAAE,IAAlB,CAHH,CAKjBA,cALiB,CAKED,OALF,CAKjBC,cALiB,CAMnBpB,KANmB,CAMXJ,oBAAoB,EANT,CAOnBK,GAPmB,CAOb,GAAIN,CAAAA,MAAM,CAACO,KAAP,CAAaC,SAAjB,CAA2BL,GAA3B,CAPa,CASnBM,QATmB,CASRL,KAAK,CAACM,GAAN,CAAU,SAACC,IAAD,QAAU,CAACA,IAAI,CAACC,OAAL,CAAaC,WAAb,EAAD,CAA6BP,GAAG,CAACQ,kBAAJ,CAAuBH,IAAI,CAACI,IAA5B,CAAkCJ,IAAI,CAACK,MAAvC,CAA7B,CAAV,EAAV,CATQ,wBAUAX,CAAAA,KAAK,CAACqB,YAAN,CAAmBD,cAAnB,CAAmChB,QAAnC,CAVA,QAUnBS,UAVmB,gBAWnBC,GAXmB,CAWbD,UAAU,CAACR,GAAX,CAAe,SAACC,IAAD,CAAOS,CAAP,CAAa,CACtC,yBAAuBT,IAAvB,IAAOgB,MAAP,UAAeC,IAAf,UACA,MAAOD,CAAAA,MAAM,CAAGrB,GAAG,CAACe,oBAAJ,CAAyBjB,KAAK,CAACgB,CAAD,CAAL,CAASL,IAAlC,CAAwCa,IAAxC,CAAH,CAAmD,IAAhE,CACD,CAHW,CAXa,kCAgBlBT,GAhBkB,2DAAH,kBAAXI,CAAAA,WAAW,kDAAjB,CAmBP,cAAerB,CAAAA,SAAf","sourcesContent":["import { ethers } from 'ethers'\nimport { getMulticallContract } from 'utils/contractHelpers'\nimport { MultiCallResponse } from './types'\n\nexport interface Call {\n  address: string // Address of the contract\n  name: string // Function name on the contract (example: balanceOf)\n  params?: any[] // Function params\n}\n\ninterface MulticallOptions {\n  requireSuccess?: boolean\n}\n\nconst multicall = async <T = any>(abi: any[], calls: Call[]): Promise<T> => {\n  try {\n    const multi = getMulticallContract()\n    const itf = new ethers.utils.Interface(abi)\n\n    const calldata = calls.map((call) => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)])\n    const { returnData } = await multi.aggregate(calldata)\n\n    const res = returnData.map((call, i) => itf.decodeFunctionResult(calls[i].name, call))\n\n    return res\n  } catch (error) {\n    throw new Error(error)\n  }\n}\n\n/**\n * Multicall V2 uses the new \"tryAggregate\" function. It is different in 2 ways\n *\n * 1. If \"requireSuccess\" is false multicall will not bail out if one of the calls fails\n * 2. The return includes a boolean whether the call was successful e.g. [wasSuccessful, callResult]\n */\nexport const multicallv2 = async <T = any>(\n  abi: any[],\n  calls: Call[],\n  options: MulticallOptions = { requireSuccess: true },\n): Promise<MultiCallResponse<T>> => {\n  const { requireSuccess } = options\n  const multi = getMulticallContract()\n  const itf = new ethers.utils.Interface(abi)\n\n  const calldata = calls.map((call) => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)])\n  const returnData = await multi.tryAggregate(requireSuccess, calldata)\n  const res = returnData.map((call, i) => {\n    const [result, data] = call\n    return result ? itf.decodeFunctionResult(calls[i].name, data) : null\n  })\n\n  return res\n}\n\nexport default multicall\n"]},"metadata":{},"sourceType":"module"}