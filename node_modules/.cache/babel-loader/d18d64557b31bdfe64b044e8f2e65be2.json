{"ast":null,"code":"import _toConsumableArray from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _defineProperty from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _regeneratorRuntime from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _slicedToArray from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _asyncToGenerator from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{createSlice,createAsyncThunk}from'@reduxjs/toolkit';import{pancakeBunniesAddress}from'views/Nft/market/constants';import{getNftsFromCollectionApi,getNftsFromCollectionSg,getNftsMarketData,getCollectionsApi,getCollectionsSg,getUserActivity,combineCollectionData,getCollectionSg,getCollectionApi,getNftsFromDifferentCollectionsApi,getCompleteAccountNftData,getNftsByBunnyIdSg,getMarketDataForTokenIds}from'./helpers';import{NFTMarketInitializationState,UserNftInitializationState,NftLocation}from'./types';var initialState={initializationState:NFTMarketInitializationState.UNINITIALIZED,data:{collections:{},nfts:{},isFetchingMoreNfts:false,latestFetchAt:0,lastUpdateAt:Date.now(),users:{},user:{userNftsInitializationState:UserNftInitializationState.UNINITIALIZED,nfts:[],activity:{initializationState:UserNftInitializationState.UNINITIALIZED,askOrderHistory:[],buyTradeHistory:[],sellTradeHistory:[]}}}};/**\n * Fetch all collections data by combining data from the API (static metadata) and the Subgraph (dynamic market data)\n */export var fetchCollections=createAsyncThunk('nft/fetchCollections',/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var _yield$Promise$all,_yield$Promise$all2,collections,collectionsMarket;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return Promise.all([getCollectionsApi(),getCollectionsSg()]);case 2:_yield$Promise$all=_context.sent;_yield$Promise$all2=_slicedToArray(_yield$Promise$all,2);collections=_yield$Promise$all2[0];collectionsMarket=_yield$Promise$all2[1];return _context.abrupt(\"return\",combineCollectionData(collections,collectionsMarket));case 7:case\"end\":return _context.stop();}}},_callee);})));/**\n * Fetch collection data by combining data from the API (static metadata) and the Subgraph (dynamic market data)\n */export var fetchCollection=createAsyncThunk('nft/fetchCollection',/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(collectionAddress){var _yield$Promise$all3,_yield$Promise$all4,collection,collectionMarket;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return Promise.all([getCollectionApi(collectionAddress),getCollectionSg(collectionAddress)]);case 2:_yield$Promise$all3=_context2.sent;_yield$Promise$all4=_slicedToArray(_yield$Promise$all3,2);collection=_yield$Promise$all4[0];collectionMarket=_yield$Promise$all4[1];return _context2.abrupt(\"return\",combineCollectionData([collection],[collectionMarket]));case 7:case\"end\":return _context2.stop();}}},_callee2);}));return function(_x){return _ref2.apply(this,arguments);};}());/**\n * Fetch all NFT data for a collections by combining data from the API (static metadata)\n * and the Subgraph (dynamic market data)\n * @param collectionAddress\n */export var fetchNftsFromCollections=createAsyncThunk('nft/fetchNftsFromCollections',/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(collectionAddress){var _yield$Promise$all5,_yield$Promise$all6,nfts,nftsMarket;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.prev=0;_context3.next=3;return Promise.all([getNftsFromCollectionApi(collectionAddress),getNftsFromCollectionSg(collectionAddress)]);case 3:_yield$Promise$all5=_context3.sent;_yield$Promise$all6=_slicedToArray(_yield$Promise$all5,2);nfts=_yield$Promise$all6[0];nftsMarket=_yield$Promise$all6[1];if(nfts===null||nfts===void 0?void 0:nfts.data){_context3.next=9;break;}return _context3.abrupt(\"return\",[]);case 9:if(!(collectionAddress===pancakeBunniesAddress)){_context3.next=11;break;}return _context3.abrupt(\"return\",nftsMarket.map(function(marketData){var _nfts$data$marketData;// The fallback is just for the testnet where some bunnies don't exist\nvar apiMetadata=(_nfts$data$marketData=nfts.data[marketData.otherId])!==null&&_nfts$data$marketData!==void 0?_nfts$data$marketData:{name:'',description:'',collection:{name:'Pancake Bunnies'},image:{original:'',thumbnail:''}};// Generating attributes field that is not returned by API but can be \"faked\" since objects are keyed with bunny id\n// Generating attributes field that is not returned by API but can be \"faked\" since objects are keyed with bunny id\nvar attributes=[{traitType:'bunnyId',value:marketData.otherId,displayType:null}];return{tokenId:marketData.tokenId,name:apiMetadata.name,description:apiMetadata.description,collectionName:apiMetadata.collection.name,collectionAddress:collectionAddress,image:apiMetadata.image,marketData:marketData,attributes:attributes};}));case 11:return _context3.abrupt(\"return\",[]);case 14:_context3.prev=14;_context3.t0=_context3[\"catch\"](0);console.error(\"Failed to fetch collection NFTs for \".concat(collectionAddress),_context3.t0);return _context3.abrupt(\"return\",[]);case 18:case\"end\":return _context3.stop();}}},_callee3,null,[[0,14]]);}));return function(_x2){return _ref3.apply(this,arguments);};}());/**\n * Fetch fresh marketdata for existing tokens in the store\n */export var updateNftTokensData=createAsyncThunk('nft/updateNftTokensData',/*#__PURE__*/function(){var _ref5=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref4){var collectionAddress,existingTokenIds,_yield$Promise$all7,_yield$Promise$all8,nfts,nftsMarket;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:collectionAddress=_ref4.collectionAddress,existingTokenIds=_ref4.existingTokenIds;_context4.prev=1;_context4.next=4;return Promise.all([getNftsFromCollectionApi(collectionAddress),getMarketDataForTokenIds(collectionAddress,existingTokenIds)]);case 4:_yield$Promise$all7=_context4.sent;_yield$Promise$all8=_slicedToArray(_yield$Promise$all7,2);nfts=_yield$Promise$all8[0];nftsMarket=_yield$Promise$all8[1];if(nfts===null||nfts===void 0?void 0:nfts.data){_context4.next=10;break;}return _context4.abrupt(\"return\",[]);case 10:return _context4.abrupt(\"return\",nftsMarket.map(function(marketData){var _nfts$data$marketData2;// The fallback is just for the testnet where some bunnies don't exist\nvar apiMetadata=(_nfts$data$marketData2=nfts.data[marketData.otherId])!==null&&_nfts$data$marketData2!==void 0?_nfts$data$marketData2:{name:'',description:'',collection:{name:'Pancake Bunnies'},image:{original:'',thumbnail:''}};// Generating attributes field that is not returned by API but can be \"faked\" since objects are keyed with bunny id\n// Generating attributes field that is not returned by API but can be \"faked\" since objects are keyed with bunny id\nvar attributes=[{traitType:'bunnyId',value:marketData.otherId,displayType:null}];return{tokenId:marketData.tokenId,name:apiMetadata.name,description:apiMetadata.description,collectionName:apiMetadata.collection.name,collectionAddress:pancakeBunniesAddress,image:apiMetadata.image,marketData:marketData,attributes:attributes};}));case 13:_context4.prev=13;_context4.t0=_context4[\"catch\"](1);console.error(\"Failed to update collection NFTs for \".concat(collectionAddress),_context4.t0);return _context4.abrupt(\"return\",[]);case 17:case\"end\":return _context4.stop();}}},_callee4,null,[[1,13]]);}));return function(_x3){return _ref5.apply(this,arguments);};}());/**\n * Fetch all 30 on sale NFTs with specified bunny id\n */export var fetchNftsByBunnyId=createAsyncThunk('nft/fetchNftsByBunnyId',/*#__PURE__*/function(){var _ref7=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(_ref6){var bunnyId,existingTokenIds,existingMetadata,orderDirection,_nfts,nfts,nftsMarket;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:bunnyId=_ref6.bunnyId,existingTokenIds=_ref6.existingTokenIds,existingMetadata=_ref6.existingMetadata,orderDirection=_ref6.orderDirection;_context5.prev=1;nfts={data:_defineProperty({},bunnyId,existingMetadata)};if(existingMetadata){_context5.next=7;break;}_context5.next=6;return getNftsFromCollectionApi(pancakeBunniesAddress);case 6:nfts=_context5.sent;case 7:_context5.next=9;return getNftsByBunnyIdSg(bunnyId,existingTokenIds,orderDirection);case 9:nftsMarket=_context5.sent;if((_nfts=nfts)===null||_nfts===void 0?void 0:_nfts.data){_context5.next=12;break;}return _context5.abrupt(\"return\",[]);case 12:return _context5.abrupt(\"return\",nftsMarket.map(function(marketData){var _nfts$data$marketData3;// The fallback is just for the testnet where some bunnies don't exist\nvar apiMetadata=(_nfts$data$marketData3=nfts.data[marketData.otherId])!==null&&_nfts$data$marketData3!==void 0?_nfts$data$marketData3:{name:'',description:'',collection:{name:'Pancake Bunnies'},image:{original:'',thumbnail:''}};// Generating attributes field that is not returned by API but can be \"faked\" since objects are keyed with bunny id\n// Generating attributes field that is not returned by API but can be \"faked\" since objects are keyed with bunny id\nvar attributes=[{traitType:'bunnyId',value:marketData.otherId,displayType:null}];return{tokenId:marketData.tokenId,name:apiMetadata.name,description:apiMetadata.description,collectionName:apiMetadata.collection.name,collectionAddress:pancakeBunniesAddress,image:apiMetadata.image,marketData:marketData,attributes:attributes};}));case 15:_context5.prev=15;_context5.t0=_context5[\"catch\"](1);console.error(\"Failed to fetch collection NFTs for bunny id \".concat(bunnyId),_context5.t0);return _context5.abrupt(\"return\",[]);case 19:case\"end\":return _context5.stop();}}},_callee5,null,[[1,15]]);}));return function(_x4){return _ref7.apply(this,arguments);};}());export var fetchUserNfts=createAsyncThunk('nft/fetchUserNfts',/*#__PURE__*/function(){var _ref9=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_ref8){var account,profileNftWithCollectionAddress,collections,completeNftData;return _regeneratorRuntime.wrap(function _callee6$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:account=_ref8.account,profileNftWithCollectionAddress=_ref8.profileNftWithCollectionAddress,collections=_ref8.collections;_context6.next=3;return getCompleteAccountNftData(account,collections,profileNftWithCollectionAddress);case 3:completeNftData=_context6.sent;return _context6.abrupt(\"return\",completeNftData);case 5:case\"end\":return _context6.stop();}}},_callee6);}));return function(_x5){return _ref9.apply(this,arguments);};}());export var updateUserNft=createAsyncThunk('nft/updateUserNft',/*#__PURE__*/function(){var _ref11=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee7(_ref10){var tokenId,collectionAddress,_ref10$location,location,marketDataForNft,metadataForNft,completeNftData;return _regeneratorRuntime.wrap(function _callee7$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:tokenId=_ref10.tokenId,collectionAddress=_ref10.collectionAddress,_ref10$location=_ref10.location,location=_ref10$location===void 0?NftLocation.WALLET:_ref10$location;_context7.next=3;return getNftsMarketData({tokenId_in:[tokenId]});case 3:marketDataForNft=_context7.sent;_context7.next=6;return getNftsFromDifferentCollectionsApi([{tokenId:tokenId,collectionAddress:collectionAddress}]);case 6:metadataForNft=_context7.sent;completeNftData=_objectSpread(_objectSpread({},metadataForNft[0]),{},{location:location,marketData:marketDataForNft[0]});return _context7.abrupt(\"return\",completeNftData);case 9:case\"end\":return _context7.stop();}}},_callee7);}));return function(_x6){return _ref11.apply(this,arguments);};}());export var removeUserNft=createAsyncThunk('nft/removeUserNft',/*#__PURE__*/function(){var _ref13=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee8(_ref12){var tokenId;return _regeneratorRuntime.wrap(function _callee8$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:tokenId=_ref12.tokenId;return _context8.abrupt(\"return\",tokenId);case 2:case\"end\":return _context8.stop();}}},_callee8);}));return function(_x7){return _ref13.apply(this,arguments);};}());export var addUserNft=createAsyncThunk('nft/addUserNft',/*#__PURE__*/function(){var _ref15=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee9(_ref14){var tokenId,collectionAddress,_ref14$nftLocation,nftLocation,marketDataForNft,metadataForNft,tokens,completeNftData;return _regeneratorRuntime.wrap(function _callee9$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:tokenId=_ref14.tokenId,collectionAddress=_ref14.collectionAddress,_ref14$nftLocation=_ref14.nftLocation,nftLocation=_ref14$nftLocation===void 0?NftLocation.WALLET:_ref14$nftLocation;_context9.next=3;return getNftsMarketData({tokenId_in:[tokenId]});case 3:marketDataForNft=_context9.sent;_context9.next=6;return getNftsFromDifferentCollectionsApi([{tokenId:tokenId,collectionAddress:collectionAddress}]);case 6:metadataForNft=_context9.sent;tokens=_defineProperty({},tokenId,_objectSpread(_objectSpread({},marketDataForNft[0]),{},{nftLocation:nftLocation}));completeNftData=_objectSpread(_objectSpread({},metadataForNft[0]),{},{tokens:tokens});return _context9.abrupt(\"return\",completeNftData);case 10:case\"end\":return _context9.stop();}}},_callee9);}));return function(_x8){return _ref15.apply(this,arguments);};}());export var fetchUserActivity=createAsyncThunk('nft/fetchUserActivity',/*#__PURE__*/function(){var _ref16=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee10(address){var userActivity;return _regeneratorRuntime.wrap(function _callee10$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:_context10.next=2;return getUserActivity(address.toLocaleLowerCase());case 2:userActivity=_context10.sent;return _context10.abrupt(\"return\",userActivity);case 4:case\"end\":return _context10.stop();}}},_callee10);}));return function(_x9){return _ref16.apply(this,arguments);};}());export var NftMarket=createSlice({name:'NftMarket',initialState:initialState,reducers:{},extraReducers:function extraReducers(builder){builder.addCase(fetchCollection.fulfilled,function(state,action){state.data.collections=_objectSpread(_objectSpread({},state.data.collections),action.payload);});builder.addCase(fetchCollections.fulfilled,function(state,action){state.data.collections=action.payload;state.initializationState=NFTMarketInitializationState.INITIALIZED;});builder.addCase(fetchNftsFromCollections.fulfilled,function(state,action){state.data.nfts[action.meta.arg]=action.payload;});builder.addCase(updateNftTokensData.fulfilled,function(state,action){if(action.payload.length>0){state.data.nfts[action.meta.arg.collectionAddress]=action.payload;state.data.lastUpdateAt=Date.now();}});builder.addCase(updateNftTokensData.rejected,function(state){state.data.lastUpdateAt=Date.now();});builder.addCase(fetchNftsByBunnyId.pending,function(state){state.data.isFetchingMoreNfts=true;});builder.addCase(fetchNftsByBunnyId.fulfilled,function(state,action){var existingNftsInState=state.data.nfts[pancakeBunniesAddress]||[];state.data.nfts[pancakeBunniesAddress]=[].concat(_toConsumableArray(existingNftsInState),_toConsumableArray(action.payload));state.data.isFetchingMoreNfts=false;state.data.latestFetchAt=Date.now();});builder.addCase(fetchNftsByBunnyId.rejected,function(state){state.data.isFetchingMoreNfts=false;});builder.addCase(fetchUserNfts.rejected,function(state){state.data.user.userNftsInitializationState=UserNftInitializationState.ERROR;});builder.addCase(fetchUserNfts.pending,function(state){state.data.user.userNftsInitializationState=UserNftInitializationState.INITIALIZING;});builder.addCase(fetchUserNfts.fulfilled,function(state,action){state.data.user.nfts=action.payload;state.data.user.userNftsInitializationState=UserNftInitializationState.INITIALIZED;});builder.addCase(updateUserNft.fulfilled,function(state,action){var userNftsState=state.data.user.nfts;var nftToUpdate=userNftsState.find(function(nft){return nft.tokenId===action.payload.tokenId;});var indexInState=userNftsState.indexOf(nftToUpdate);state.data.user.nfts[indexInState]=action.payload;});builder.addCase(removeUserNft.fulfilled,function(state,action){var copyOfState=_toConsumableArray(state.data.user.nfts);var nftToRemove=copyOfState.find(function(nft){return nft.tokenId===action.payload;});var indexInState=copyOfState.indexOf(nftToRemove);copyOfState.splice(indexInState,1);state.data.user.nfts=copyOfState;});builder.addCase(addUserNft.fulfilled,function(state,action){state.data.user.nfts=[].concat(_toConsumableArray(state.data.user.nfts),[action.payload]);});builder.addCase(fetchUserActivity.fulfilled,function(state,action){state.data.user.activity=_objectSpread(_objectSpread({},action.payload),{},{initializationState:UserNftInitializationState.INITIALIZED});});builder.addCase(fetchUserActivity.rejected,function(state){state.data.user.activity.initializationState=UserNftInitializationState.ERROR;});builder.addCase(fetchUserActivity.pending,function(state){state.data.user.activity.initializationState=UserNftInitializationState.INITIALIZING;});}});export default NftMarket.reducer;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/nftMarket/reducer.ts"],"names":["createSlice","createAsyncThunk","pancakeBunniesAddress","getNftsFromCollectionApi","getNftsFromCollectionSg","getNftsMarketData","getCollectionsApi","getCollectionsSg","getUserActivity","combineCollectionData","getCollectionSg","getCollectionApi","getNftsFromDifferentCollectionsApi","getCompleteAccountNftData","getNftsByBunnyIdSg","getMarketDataForTokenIds","NFTMarketInitializationState","UserNftInitializationState","NftLocation","initialState","initializationState","UNINITIALIZED","data","collections","nfts","isFetchingMoreNfts","latestFetchAt","lastUpdateAt","Date","now","users","user","userNftsInitializationState","activity","askOrderHistory","buyTradeHistory","sellTradeHistory","fetchCollections","Promise","all","collectionsMarket","fetchCollection","collectionAddress","collection","collectionMarket","fetchNftsFromCollections","nftsMarket","map","marketData","apiMetadata","otherId","name","description","image","original","thumbnail","attributes","traitType","value","displayType","tokenId","collectionName","console","error","updateNftTokensData","existingTokenIds","fetchNftsByBunnyId","bunnyId","existingMetadata","orderDirection","fetchUserNfts","account","profileNftWithCollectionAddress","completeNftData","updateUserNft","location","WALLET","tokenId_in","marketDataForNft","metadataForNft","removeUserNft","addUserNft","nftLocation","tokens","fetchUserActivity","address","toLocaleLowerCase","userActivity","NftMarket","reducers","extraReducers","builder","addCase","fulfilled","state","action","payload","INITIALIZED","meta","arg","length","rejected","pending","existingNftsInState","ERROR","INITIALIZING","userNftsState","nftToUpdate","find","nft","indexInState","indexOf","copyOfState","nftToRemove","splice","reducer"],"mappings":"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","sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'\nimport { pancakeBunniesAddress } from 'views/Nft/market/constants'\nimport {\n  getNftsFromCollectionApi,\n  getNftsFromCollectionSg,\n  getNftsMarketData,\n  getCollectionsApi,\n  getCollectionsSg,\n  getUserActivity,\n  combineCollectionData,\n  getCollectionSg,\n  getCollectionApi,\n  getNftsFromDifferentCollectionsApi,\n  getCompleteAccountNftData,\n  getNftsByBunnyIdSg,\n  getMarketDataForTokenIds,\n} from './helpers'\nimport {\n  State,\n  Collection,\n  ApiCollections,\n  TokenIdWithCollectionAddress,\n  NFTMarketInitializationState,\n  UserNftInitializationState,\n  NftToken,\n  NftLocation,\n  ApiSingleTokenData,\n} from './types'\n\nconst initialState: State = {\n  initializationState: NFTMarketInitializationState.UNINITIALIZED,\n  data: {\n    collections: {},\n    nfts: {},\n    isFetchingMoreNfts: false,\n    latestFetchAt: 0,\n    lastUpdateAt: Date.now(),\n    users: {},\n    user: {\n      userNftsInitializationState: UserNftInitializationState.UNINITIALIZED,\n      nfts: [],\n      activity: {\n        initializationState: UserNftInitializationState.UNINITIALIZED,\n        askOrderHistory: [],\n        buyTradeHistory: [],\n        sellTradeHistory: [],\n      },\n    },\n  },\n}\n\n/**\n * Fetch all collections data by combining data from the API (static metadata) and the Subgraph (dynamic market data)\n */\nexport const fetchCollections = createAsyncThunk<Record<string, Collection>>('nft/fetchCollections', async () => {\n  const [collections, collectionsMarket] = await Promise.all([getCollectionsApi(), getCollectionsSg()])\n  return combineCollectionData(collections, collectionsMarket)\n})\n\n/**\n * Fetch collection data by combining data from the API (static metadata) and the Subgraph (dynamic market data)\n */\nexport const fetchCollection = createAsyncThunk<Record<string, Collection>, string>(\n  'nft/fetchCollection',\n  async (collectionAddress) => {\n    const [collection, collectionMarket] = await Promise.all([\n      getCollectionApi(collectionAddress),\n      getCollectionSg(collectionAddress),\n    ])\n\n    return combineCollectionData([collection], [collectionMarket])\n  },\n)\n\n/**\n * Fetch all NFT data for a collections by combining data from the API (static metadata)\n * and the Subgraph (dynamic market data)\n * @param collectionAddress\n */\nexport const fetchNftsFromCollections = createAsyncThunk(\n  'nft/fetchNftsFromCollections',\n  async (collectionAddress: string) => {\n    try {\n      const [nfts, nftsMarket] = await Promise.all([\n        getNftsFromCollectionApi(collectionAddress),\n        getNftsFromCollectionSg(collectionAddress),\n      ])\n\n      if (!nfts?.data) {\n        return []\n      }\n\n      if (collectionAddress === pancakeBunniesAddress) {\n        return nftsMarket.map((marketData) => {\n          // The fallback is just for the testnet where some bunnies don't exist\n          const apiMetadata = nfts.data[marketData.otherId] ?? {\n            name: '',\n            description: '',\n            collection: { name: 'Pancake Bunnies' },\n            image: {\n              original: '',\n              thumbnail: '',\n            },\n          }\n          // Generating attributes field that is not returned by API but can be \"faked\" since objects are keyed with bunny id\n          const attributes = [\n            {\n              traitType: 'bunnyId',\n              value: marketData.otherId,\n              displayType: null,\n            },\n          ]\n          return {\n            tokenId: marketData.tokenId,\n            name: apiMetadata.name,\n            description: apiMetadata.description,\n            collectionName: apiMetadata.collection.name,\n            collectionAddress,\n            image: apiMetadata.image,\n            marketData,\n            attributes,\n          }\n        })\n      }\n\n      // TODO: revisit this for other collecitons\n      return []\n    } catch (error) {\n      console.error(`Failed to fetch collection NFTs for ${collectionAddress}`, error)\n      return []\n    }\n  },\n)\n\n/**\n * Fetch fresh marketdata for existing tokens in the store\n */\nexport const updateNftTokensData = createAsyncThunk<\n  NftToken[],\n  { collectionAddress: string; existingTokenIds: string[] }\n>('nft/updateNftTokensData', async ({ collectionAddress, existingTokenIds }) => {\n  try {\n    // TODO: this kinda should work for other collections too, but doublecheck during Squad integration\n    const [nfts, nftsMarket] = await Promise.all([\n      getNftsFromCollectionApi(collectionAddress),\n      getMarketDataForTokenIds(collectionAddress, existingTokenIds),\n    ])\n\n    if (!nfts?.data) {\n      return []\n    }\n\n    return nftsMarket.map((marketData) => {\n      // The fallback is just for the testnet where some bunnies don't exist\n      const apiMetadata = nfts.data[marketData.otherId] ?? {\n        name: '',\n        description: '',\n        collection: { name: 'Pancake Bunnies' },\n        image: {\n          original: '',\n          thumbnail: '',\n        },\n      }\n      // Generating attributes field that is not returned by API but can be \"faked\" since objects are keyed with bunny id\n      const attributes = [\n        {\n          traitType: 'bunnyId',\n          value: marketData.otherId,\n          displayType: null,\n        },\n      ]\n      return {\n        tokenId: marketData.tokenId,\n        name: apiMetadata.name,\n        description: apiMetadata.description,\n        collectionName: apiMetadata.collection.name,\n        collectionAddress: pancakeBunniesAddress,\n        image: apiMetadata.image,\n        marketData,\n        attributes,\n      }\n    })\n  } catch (error) {\n    console.error(`Failed to update collection NFTs for ${collectionAddress}`, error)\n    return []\n  }\n})\n\n/**\n * Fetch all 30 on sale NFTs with specified bunny id\n */\nexport const fetchNftsByBunnyId = createAsyncThunk<\n  NftToken[],\n  { bunnyId: string; existingTokenIds: string[]; existingMetadata: ApiSingleTokenData; orderDirection: 'asc' | 'desc' }\n>('nft/fetchNftsByBunnyId', async ({ bunnyId, existingTokenIds, existingMetadata, orderDirection }) => {\n  try {\n    let nfts = { data: { [bunnyId]: existingMetadata } }\n    if (!existingMetadata) {\n      nfts = await getNftsFromCollectionApi(pancakeBunniesAddress)\n    }\n    const nftsMarket = await getNftsByBunnyIdSg(bunnyId, existingTokenIds, orderDirection)\n\n    if (!nfts?.data) {\n      return []\n    }\n\n    return nftsMarket.map((marketData) => {\n      // The fallback is just for the testnet where some bunnies don't exist\n      const apiMetadata = nfts.data[marketData.otherId] ?? {\n        name: '',\n        description: '',\n        collection: { name: 'Pancake Bunnies' },\n        image: {\n          original: '',\n          thumbnail: '',\n        },\n      }\n      // Generating attributes field that is not returned by API but can be \"faked\" since objects are keyed with bunny id\n      const attributes = [\n        {\n          traitType: 'bunnyId',\n          value: marketData.otherId,\n          displayType: null,\n        },\n      ]\n      return {\n        tokenId: marketData.tokenId,\n        name: apiMetadata.name,\n        description: apiMetadata.description,\n        collectionName: apiMetadata.collection.name,\n        collectionAddress: pancakeBunniesAddress,\n        image: apiMetadata.image,\n        marketData,\n        attributes,\n      }\n    })\n  } catch (error) {\n    console.error(`Failed to fetch collection NFTs for bunny id ${bunnyId}`, error)\n    return []\n  }\n})\n\nexport const fetchUserNfts = createAsyncThunk<\n  NftToken[],\n  { account: string; profileNftWithCollectionAddress?: TokenIdWithCollectionAddress; collections: ApiCollections }\n>('nft/fetchUserNfts', async ({ account, profileNftWithCollectionAddress, collections }) => {\n  const completeNftData = await getCompleteAccountNftData(account, collections, profileNftWithCollectionAddress)\n  return completeNftData\n})\n\nexport const updateUserNft = createAsyncThunk<\n  NftToken,\n  { tokenId: string; collectionAddress: string; location?: NftLocation }\n>('nft/updateUserNft', async ({ tokenId, collectionAddress, location = NftLocation.WALLET }) => {\n  const marketDataForNft = await getNftsMarketData({ tokenId_in: [tokenId] })\n  const metadataForNft = await getNftsFromDifferentCollectionsApi([{ tokenId, collectionAddress }])\n  const completeNftData = { ...metadataForNft[0], location, marketData: marketDataForNft[0] }\n\n  return completeNftData\n})\n\nexport const removeUserNft = createAsyncThunk<string, { tokenId: string }>(\n  'nft/removeUserNft',\n  async ({ tokenId }) => tokenId,\n)\n\nexport const addUserNft = createAsyncThunk<\n  NftToken,\n  { tokenId: string; collectionAddress: string; nftLocation?: NftLocation }\n>('nft/addUserNft', async ({ tokenId, collectionAddress, nftLocation = NftLocation.WALLET }) => {\n  const marketDataForNft = await getNftsMarketData({ tokenId_in: [tokenId] })\n  const metadataForNft = await getNftsFromDifferentCollectionsApi([{ tokenId, collectionAddress }])\n\n  const tokens = { [tokenId]: { ...marketDataForNft[0], nftLocation } }\n  const completeNftData = { ...metadataForNft[0], tokens }\n\n  return completeNftData\n})\n\nexport const fetchUserActivity = createAsyncThunk('nft/fetchUserActivity', async (address: string) => {\n  const userActivity = await getUserActivity(address.toLocaleLowerCase())\n  return userActivity\n})\n\nexport const NftMarket = createSlice({\n  name: 'NftMarket',\n  initialState,\n  reducers: {},\n  extraReducers: (builder) => {\n    builder.addCase(fetchCollection.fulfilled, (state, action) => {\n      state.data.collections = { ...state.data.collections, ...action.payload }\n    })\n    builder.addCase(fetchCollections.fulfilled, (state, action) => {\n      state.data.collections = action.payload\n      state.initializationState = NFTMarketInitializationState.INITIALIZED\n    })\n    builder.addCase(fetchNftsFromCollections.fulfilled, (state, action) => {\n      state.data.nfts[action.meta.arg] = action.payload\n    })\n    builder.addCase(updateNftTokensData.fulfilled, (state, action) => {\n      if (action.payload.length > 0) {\n        state.data.nfts[action.meta.arg.collectionAddress] = action.payload\n        state.data.lastUpdateAt = Date.now()\n      }\n    })\n    builder.addCase(updateNftTokensData.rejected, (state) => {\n      state.data.lastUpdateAt = Date.now()\n    })\n    builder.addCase(fetchNftsByBunnyId.pending, (state) => {\n      state.data.isFetchingMoreNfts = true\n    })\n    builder.addCase(fetchNftsByBunnyId.fulfilled, (state, action) => {\n      const existingNftsInState = state.data.nfts[pancakeBunniesAddress] || []\n      state.data.nfts[pancakeBunniesAddress] = [...existingNftsInState, ...action.payload]\n      state.data.isFetchingMoreNfts = false\n      state.data.latestFetchAt = Date.now()\n    })\n    builder.addCase(fetchNftsByBunnyId.rejected, (state) => {\n      state.data.isFetchingMoreNfts = false\n    })\n    builder.addCase(fetchUserNfts.rejected, (state) => {\n      state.data.user.userNftsInitializationState = UserNftInitializationState.ERROR\n    })\n    builder.addCase(fetchUserNfts.pending, (state) => {\n      state.data.user.userNftsInitializationState = UserNftInitializationState.INITIALIZING\n    })\n    builder.addCase(fetchUserNfts.fulfilled, (state, action) => {\n      state.data.user.nfts = action.payload\n      state.data.user.userNftsInitializationState = UserNftInitializationState.INITIALIZED\n    })\n    builder.addCase(updateUserNft.fulfilled, (state, action) => {\n      const userNftsState: NftToken[] = state.data.user.nfts\n      const nftToUpdate = userNftsState.find((nft) => nft.tokenId === action.payload.tokenId)\n      const indexInState = userNftsState.indexOf(nftToUpdate)\n      state.data.user.nfts[indexInState] = action.payload\n    })\n    builder.addCase(removeUserNft.fulfilled, (state, action) => {\n      const copyOfState: NftToken[] = [...state.data.user.nfts]\n      const nftToRemove = copyOfState.find((nft) => nft.tokenId === action.payload)\n      const indexInState = copyOfState.indexOf(nftToRemove)\n      copyOfState.splice(indexInState, 1)\n      state.data.user.nfts = copyOfState\n    })\n    builder.addCase(addUserNft.fulfilled, (state, action) => {\n      state.data.user.nfts = [...state.data.user.nfts, action.payload]\n    })\n    builder.addCase(fetchUserActivity.fulfilled, (state, action) => {\n      state.data.user.activity = { ...action.payload, initializationState: UserNftInitializationState.INITIALIZED }\n    })\n    builder.addCase(fetchUserActivity.rejected, (state) => {\n      state.data.user.activity.initializationState = UserNftInitializationState.ERROR\n    })\n    builder.addCase(fetchUserActivity.pending, (state) => {\n      state.data.user.activity.initializationState = UserNftInitializationState.INITIALIZING\n    })\n  },\n})\n\nexport default NftMarket.reducer\n"]},"metadata":{},"sourceType":"module"}