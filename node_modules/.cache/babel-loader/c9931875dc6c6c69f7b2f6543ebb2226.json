{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { gql } from 'graphql-request';\nimport { useState, useEffect } from 'react';\nimport { multiQuery } from 'views/Info/utils/infoQueryHelpers';\nimport { BLOCKS_CLIENT } from 'config/constants/endpoints';\n\nconst getBlockSubqueries = timestamps => timestamps.map(timestamp => {\n  return `t${timestamp}:blocks(first: 1, orderBy: timestamp, orderDirection: desc, where: { timestamp_gt: ${timestamp}, timestamp_lt: ${timestamp + 600} }) {\n      number\n    }`;\n});\n\nconst blocksQueryConstructor = subqueries => {\n  return gql`query blocks {\n    ${subqueries}\n  }`;\n};\n/**\n * @notice Fetches block objects for an array of timestamps.\n * @param {Array} timestamps\n */\n\n\nexport const getBlocksFromTimestamps = async (timestamps, sortDirection = 'desc', skipCount = 500) => {\n  if ((timestamps === null || timestamps === void 0 ? void 0 : timestamps.length) === 0) {\n    return [];\n  }\n\n  const fetchedData = await multiQuery(blocksQueryConstructor, getBlockSubqueries(timestamps), BLOCKS_CLIENT, skipCount);\n  const sortingFunction = sortDirection === 'desc' ? (a, b) => b.number - a.number : (a, b) => a.number - b.number;\n  const blocks = [];\n\n  if (fetchedData) {\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key of Object.keys(fetchedData)) {\n      if (fetchedData[key].length > 0) {\n        blocks.push({\n          timestamp: key.split('t')[1],\n          number: parseInt(fetchedData[key][0].number, 10)\n        });\n      }\n    } // graphql-request does not guarantee same ordering of batched requests subqueries, hence manual sorting\n\n\n    blocks.sort(sortingFunction);\n  }\n\n  return blocks;\n};\n/**\n * for a given array of timestamps, returns block entities\n * @param timestamps\n * @param sortDirection\n * @param skipCount\n */\n\nexport const useBlocksFromTimestamps = (timestamps, sortDirection = 'desc', skipCount = 1000) => {\n  _s();\n\n  const [blocks, setBlocks] = useState();\n  const [error, setError] = useState(false);\n  const timestampsString = JSON.stringify(timestamps);\n  const blocksString = blocks ? JSON.stringify(blocks) : undefined;\n  useEffect(() => {\n    const fetchData = async () => {\n      const timestampsArray = JSON.parse(timestampsString);\n      const result = await getBlocksFromTimestamps(timestampsArray, sortDirection, skipCount);\n\n      if (result.length === 0) {\n        setError(true);\n      } else {\n        setBlocks(result);\n      }\n    };\n\n    const blocksArray = blocksString ? JSON.parse(blocksString) : undefined;\n\n    if (!blocksArray && !error) {\n      fetchData();\n    }\n  }, [blocksString, error, skipCount, sortDirection, timestampsString]);\n  return {\n    blocks,\n    error\n  };\n};\n\n_s(useBlocksFromTimestamps, \"HnEjk+Fn/TGUjRWn/bOGkLIdY4Y=\");","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/views/Info/hooks/useBlocksFromTimestamps.ts"],"names":["gql","useState","useEffect","multiQuery","BLOCKS_CLIENT","getBlockSubqueries","timestamps","map","timestamp","blocksQueryConstructor","subqueries","getBlocksFromTimestamps","sortDirection","skipCount","length","fetchedData","sortingFunction","a","b","number","blocks","key","Object","keys","push","split","parseInt","sort","useBlocksFromTimestamps","setBlocks","error","setError","timestampsString","JSON","stringify","blocksString","undefined","fetchData","timestampsArray","parse","result","blocksArray"],"mappings":"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","sourcesContent":["import { gql } from 'graphql-request'\nimport { useState, useEffect } from 'react'\nimport { multiQuery } from 'views/Info/utils/infoQueryHelpers'\nimport { BLOCKS_CLIENT } from 'config/constants/endpoints'\nimport { Block } from 'state/info/types'\n\nconst getBlockSubqueries = (timestamps: number[]) =>\n  timestamps.map((timestamp) => {\n    return `t${timestamp}:blocks(first: 1, orderBy: timestamp, orderDirection: desc, where: { timestamp_gt: ${timestamp}, timestamp_lt: ${\n      timestamp + 600\n    } }) {\n      number\n    }`\n  })\n\nconst blocksQueryConstructor = (subqueries: string[]) => {\n  return gql`query blocks {\n    ${subqueries}\n  }`\n}\n\n/**\n * @notice Fetches block objects for an array of timestamps.\n * @param {Array} timestamps\n */\nexport const getBlocksFromTimestamps = async (\n  timestamps: number[],\n  sortDirection: 'asc' | 'desc' = 'desc',\n  skipCount = 500,\n): Promise<Block[]> => {\n  if (timestamps?.length === 0) {\n    return []\n  }\n\n  const fetchedData: any = await multiQuery(\n    blocksQueryConstructor,\n    getBlockSubqueries(timestamps),\n    BLOCKS_CLIENT,\n    skipCount,\n  )\n\n  const sortingFunction =\n    sortDirection === 'desc' ? (a: Block, b: Block) => b.number - a.number : (a: Block, b: Block) => a.number - b.number\n\n  const blocks: Block[] = []\n  if (fetchedData) {\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key of Object.keys(fetchedData)) {\n      if (fetchedData[key].length > 0) {\n        blocks.push({\n          timestamp: key.split('t')[1],\n          number: parseInt(fetchedData[key][0].number, 10),\n        })\n      }\n    }\n    // graphql-request does not guarantee same ordering of batched requests subqueries, hence manual sorting\n    blocks.sort(sortingFunction)\n  }\n  return blocks\n}\n\n/**\n * for a given array of timestamps, returns block entities\n * @param timestamps\n * @param sortDirection\n * @param skipCount\n */\nexport const useBlocksFromTimestamps = (\n  timestamps: number[],\n  sortDirection: 'asc' | 'desc' = 'desc',\n  skipCount = 1000,\n): {\n  blocks?: Block[]\n  error: boolean\n} => {\n  const [blocks, setBlocks] = useState<Block[]>()\n  const [error, setError] = useState(false)\n\n  const timestampsString = JSON.stringify(timestamps)\n  const blocksString = blocks ? JSON.stringify(blocks) : undefined\n\n  useEffect(() => {\n    const fetchData = async () => {\n      const timestampsArray = JSON.parse(timestampsString)\n      const result = await getBlocksFromTimestamps(timestampsArray, sortDirection, skipCount)\n      if (result.length === 0) {\n        setError(true)\n      } else {\n        setBlocks(result)\n      }\n    }\n    const blocksArray = blocksString ? JSON.parse(blocksString) : undefined\n    if (!blocksArray && !error) {\n      fetchData()\n    }\n  }, [blocksString, error, skipCount, sortDirection, timestampsString])\n\n  return {\n    blocks,\n    error,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}