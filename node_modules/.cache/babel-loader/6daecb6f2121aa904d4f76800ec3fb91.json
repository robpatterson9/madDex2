{"ast":null,"code":"var _jsxFileName = \"/Volumes/evo970/lou/madDex-master/src/views/Nft/market/Collection/Items/CollectionNfts.tsx\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect } from 'react';\nimport { Grid } from '@pancakeswap/uikit';\nimport { getAddress } from '@ethersproject/address';\nimport orderBy from 'lodash/orderBy';\nimport { useAppDispatch } from 'state';\nimport { useNftsFromCollection } from 'state/nftMarket/hooks';\nimport { fetchNftsFromCollections } from 'state/nftMarket/reducer';\nimport GridPlaceholder from '../../components/GridPlaceholder';\nimport { CollectibleLinkCard } from '../../components/CollectibleCard';\nimport { pancakeBunniesAddress } from '../../constants';\nimport useAllPancakeBunnyNfts from '../../hooks/useAllPancakeBunnyNfts';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst CollectionNfts = ({\n  collection,\n  sortBy = 'updatedAt'\n}) => {\n  _s();\n\n  const {\n    address\n  } = collection;\n  const checksummedAddress = getAddress(address);\n  const dispatch = useAppDispatch();\n  const isPBCollection = address === pancakeBunniesAddress;\n  useEffect(() => {\n    dispatch(fetchNftsFromCollections(checksummedAddress));\n  }, [checksummedAddress, dispatch]);\n  const nfts = useNftsFromCollection(checksummedAddress);\n  const allPancakeBunnyNfts = useAllPancakeBunnyNfts(address);\n  const currentNfts = isPBCollection ? allPancakeBunnyNfts : nfts === null || nfts === void 0 ? void 0 : nfts.filter(nft => nft.marketData.isTradable);\n\n  if (!currentNfts) {\n    return /*#__PURE__*/_jsxDEV(GridPlaceholder, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 36,\n      columnNumber: 12\n    }, this);\n  }\n\n  const nftsToShow = orderBy(currentNfts, nft => isPBCollection ? nft.meta[sortBy] : Number(nft.marketData[sortBy]), [sortBy === 'currentAskPrice' ? 'asc' : 'desc']);\n  return /*#__PURE__*/_jsxDEV(Grid, {\n    gridGap: \"16px\",\n    gridTemplateColumns: ['1fr', null, 'repeat(3, 1fr)', null, 'repeat(4, 1fr)'],\n    alignItems: \"start\",\n    children: nftsToShow.map(nft => {\n      return /*#__PURE__*/_jsxDEV(CollectibleLinkCard, {\n        nft: nft\n      }, `${nft.tokenId}-${nft.collectionName}`, false, {\n        fileName: _jsxFileName,\n        lineNumber: 52,\n        columnNumber: 16\n      }, this);\n    })\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 46,\n    columnNumber: 5\n  }, this);\n};\n\n_s(CollectionNfts, \"ZuAO30TCI8/BhJ/6K5xuBz8lTHE=\", false, function () {\n  return [useAppDispatch, useNftsFromCollection, useAllPancakeBunnyNfts];\n});\n\n_c = CollectionNfts;\nexport default CollectionNfts;\n\nvar _c;\n\n$RefreshReg$(_c, \"CollectionNfts\");","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/views/Nft/market/Collection/Items/CollectionNfts.tsx"],"names":["React","useEffect","Grid","getAddress","orderBy","useAppDispatch","useNftsFromCollection","fetchNftsFromCollections","GridPlaceholder","CollectibleLinkCard","pancakeBunniesAddress","useAllPancakeBunnyNfts","CollectionNfts","collection","sortBy","address","checksummedAddress","dispatch","isPBCollection","nfts","allPancakeBunnyNfts","currentNfts","filter","nft","marketData","isTradable","nftsToShow","meta","Number","map","tokenId","collectionName"],"mappings":";;;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,SAASC,IAAT,QAAqB,oBAArB;AACA,SAASC,UAAT,QAA2B,wBAA3B;AACA,OAAOC,OAAP,MAAoB,gBAApB;AACA,SAASC,cAAT,QAA+B,OAA/B;AACA,SAASC,qBAAT,QAAsC,uBAAtC;AAEA,SAASC,wBAAT,QAAyC,yBAAzC;AACA,OAAOC,eAAP,MAA4B,kCAA5B;AACA,SAASC,mBAAT,QAAoC,kCAApC;AACA,SAASC,qBAAT,QAAsC,iBAAtC;AACA,OAAOC,sBAAP,MAAmC,oCAAnC;;;AAOA,MAAMC,cAA6C,GAAG,CAAC;AAAEC,EAAAA,UAAF;AAAcC,EAAAA,MAAM,GAAG;AAAvB,CAAD,KAA0C;AAAA;;AAC9F,QAAM;AAAEC,IAAAA;AAAF,MAAcF,UAApB;AACA,QAAMG,kBAAkB,GAAGb,UAAU,CAACY,OAAD,CAArC;AACA,QAAME,QAAQ,GAAGZ,cAAc,EAA/B;AAEA,QAAMa,cAAc,GAAGH,OAAO,KAAKL,qBAAnC;AAEAT,EAAAA,SAAS,CAAC,MAAM;AACdgB,IAAAA,QAAQ,CAACV,wBAAwB,CAACS,kBAAD,CAAzB,CAAR;AACD,GAFQ,EAEN,CAACA,kBAAD,EAAqBC,QAArB,CAFM,CAAT;AAIA,QAAME,IAAI,GAAGb,qBAAqB,CAACU,kBAAD,CAAlC;AACA,QAAMI,mBAAmB,GAAGT,sBAAsB,CAACI,OAAD,CAAlD;AAEA,QAAMM,WAAW,GAAGH,cAAc,GAAGE,mBAAH,GAAyBD,IAAzB,aAAyBA,IAAzB,uBAAyBA,IAAI,CAAEG,MAAN,CAAcC,GAAD,IAASA,GAAG,CAACC,UAAJ,CAAeC,UAArC,CAA3D;;AAEA,MAAI,CAACJ,WAAL,EAAkB;AAChB,wBAAO,QAAC,eAAD;AAAA;AAAA;AAAA;AAAA,YAAP;AACD;;AAED,QAAMK,UAAU,GAAGtB,OAAO,CACxBiB,WADwB,EAEvBE,GAAD,IAAUL,cAAc,GAAGK,GAAG,CAACI,IAAJ,CAASb,MAAT,CAAH,GAAsBc,MAAM,CAACL,GAAG,CAACC,UAAJ,CAAeV,MAAf,CAAD,CAF5B,EAGxB,CAACA,MAAM,KAAK,iBAAX,GAA+B,KAA/B,GAAuC,MAAxC,CAHwB,CAA1B;AAMA,sBACE,QAAC,IAAD;AACE,IAAA,OAAO,EAAC,MADV;AAEE,IAAA,mBAAmB,EAAE,CAAC,KAAD,EAAQ,IAAR,EAAc,gBAAd,EAAgC,IAAhC,EAAsC,gBAAtC,CAFvB;AAGE,IAAA,UAAU,EAAC,OAHb;AAAA,cAKGY,UAAU,CAACG,GAAX,CAAgBN,GAAD,IAAS;AACvB,0BAAO,QAAC,mBAAD;AAAkE,QAAA,GAAG,EAAEA;AAAvE,SAA2B,GAAEA,GAAG,CAACO,OAAQ,IAAGP,GAAG,CAACQ,cAAe,EAA/D;AAAA;AAAA;AAAA;AAAA,cAAP;AACD,KAFA;AALH;AAAA;AAAA;AAAA;AAAA,UADF;AAWD,CArCD;;GAAMnB,c;UAGaP,c,EAQJC,qB,EACeK,sB;;;KAZxBC,c;AAuCN,eAAeA,cAAf","sourcesContent":["import React, { useEffect } from 'react'\nimport { Grid } from '@pancakeswap/uikit'\nimport { getAddress } from '@ethersproject/address'\nimport orderBy from 'lodash/orderBy'\nimport { useAppDispatch } from 'state'\nimport { useNftsFromCollection } from 'state/nftMarket/hooks'\nimport { Collection } from 'state/nftMarket/types'\nimport { fetchNftsFromCollections } from 'state/nftMarket/reducer'\nimport GridPlaceholder from '../../components/GridPlaceholder'\nimport { CollectibleLinkCard } from '../../components/CollectibleCard'\nimport { pancakeBunniesAddress } from '../../constants'\nimport useAllPancakeBunnyNfts from '../../hooks/useAllPancakeBunnyNfts'\n\ninterface CollectionNftsProps {\n  collection: Collection\n  sortBy?: string\n}\n\nconst CollectionNfts: React.FC<CollectionNftsProps> = ({ collection, sortBy = 'updatedAt' }) => {\n  const { address } = collection\n  const checksummedAddress = getAddress(address)\n  const dispatch = useAppDispatch()\n\n  const isPBCollection = address === pancakeBunniesAddress\n\n  useEffect(() => {\n    dispatch(fetchNftsFromCollections(checksummedAddress))\n  }, [checksummedAddress, dispatch])\n\n  const nfts = useNftsFromCollection(checksummedAddress)\n  const allPancakeBunnyNfts = useAllPancakeBunnyNfts(address)\n\n  const currentNfts = isPBCollection ? allPancakeBunnyNfts : nfts?.filter((nft) => nft.marketData.isTradable)\n\n  if (!currentNfts) {\n    return <GridPlaceholder />\n  }\n\n  const nftsToShow = orderBy(\n    currentNfts,\n    (nft) => (isPBCollection ? nft.meta[sortBy] : Number(nft.marketData[sortBy])),\n    [sortBy === 'currentAskPrice' ? 'asc' : 'desc'],\n  )\n\n  return (\n    <Grid\n      gridGap=\"16px\"\n      gridTemplateColumns={['1fr', null, 'repeat(3, 1fr)', null, 'repeat(4, 1fr)']}\n      alignItems=\"start\"\n    >\n      {nftsToShow.map((nft) => {\n        return <CollectibleLinkCard key={`${nft.tokenId}-${nft.collectionName}`} nft={nft} />\n      })}\n    </Grid>\n  )\n}\n\nexport default CollectionNfts\n"]},"metadata":{},"sourceType":"module"}