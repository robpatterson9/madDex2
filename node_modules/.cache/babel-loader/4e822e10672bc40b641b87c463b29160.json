{"ast":null,"code":"import _regeneratorRuntime from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _taggedTemplateLiteral from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";var _templateObject;import{getUnixTime}from'date-fns';import{gql}from'graphql-request';import{getBlocksFromTimestamps}from'views/Info/hooks/useBlocksFromTimestamps';import{multiQuery}from'views/Info/utils/infoQueryHelpers';import{INFO_CLIENT}from'config/constants/endpoints';var getPriceSubqueries=function getPriceSubqueries(tokenAddress,blocks){return blocks.map(function(block){return\"\\n      t\".concat(block.timestamp,\":token(id:\\\"\").concat(tokenAddress,\"\\\", block: { number: \").concat(block.number,\" }) { \\n        derivedBNB\\n      }\\n      b\").concat(block.timestamp,\": bundle(id:\\\"1\\\", block: { number: \").concat(block.number,\" }) { \\n        bnbPrice\\n      }\\n    \");});};/**\n * Price data for token and bnb based on block number\n */var priceQueryConstructor=function priceQueryConstructor(subqueries){return gql(_templateObject||(_templateObject=_taggedTemplateLiteral([\"\\n    query tokenPriceData {\\n      \",\"\\n    }\\n  \"])),subqueries);};var fetchTokenPriceData=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(address,interval,startTimestamp){var endTimestamp,timestamps,time,blocks,prices,tokenPrices,formattedHistory,i;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:// Construct timestamps to query against\nendTimestamp=getUnixTime(new Date());timestamps=[];time=startTimestamp;while(time<=endTimestamp){timestamps.push(time);time+=interval;}_context.prev=4;_context.next=7;return getBlocksFromTimestamps(timestamps,'asc',500);case 7:blocks=_context.sent;if(!(!blocks||blocks.length===0)){_context.next=11;break;}console.error('Error fetching blocks for timestamps',timestamps);return _context.abrupt(\"return\",{error:false});case 11:_context.next=13;return multiQuery(priceQueryConstructor,getPriceSubqueries(address,blocks),INFO_CLIENT,200);case 13:prices=_context.sent;if(prices){_context.next=17;break;}console.error('Price data failed to load');return _context.abrupt(\"return\",{error:false});case 17:// format token BNB price results\ntokenPrices=[];// Get Token prices in BNB\nObject.keys(prices).forEach(function(priceKey){var timestamp=priceKey.split('t')[1];// if its BNB price e.g. `b123` split('t')[1] will be undefined and skip BNB price entry\nif(timestamp){var _prices$priceKey;tokenPrices.push({timestamp:timestamp,derivedBNB:((_prices$priceKey=prices[priceKey])===null||_prices$priceKey===void 0?void 0:_prices$priceKey.derivedBNB)?parseFloat(prices[priceKey].derivedBNB):0,priceUSD:0});}});// Go through BNB USD prices and calculate Token price based on it\nObject.keys(prices).forEach(function(priceKey){var timestamp=priceKey.split('b')[1];// if its Token price e.g. `t123` split('b')[1] will be undefined and skip Token price entry\nif(timestamp){var tokenPriceIndex=tokenPrices.findIndex(function(tokenPrice){return tokenPrice.timestamp===timestamp;});if(tokenPriceIndex>=0){var _prices$priceKey$bnbP,_prices$priceKey2;var derivedBNB=tokenPrices[tokenPriceIndex].derivedBNB;tokenPrices[tokenPriceIndex].priceUSD=parseFloat((_prices$priceKey$bnbP=(_prices$priceKey2=prices[priceKey])===null||_prices$priceKey2===void 0?void 0:_prices$priceKey2.bnbPrice)!==null&&_prices$priceKey$bnbP!==void 0?_prices$priceKey$bnbP:0)*derivedBNB;}}});// graphql-request does not guarantee same ordering of batched requests subqueries, hence sorting by timestamp from oldest to newest\ntokenPrices.sort(function(a,b){return parseInt(a.timestamp,10)-parseInt(b.timestamp,10);});formattedHistory=[];// for each timestamp, construct the open and close price\nfor(i=0;i<tokenPrices.length-1;i++){formattedHistory.push({time:parseFloat(tokenPrices[i].timestamp),open:tokenPrices[i].priceUSD,close:tokenPrices[i+1].priceUSD,high:tokenPrices[i+1].priceUSD,low:tokenPrices[i].priceUSD});}return _context.abrupt(\"return\",{data:formattedHistory,error:false});case 26:_context.prev=26;_context.t0=_context[\"catch\"](4);console.error(\"Failed to fetch price data for token \".concat(address),_context.t0);return _context.abrupt(\"return\",{error:true});case 30:case\"end\":return _context.stop();}}},_callee,null,[[4,26]]);}));return function fetchTokenPriceData(_x,_x2,_x3){return _ref.apply(this,arguments);};}();export default fetchTokenPriceData;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/info/queries/tokens/priceData.ts"],"names":["getUnixTime","gql","getBlocksFromTimestamps","multiQuery","INFO_CLIENT","getPriceSubqueries","tokenAddress","blocks","map","block","timestamp","number","priceQueryConstructor","subqueries","fetchTokenPriceData","address","interval","startTimestamp","endTimestamp","Date","timestamps","time","push","length","console","error","prices","tokenPrices","Object","keys","forEach","priceKey","split","derivedBNB","parseFloat","priceUSD","tokenPriceIndex","findIndex","tokenPrice","bnbPrice","sort","a","b","parseInt","formattedHistory","i","open","close","high","low","data"],"mappings":"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","sourcesContent":["import { getUnixTime } from 'date-fns'\nimport { gql } from 'graphql-request'\nimport { getBlocksFromTimestamps } from 'views/Info/hooks/useBlocksFromTimestamps'\nimport { multiQuery } from 'views/Info/utils/infoQueryHelpers'\nimport { PriceChartEntry } from 'state/info/types'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\n\nconst getPriceSubqueries = (tokenAddress: string, blocks: any) =>\n  blocks.map(\n    (block: any) => `\n      t${block.timestamp}:token(id:\"${tokenAddress}\", block: { number: ${block.number} }) { \n        derivedBNB\n      }\n      b${block.timestamp}: bundle(id:\"1\", block: { number: ${block.number} }) { \n        bnbPrice\n      }\n    `,\n  )\n\n/**\n * Price data for token and bnb based on block number\n */\nconst priceQueryConstructor = (subqueries: string[]) => {\n  return gql`\n    query tokenPriceData {\n      ${subqueries}\n    }\n  `\n}\n\nconst fetchTokenPriceData = async (\n  address: string,\n  interval: number,\n  startTimestamp: number,\n): Promise<{\n  data?: PriceChartEntry[]\n  error: boolean\n}> => {\n  // Construct timestamps to query against\n  const endTimestamp = getUnixTime(new Date())\n  const timestamps = []\n  let time = startTimestamp\n  while (time <= endTimestamp) {\n    timestamps.push(time)\n    time += interval\n  }\n  try {\n    const blocks = await getBlocksFromTimestamps(timestamps, 'asc', 500)\n    if (!blocks || blocks.length === 0) {\n      console.error('Error fetching blocks for timestamps', timestamps)\n      return {\n        error: false,\n      }\n    }\n\n    const prices: any | undefined = await multiQuery(\n      priceQueryConstructor,\n      getPriceSubqueries(address, blocks),\n      INFO_CLIENT,\n      200,\n    )\n\n    if (!prices) {\n      console.error('Price data failed to load')\n      return {\n        error: false,\n      }\n    }\n\n    // format token BNB price results\n    const tokenPrices: {\n      timestamp: string\n      derivedBNB: number\n      priceUSD: number\n    }[] = []\n\n    // Get Token prices in BNB\n    Object.keys(prices).forEach((priceKey) => {\n      const timestamp = priceKey.split('t')[1]\n      // if its BNB price e.g. `b123` split('t')[1] will be undefined and skip BNB price entry\n      if (timestamp) {\n        tokenPrices.push({\n          timestamp,\n          derivedBNB: prices[priceKey]?.derivedBNB ? parseFloat(prices[priceKey].derivedBNB) : 0,\n          priceUSD: 0,\n        })\n      }\n    })\n\n    // Go through BNB USD prices and calculate Token price based on it\n    Object.keys(prices).forEach((priceKey) => {\n      const timestamp = priceKey.split('b')[1]\n      // if its Token price e.g. `t123` split('b')[1] will be undefined and skip Token price entry\n      if (timestamp) {\n        const tokenPriceIndex = tokenPrices.findIndex((tokenPrice) => tokenPrice.timestamp === timestamp)\n        if (tokenPriceIndex >= 0) {\n          const { derivedBNB } = tokenPrices[tokenPriceIndex]\n          tokenPrices[tokenPriceIndex].priceUSD = parseFloat(prices[priceKey]?.bnbPrice ?? 0) * derivedBNB\n        }\n      }\n    })\n\n    // graphql-request does not guarantee same ordering of batched requests subqueries, hence sorting by timestamp from oldest to newest\n    tokenPrices.sort((a, b) => parseInt(a.timestamp, 10) - parseInt(b.timestamp, 10))\n\n    const formattedHistory = []\n\n    // for each timestamp, construct the open and close price\n    for (let i = 0; i < tokenPrices.length - 1; i++) {\n      formattedHistory.push({\n        time: parseFloat(tokenPrices[i].timestamp),\n        open: tokenPrices[i].priceUSD,\n        close: tokenPrices[i + 1].priceUSD,\n        high: tokenPrices[i + 1].priceUSD,\n        low: tokenPrices[i].priceUSD,\n      })\n    }\n\n    return { data: formattedHistory, error: false }\n  } catch (error) {\n    console.error(`Failed to fetch price data for token ${address}`, error)\n    return {\n      error: true,\n    }\n  }\n}\n\nexport default fetchTokenPriceData\n"]},"metadata":{},"sourceType":"module"}