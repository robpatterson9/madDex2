{"ast":null,"code":"import _toConsumableArray from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import{random}from'lodash';/**\n * Generate a specific number of unique, randomised 7-digit lottery numbers between 1000000 & 1999999\n */var generateTicketNumbers=function generateTicketNumbers(numberOfTickets,userCurrentTickets){var minNumber=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1000000;var maxNumber=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1999999;// Populate array with existing tickets (if they have them) to ensure no duplicates when generating new numbers\nvar existingTicketNumbers=(userCurrentTickets===null||userCurrentTickets===void 0?void 0:userCurrentTickets.length)>0?userCurrentTickets.map(function(ticket){return parseInt(ticket===null||ticket===void 0?void 0:ticket.number);}):[];var generatedTicketNumbers=_toConsumableArray(existingTicketNumbers);for(var count=0;count<numberOfTickets;count++){var randomNumber=random(minNumber,maxNumber);while(generatedTicketNumbers.includes(randomNumber)){// Catch for duplicates - generate a new number until the array doesn't include the random number generated\nrandomNumber=random(minNumber,maxNumber);}generatedTicketNumbers.push(randomNumber);}// Filter out the users' existing tickets\nvar ticketsToBuy=(userCurrentTickets===null||userCurrentTickets===void 0?void 0:userCurrentTickets.length)>0?generatedTicketNumbers.filter(function(ticketNumber){return!existingTicketNumbers.includes(ticketNumber);}):generatedTicketNumbers;return ticketsToBuy;};export default generateTicketNumbers;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/views/Lottery/components/BuyTicketsModal/generateTicketNumbers.tsx"],"names":["random","generateTicketNumbers","numberOfTickets","userCurrentTickets","minNumber","maxNumber","existingTicketNumbers","length","map","ticket","parseInt","number","generatedTicketNumbers","count","randomNumber","includes","push","ticketsToBuy","filter","ticketNumber"],"mappings":"gKACA,OAASA,MAAT,KAAuB,QAAvB,CAEA;AACA;AACA,GACA,GAAMC,CAAAA,qBAAqB,CAAG,QAAxBA,CAAAA,qBAAwB,CAC5BC,eAD4B,CAE5BC,kBAF4B,CAKf,IAFbC,CAAAA,SAEa,2DAFD,OAEC,IADbC,CAAAA,SACa,2DADD,OACC,CACb;AACA,GAAMC,CAAAA,qBAAqB,CACzB,CAAAH,kBAAkB,OAAlB,EAAAA,kBAAkB,SAAlB,QAAAA,kBAAkB,CAAEI,MAApB,EAA6B,CAA7B,CACIJ,kBAAkB,CAACK,GAAnB,CAAuB,SAACC,MAAD,CAAY,CACjC,MAAOC,CAAAA,QAAQ,CAACD,MAAD,SAACA,MAAD,iBAACA,MAAM,CAAEE,MAAT,CAAf,CACD,CAFD,CADJ,CAII,EALN,CAMA,GAAMC,CAAAA,sBAAsB,oBAAON,qBAAP,CAA5B,CAEA,IAAK,GAAIO,CAAAA,KAAK,CAAG,CAAjB,CAAoBA,KAAK,CAAGX,eAA5B,CAA6CW,KAAK,EAAlD,CAAsD,CACpD,GAAIC,CAAAA,YAAY,CAAGd,MAAM,CAACI,SAAD,CAAYC,SAAZ,CAAzB,CACA,MAAOO,sBAAsB,CAACG,QAAvB,CAAgCD,YAAhC,CAAP,CAAsD,CACpD;AACAA,YAAY,CAAGd,MAAM,CAACI,SAAD,CAAYC,SAAZ,CAArB,CACD,CACDO,sBAAsB,CAACI,IAAvB,CAA4BF,YAA5B,EACD,CAED;AACA,GAAMG,CAAAA,YAAY,CAChB,CAAAd,kBAAkB,OAAlB,EAAAA,kBAAkB,SAAlB,QAAAA,kBAAkB,CAAEI,MAApB,EAA6B,CAA7B,CACIK,sBAAsB,CAACM,MAAvB,CAA8B,SAACC,YAAD,CAAkB,CAC9C,MAAO,CAACb,qBAAqB,CAACS,QAAtB,CAA+BI,YAA/B,CAAR,CACD,CAFD,CADJ,CAIIP,sBALN,CAOA,MAAOK,CAAAA,YAAP,CACD,CAjCD,CAmCA,cAAehB,CAAAA,qBAAf","sourcesContent":["import { LotteryTicket } from 'config/constants/types'\nimport { random } from 'lodash'\n\n/**\n * Generate a specific number of unique, randomised 7-digit lottery numbers between 1000000 & 1999999\n */\nconst generateTicketNumbers = (\n  numberOfTickets: number,\n  userCurrentTickets?: LotteryTicket[],\n  minNumber = 1000000,\n  maxNumber = 1999999,\n): number[] => {\n  // Populate array with existing tickets (if they have them) to ensure no duplicates when generating new numbers\n  const existingTicketNumbers =\n    userCurrentTickets?.length > 0\n      ? userCurrentTickets.map((ticket) => {\n          return parseInt(ticket?.number)\n        })\n      : []\n  const generatedTicketNumbers = [...existingTicketNumbers]\n\n  for (let count = 0; count < numberOfTickets; count++) {\n    let randomNumber = random(minNumber, maxNumber)\n    while (generatedTicketNumbers.includes(randomNumber)) {\n      // Catch for duplicates - generate a new number until the array doesn't include the random number generated\n      randomNumber = random(minNumber, maxNumber)\n    }\n    generatedTicketNumbers.push(randomNumber)\n  }\n\n  // Filter out the users' existing tickets\n  const ticketsToBuy =\n    userCurrentTickets?.length > 0\n      ? generatedTicketNumbers.filter((ticketNumber) => {\n          return !existingTicketNumbers.includes(ticketNumber)\n        })\n      : generatedTicketNumbers\n\n  return ticketsToBuy\n}\n\nexport default generateTicketNumbers\n"]},"metadata":{},"sourceType":"module"}