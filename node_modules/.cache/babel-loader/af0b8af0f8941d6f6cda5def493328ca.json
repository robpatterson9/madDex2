{"ast":null,"code":"import _toConsumableArray from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _slicedToArray from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";/* eslint-disable no-param-reassign */import{isTradeBetter}from'utils/trades';import{Trade}from'@pancakeswap/sdk';import flatMap from'lodash/flatMap';import{useMemo}from'react';import useActiveWeb3React from'hooks/useActiveWeb3React';import{useUserSingleHopOnly}from'state/user/hooks';import{BASES_TO_CHECK_TRADES_AGAINST,CUSTOM_BASES,BETTER_TRADE_LESS_HOPS_THRESHOLD,ADDITIONAL_BASES}from'../config/constants';import{PairState,usePairs}from'./usePairs';import{wrappedCurrency}from'../utils/wrappedCurrency';import{useUnsupportedTokens}from'./Tokens';function useAllCommonPairs(currencyA,currencyB){var _useActiveWeb3React=useActiveWeb3React(),chainId=_useActiveWeb3React.chainId;var _ref=chainId?[wrappedCurrency(currencyA,chainId),wrappedCurrency(currencyB,chainId)]:[undefined,undefined],_ref2=_slicedToArray(_ref,2),tokenA=_ref2[0],tokenB=_ref2[1];var bases=useMemo(function(){var _BASES_TO_CHECK_TRADE,_ADDITIONAL_BASES$cha,_ADDITIONAL_BASES$cha2,_ADDITIONAL_BASES$cha3,_ADDITIONAL_BASES$cha4;if(!chainId)return[];var common=(_BASES_TO_CHECK_TRADE=BASES_TO_CHECK_TRADES_AGAINST[chainId])!==null&&_BASES_TO_CHECK_TRADE!==void 0?_BASES_TO_CHECK_TRADE:[];var additionalA=tokenA?(_ADDITIONAL_BASES$cha=(_ADDITIONAL_BASES$cha2=ADDITIONAL_BASES[chainId])===null||_ADDITIONAL_BASES$cha2===void 0?void 0:_ADDITIONAL_BASES$cha2[tokenA.address])!==null&&_ADDITIONAL_BASES$cha!==void 0?_ADDITIONAL_BASES$cha:[]:[];var additionalB=tokenB?(_ADDITIONAL_BASES$cha3=(_ADDITIONAL_BASES$cha4=ADDITIONAL_BASES[chainId])===null||_ADDITIONAL_BASES$cha4===void 0?void 0:_ADDITIONAL_BASES$cha4[tokenB.address])!==null&&_ADDITIONAL_BASES$cha3!==void 0?_ADDITIONAL_BASES$cha3:[]:[];return[].concat(_toConsumableArray(common),_toConsumableArray(additionalA),_toConsumableArray(additionalB));},[chainId,tokenA,tokenB]);var basePairs=useMemo(function(){return flatMap(bases,function(base){return bases.map(function(otherBase){return[base,otherBase];});});},[bases]);var allPairCombinations=useMemo(function(){return tokenA&&tokenB?[// the direct pair\n[tokenA,tokenB]].concat(_toConsumableArray(bases.map(function(base){return[tokenA,base];})),_toConsumableArray(bases.map(function(base){return[tokenB,base];})),_toConsumableArray(basePairs)).filter(function(tokens){return Boolean(tokens[0]&&tokens[1]);}).filter(function(_ref3){var _ref4=_slicedToArray(_ref3,2),t0=_ref4[0],t1=_ref4[1];return t0.address!==t1.address;}).filter(function(_ref5){var _ref6=_slicedToArray(_ref5,2),tokenA_=_ref6[0],tokenB_=_ref6[1];if(!chainId)return true;var customBases=CUSTOM_BASES[chainId];var customBasesA=customBases===null||customBases===void 0?void 0:customBases[tokenA_.address];var customBasesB=customBases===null||customBases===void 0?void 0:customBases[tokenB_.address];if(!customBasesA&&!customBasesB)return true;if(customBasesA&&!customBasesA.find(function(base){return tokenB_.equals(base);}))return false;if(customBasesB&&!customBasesB.find(function(base){return tokenA_.equals(base);}))return false;return true;}):[];},[tokenA,tokenB,bases,basePairs,chainId]);var allPairs=usePairs(allPairCombinations);// only pass along valid pairs, non-duplicated pairs\nreturn useMemo(function(){return Object.values(allPairs// filter out invalid pairs\n.filter(function(result){return Boolean(result[0]===PairState.EXISTS&&result[1]);})// filter out duplicated pairs\n.reduce(function(memo,_ref7){var _memo$curr$liquidityT;var _ref8=_slicedToArray(_ref7,2),curr=_ref8[1];memo[curr.liquidityToken.address]=(_memo$curr$liquidityT=memo[curr.liquidityToken.address])!==null&&_memo$curr$liquidityT!==void 0?_memo$curr$liquidityT:curr;return memo;},{}));},[allPairs]);}var MAX_HOPS=3;/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */export function useTradeExactIn(currencyAmountIn,currencyOut){var allowedPairs=useAllCommonPairs(currencyAmountIn===null||currencyAmountIn===void 0?void 0:currencyAmountIn.currency,currencyOut);var _useUserSingleHopOnly=useUserSingleHopOnly(),_useUserSingleHopOnly2=_slicedToArray(_useUserSingleHopOnly,1),singleHopOnly=_useUserSingleHopOnly2[0];return useMemo(function(){if(currencyAmountIn&&currencyOut&&allowedPairs.length>0){if(singleHopOnly){var _Trade$bestTradeExact;return(_Trade$bestTradeExact=Trade.bestTradeExactIn(allowedPairs,currencyAmountIn,currencyOut,{maxHops:1,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact!==void 0?_Trade$bestTradeExact:null;}// search through trades with varying hops, find best trade out of them\nvar bestTradeSoFar=null;for(var i=1;i<=MAX_HOPS;i++){var _Trade$bestTradeExact2;var currentTrade=(_Trade$bestTradeExact2=Trade.bestTradeExactIn(allowedPairs,currencyAmountIn,currencyOut,{maxHops:i,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact2!==void 0?_Trade$bestTradeExact2:null;// if current trade is best yet, save it\nif(isTradeBetter(bestTradeSoFar,currentTrade,BETTER_TRADE_LESS_HOPS_THRESHOLD)){bestTradeSoFar=currentTrade;}}return bestTradeSoFar;}return null;},[allowedPairs,currencyAmountIn,currencyOut,singleHopOnly]);}/**\n * Returns the best trade for the token in to the exact amount of token out\n */export function useTradeExactOut(currencyIn,currencyAmountOut){var allowedPairs=useAllCommonPairs(currencyIn,currencyAmountOut===null||currencyAmountOut===void 0?void 0:currencyAmountOut.currency);var _useUserSingleHopOnly3=useUserSingleHopOnly(),_useUserSingleHopOnly4=_slicedToArray(_useUserSingleHopOnly3,1),singleHopOnly=_useUserSingleHopOnly4[0];return useMemo(function(){if(currencyIn&&currencyAmountOut&&allowedPairs.length>0){if(singleHopOnly){var _Trade$bestTradeExact3;return(_Trade$bestTradeExact3=Trade.bestTradeExactOut(allowedPairs,currencyIn,currencyAmountOut,{maxHops:1,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact3!==void 0?_Trade$bestTradeExact3:null;}// search through trades with varying hops, find best trade out of them\nvar bestTradeSoFar=null;for(var i=1;i<=MAX_HOPS;i++){var _Trade$bestTradeExact4;var currentTrade=(_Trade$bestTradeExact4=Trade.bestTradeExactOut(allowedPairs,currencyIn,currencyAmountOut,{maxHops:i,maxNumResults:1})[0])!==null&&_Trade$bestTradeExact4!==void 0?_Trade$bestTradeExact4:null;if(isTradeBetter(bestTradeSoFar,currentTrade,BETTER_TRADE_LESS_HOPS_THRESHOLD)){bestTradeSoFar=currentTrade;}}return bestTradeSoFar;}return null;},[currencyIn,currencyAmountOut,allowedPairs,singleHopOnly]);}export function useIsTransactionUnsupported(currencyIn,currencyOut){var unsupportedTokens=useUnsupportedTokens();var _useActiveWeb3React2=useActiveWeb3React(),chainId=_useActiveWeb3React2.chainId;var tokenIn=wrappedCurrency(currencyIn,chainId);var tokenOut=wrappedCurrency(currencyOut,chainId);// if unsupported list loaded & either token on list, mark as unsupported\nif(unsupportedTokens){if(tokenIn&&Object.keys(unsupportedTokens).includes(tokenIn.address)){return true;}if(tokenOut&&Object.keys(unsupportedTokens).includes(tokenOut.address)){return true;}}return false;}","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/hooks/Trades.ts"],"names":["isTradeBetter","Trade","flatMap","useMemo","useActiveWeb3React","useUserSingleHopOnly","BASES_TO_CHECK_TRADES_AGAINST","CUSTOM_BASES","BETTER_TRADE_LESS_HOPS_THRESHOLD","ADDITIONAL_BASES","PairState","usePairs","wrappedCurrency","useUnsupportedTokens","useAllCommonPairs","currencyA","currencyB","chainId","undefined","tokenA","tokenB","bases","common","additionalA","address","additionalB","basePairs","base","map","otherBase","allPairCombinations","filter","tokens","Boolean","t0","t1","tokenA_","tokenB_","customBases","customBasesA","customBasesB","find","equals","allPairs","Object","values","result","EXISTS","reduce","memo","curr","liquidityToken","MAX_HOPS","useTradeExactIn","currencyAmountIn","currencyOut","allowedPairs","currency","singleHopOnly","length","bestTradeExactIn","maxHops","maxNumResults","bestTradeSoFar","i","currentTrade","useTradeExactOut","currencyIn","currencyAmountOut","bestTradeExactOut","useIsTransactionUnsupported","unsupportedTokens","tokenIn","tokenOut","keys","includes"],"mappings":"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","sourcesContent":["/* eslint-disable no-param-reassign */\nimport { isTradeBetter } from 'utils/trades'\nimport { Currency, CurrencyAmount, Pair, Token, Trade } from '@pancakeswap/sdk'\nimport flatMap from 'lodash/flatMap'\nimport { useMemo } from 'react'\nimport useActiveWeb3React from 'hooks/useActiveWeb3React'\n\nimport { useUserSingleHopOnly } from 'state/user/hooks'\nimport {\n  BASES_TO_CHECK_TRADES_AGAINST,\n  CUSTOM_BASES,\n  BETTER_TRADE_LESS_HOPS_THRESHOLD,\n  ADDITIONAL_BASES,\n} from '../config/constants'\nimport { PairState, usePairs } from './usePairs'\nimport { wrappedCurrency } from '../utils/wrappedCurrency'\n\nimport { useUnsupportedTokens } from './Tokens'\n\nfunction useAllCommonPairs(currencyA?: Currency, currencyB?: Currency): Pair[] {\n  const { chainId } = useActiveWeb3React()\n\n  const [tokenA, tokenB] = chainId\n    ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\n    : [undefined, undefined]\n\n  const bases: Token[] = useMemo(() => {\n    if (!chainId) return []\n\n    const common = BASES_TO_CHECK_TRADES_AGAINST[chainId] ?? []\n    const additionalA = tokenA ? ADDITIONAL_BASES[chainId]?.[tokenA.address] ?? [] : []\n    const additionalB = tokenB ? ADDITIONAL_BASES[chainId]?.[tokenB.address] ?? [] : []\n\n    return [...common, ...additionalA, ...additionalB]\n  }, [chainId, tokenA, tokenB])\n\n  const basePairs: [Token, Token][] = useMemo(\n    () => flatMap(bases, (base): [Token, Token][] => bases.map((otherBase) => [base, otherBase])),\n    [bases],\n  )\n\n  const allPairCombinations: [Token, Token][] = useMemo(\n    () =>\n      tokenA && tokenB\n        ? [\n            // the direct pair\n            [tokenA, tokenB],\n            // token A against all bases\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\n            // token B against all bases\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\n            // each base against all bases\n            ...basePairs,\n          ]\n            .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\n            .filter(([t0, t1]) => t0.address !== t1.address)\n            .filter(([tokenA_, tokenB_]) => {\n              if (!chainId) return true\n              const customBases = CUSTOM_BASES[chainId]\n\n              const customBasesA: Token[] | undefined = customBases?.[tokenA_.address]\n              const customBasesB: Token[] | undefined = customBases?.[tokenB_.address]\n\n              if (!customBasesA && !customBasesB) return true\n\n              if (customBasesA && !customBasesA.find((base) => tokenB_.equals(base))) return false\n              if (customBasesB && !customBasesB.find((base) => tokenA_.equals(base))) return false\n\n              return true\n            })\n        : [],\n    [tokenA, tokenB, bases, basePairs, chainId],\n  )\n\n  const allPairs = usePairs(allPairCombinations)\n\n  // only pass along valid pairs, non-duplicated pairs\n  return useMemo(\n    () =>\n      Object.values(\n        allPairs\n          // filter out invalid pairs\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\n          // filter out duplicated pairs\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr\n            return memo\n          }, {}),\n      ),\n    [allPairs],\n  )\n}\n\nconst MAX_HOPS = 3\n\n/**\n * Returns the best trade for the exact amount of tokens in to the given token out\n */\nexport function useTradeExactIn(currencyAmountIn?: CurrencyAmount, currencyOut?: Currency): Trade | null {\n  const allowedPairs = useAllCommonPairs(currencyAmountIn?.currency, currencyOut)\n\n  const [singleHopOnly] = useUserSingleHopOnly()\n\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        return (\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 1, maxNumResults: 1 })[0] ??\n          null\n        )\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: Trade | null = null\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        const currentTrade: Trade | null =\n          Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: i, maxNumResults: 1 })[0] ??\n          null\n        // if current trade is best yet, save it\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade\n        }\n      }\n      return bestTradeSoFar\n    }\n\n    return null\n  }, [allowedPairs, currencyAmountIn, currencyOut, singleHopOnly])\n}\n\n/**\n * Returns the best trade for the token in to the exact amount of token out\n */\nexport function useTradeExactOut(currencyIn?: Currency, currencyAmountOut?: CurrencyAmount): Trade | null {\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut?.currency)\n\n  const [singleHopOnly] = useUserSingleHopOnly()\n\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      if (singleHopOnly) {\n        return (\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 1, maxNumResults: 1 })[0] ??\n          null\n        )\n      }\n      // search through trades with varying hops, find best trade out of them\n      let bestTradeSoFar: Trade | null = null\n      for (let i = 1; i <= MAX_HOPS; i++) {\n        const currentTrade =\n          Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: i, maxNumResults: 1 })[0] ??\n          null\n        if (isTradeBetter(bestTradeSoFar, currentTrade, BETTER_TRADE_LESS_HOPS_THRESHOLD)) {\n          bestTradeSoFar = currentTrade\n        }\n      }\n      return bestTradeSoFar\n    }\n    return null\n  }, [currencyIn, currencyAmountOut, allowedPairs, singleHopOnly])\n}\n\nexport function useIsTransactionUnsupported(currencyIn?: Currency, currencyOut?: Currency): boolean {\n  const unsupportedTokens: { [address: string]: Token } = useUnsupportedTokens()\n  const { chainId } = useActiveWeb3React()\n\n  const tokenIn = wrappedCurrency(currencyIn, chainId)\n  const tokenOut = wrappedCurrency(currencyOut, chainId)\n\n  // if unsupported list loaded & either token on list, mark as unsupported\n  if (unsupportedTokens) {\n    if (tokenIn && Object.keys(unsupportedTokens).includes(tokenIn.address)) {\n      return true\n    }\n    if (tokenOut && Object.keys(unsupportedTokens).includes(tokenOut.address)) {\n      return true\n    }\n  }\n\n  return false\n}\n"]},"metadata":{},"sourceType":"module"}