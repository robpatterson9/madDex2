{"ast":null,"code":"import _regeneratorRuntime from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _toConsumableArray from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _asyncToGenerator from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _taggedTemplateLiteral from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";var _templateObject;import{request,gql}from'graphql-request';import{INFO_CLIENT}from'config/constants/endpoints';import{mapMints,mapBurns,mapSwaps}from'state/info/queries/helpers';/**\n * Data to display transaction table on Token page\n */var TOKEN_TRANSACTIONS=gql(_templateObject||(_templateObject=_taggedTemplateLiteral([\"\\n  query tokenTransactions($address: Bytes!) {\\n    mintsAs0: mints(first: 10, orderBy: timestamp, orderDirection: desc, where: { token0: $address }) {\\n      id\\n      timestamp\\n      pair {\\n        token0 {\\n          id\\n          symbol\\n        }\\n        token1 {\\n          id\\n          symbol\\n        }\\n      }\\n      to\\n      amount0\\n      amount1\\n      amountUSD\\n    }\\n    mintsAs1: mints(first: 10, orderBy: timestamp, orderDirection: desc, where: { token0: $address }) {\\n      id\\n      timestamp\\n      pair {\\n        token0 {\\n          id\\n          symbol\\n        }\\n        token1 {\\n          id\\n          symbol\\n        }\\n      }\\n      to\\n      amount0\\n      amount1\\n      amountUSD\\n    }\\n    swapsAs0: swaps(first: 10, orderBy: timestamp, orderDirection: desc, where: { token0: $address }) {\\n      id\\n      timestamp\\n      pair {\\n        token0 {\\n          id\\n          symbol\\n        }\\n        token1 {\\n          id\\n          symbol\\n        }\\n      }\\n      from\\n      amount0In\\n      amount1In\\n      amount0Out\\n      amount1Out\\n      amountUSD\\n    }\\n    swapsAs1: swaps(first: 10, orderBy: timestamp, orderDirection: desc, where: { token1: $address }) {\\n      id\\n      timestamp\\n      pair {\\n        token0 {\\n          id\\n          symbol\\n        }\\n        token1 {\\n          id\\n          symbol\\n        }\\n      }\\n      from\\n      amount0In\\n      amount1In\\n      amount0Out\\n      amount1Out\\n      amountUSD\\n    }\\n    burnsAs0: burns(first: 10, orderBy: timestamp, orderDirection: desc, where: { token0: $address }) {\\n      id\\n      timestamp\\n      pair {\\n        token0 {\\n          id\\n          symbol\\n        }\\n        token1 {\\n          id\\n          symbol\\n        }\\n      }\\n      sender\\n      amount0\\n      amount1\\n      amountUSD\\n    }\\n    burnsAs1: burns(first: 10, orderBy: timestamp, orderDirection: desc, where: { token1: $address }) {\\n      id\\n      timestamp\\n      pair {\\n        token0 {\\n          id\\n          symbol\\n        }\\n        token1 {\\n          id\\n          symbol\\n        }\\n      }\\n      sender\\n      amount0\\n      amount1\\n      amountUSD\\n    }\\n  }\\n\"])));var fetchTokenTransactions=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(address){var data,mints0,mints1,burns0,burns1,swaps0,swaps1;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.prev=0;_context.next=3;return request(INFO_CLIENT,TOKEN_TRANSACTIONS,{address:address});case 3:data=_context.sent;mints0=data.mintsAs0.map(mapMints);mints1=data.mintsAs1.map(mapMints);burns0=data.burnsAs0.map(mapBurns);burns1=data.burnsAs1.map(mapBurns);swaps0=data.swapsAs0.map(mapSwaps);swaps1=data.swapsAs1.map(mapSwaps);return _context.abrupt(\"return\",{data:[].concat(_toConsumableArray(mints0),_toConsumableArray(mints1),_toConsumableArray(burns0),_toConsumableArray(burns1),_toConsumableArray(swaps0),_toConsumableArray(swaps1)),error:false});case 13:_context.prev=13;_context.t0=_context[\"catch\"](0);console.error(\"Failed to fetch transactions for token \".concat(address),_context.t0);return _context.abrupt(\"return\",{error:true});case 17:case\"end\":return _context.stop();}}},_callee,null,[[0,13]]);}));return function fetchTokenTransactions(_x){return _ref.apply(this,arguments);};}();export default fetchTokenTransactions;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/info/queries/tokens/transactions.ts"],"names":["request","gql","INFO_CLIENT","mapMints","mapBurns","mapSwaps","TOKEN_TRANSACTIONS","fetchTokenTransactions","address","data","mints0","mintsAs0","map","mints1","mintsAs1","burns0","burnsAs0","burns1","burnsAs1","swaps0","swapsAs0","swaps1","swapsAs1","error","console"],"mappings":"yoBAAA,OAASA,OAAT,CAAkBC,GAAlB,KAA6B,iBAA7B,CACA,OAASC,WAAT,KAA4B,4BAA5B,CAGA,OAASC,QAAT,CAAmBC,QAAnB,CAA6BC,QAA7B,KAA6C,4BAA7C,CAEA;AACA;AACA,GACA,GAAMC,CAAAA,kBAAkB,CAAGL,GAAH,itEAAxB,CA8HA,GAAMM,CAAAA,sBAAsB,0FAAG,iBAAOC,OAAP,2MAERR,CAAAA,OAAO,CAAqBE,WAArB,CAAkCI,kBAAlC,CAAsD,CAC9EE,OAAO,CAAPA,OAD8E,CAAtD,CAFC,QAErBC,IAFqB,eAKrBC,MALqB,CAKZD,IAAI,CAACE,QAAL,CAAcC,GAAd,CAAkBT,QAAlB,CALY,CAMrBU,MANqB,CAMZJ,IAAI,CAACK,QAAL,CAAcF,GAAd,CAAkBT,QAAlB,CANY,CAQrBY,MARqB,CAQZN,IAAI,CAACO,QAAL,CAAcJ,GAAd,CAAkBR,QAAlB,CARY,CASrBa,MATqB,CASZR,IAAI,CAACS,QAAL,CAAcN,GAAd,CAAkBR,QAAlB,CATY,CAWrBe,MAXqB,CAWZV,IAAI,CAACW,QAAL,CAAcR,GAAd,CAAkBP,QAAlB,CAXY,CAYrBgB,MAZqB,CAYZZ,IAAI,CAACa,QAAL,CAAcV,GAAd,CAAkBP,QAAlB,CAZY,iCAcpB,CAAEI,IAAI,8BAAMC,MAAN,qBAAiBG,MAAjB,qBAA4BE,MAA5B,qBAAuCE,MAAvC,qBAAkDE,MAAlD,qBAA6DE,MAA7D,EAAN,CAA4EE,KAAK,CAAE,KAAnF,CAdoB,4DAgB3BC,OAAO,CAACD,KAAR,kDAAwDf,OAAxD,eAhB2B,gCAiBpB,CACLe,KAAK,CAAE,IADF,CAjBoB,uEAAH,kBAAtBhB,CAAAA,sBAAsB,4CAA5B,CAuBA,cAAeA,CAAAA,sBAAf","sourcesContent":["import { request, gql } from 'graphql-request'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\nimport { Transaction } from 'state/info/types'\nimport { MintResponse, SwapResponse, BurnResponse } from 'state/info/queries/types'\nimport { mapMints, mapBurns, mapSwaps } from 'state/info/queries/helpers'\n\n/**\n * Data to display transaction table on Token page\n */\nconst TOKEN_TRANSACTIONS = gql`\n  query tokenTransactions($address: Bytes!) {\n    mintsAs0: mints(first: 10, orderBy: timestamp, orderDirection: desc, where: { token0: $address }) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      to\n      amount0\n      amount1\n      amountUSD\n    }\n    mintsAs1: mints(first: 10, orderBy: timestamp, orderDirection: desc, where: { token0: $address }) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      to\n      amount0\n      amount1\n      amountUSD\n    }\n    swapsAs0: swaps(first: 10, orderBy: timestamp, orderDirection: desc, where: { token0: $address }) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      from\n      amount0In\n      amount1In\n      amount0Out\n      amount1Out\n      amountUSD\n    }\n    swapsAs1: swaps(first: 10, orderBy: timestamp, orderDirection: desc, where: { token1: $address }) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      from\n      amount0In\n      amount1In\n      amount0Out\n      amount1Out\n      amountUSD\n    }\n    burnsAs0: burns(first: 10, orderBy: timestamp, orderDirection: desc, where: { token0: $address }) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      sender\n      amount0\n      amount1\n      amountUSD\n    }\n    burnsAs1: burns(first: 10, orderBy: timestamp, orderDirection: desc, where: { token1: $address }) {\n      id\n      timestamp\n      pair {\n        token0 {\n          id\n          symbol\n        }\n        token1 {\n          id\n          symbol\n        }\n      }\n      sender\n      amount0\n      amount1\n      amountUSD\n    }\n  }\n`\n\ninterface TransactionResults {\n  mintsAs0: MintResponse[]\n  mintsAs1: MintResponse[]\n  swapsAs0: SwapResponse[]\n  swapsAs1: SwapResponse[]\n  burnsAs0: BurnResponse[]\n  burnsAs1: BurnResponse[]\n}\n\nconst fetchTokenTransactions = async (address: string): Promise<{ data?: Transaction[]; error: boolean }> => {\n  try {\n    const data = await request<TransactionResults>(INFO_CLIENT, TOKEN_TRANSACTIONS, {\n      address,\n    })\n    const mints0 = data.mintsAs0.map(mapMints)\n    const mints1 = data.mintsAs1.map(mapMints)\n\n    const burns0 = data.burnsAs0.map(mapBurns)\n    const burns1 = data.burnsAs1.map(mapBurns)\n\n    const swaps0 = data.swapsAs0.map(mapSwaps)\n    const swaps1 = data.swapsAs1.map(mapSwaps)\n\n    return { data: [...mints0, ...mints1, ...burns0, ...burns1, ...swaps0, ...swaps1], error: false }\n  } catch (error) {\n    console.error(`Failed to fetch transactions for token ${address}`, error)\n    return {\n      error: true,\n    }\n  }\n}\n\nexport default fetchTokenTransactions\n"]},"metadata":{},"sourceType":"module"}