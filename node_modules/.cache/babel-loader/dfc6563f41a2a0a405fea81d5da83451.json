{"ast":null,"code":"import { getUnixTime } from 'date-fns';\nimport { gql } from 'graphql-request';\nimport { getBlocksFromTimestamps } from 'views/Info/hooks/useBlocksFromTimestamps';\nimport { multiQuery } from 'views/Info/utils/infoQueryHelpers';\nimport { INFO_CLIENT } from 'config/constants/endpoints';\n\nconst getPriceSubqueries = (tokenAddress, blocks) => blocks.map(block => `\n      t${block.timestamp}:token(id:\"${tokenAddress}\", block: { number: ${block.number} }) { \n        derivedBNB\n      }\n      b${block.timestamp}: bundle(id:\"1\", block: { number: ${block.number} }) { \n        bnbPrice\n      }\n    `);\n/**\n * Price data for token and bnb based on block number\n */\n\n\nconst priceQueryConstructor = subqueries => {\n  return gql`\n    query tokenPriceData {\n      ${subqueries}\n    }\n  `;\n};\n\nconst fetchTokenPriceData = async (address, interval, startTimestamp) => {\n  // Construct timestamps to query against\n  const endTimestamp = getUnixTime(new Date());\n  const timestamps = [];\n  let time = startTimestamp;\n\n  while (time <= endTimestamp) {\n    timestamps.push(time);\n    time += interval;\n  }\n\n  try {\n    const blocks = await getBlocksFromTimestamps(timestamps, 'asc', 500);\n\n    if (!blocks || blocks.length === 0) {\n      console.error('Error fetching blocks for timestamps', timestamps);\n      return {\n        error: false\n      };\n    }\n\n    const prices = await multiQuery(priceQueryConstructor, getPriceSubqueries(address, blocks), INFO_CLIENT, 200);\n\n    if (!prices) {\n      console.error('Price data failed to load');\n      return {\n        error: false\n      };\n    } // format token BNB price results\n\n\n    const tokenPrices = []; // Get Token prices in BNB\n\n    Object.keys(prices).forEach(priceKey => {\n      const timestamp = priceKey.split('t')[1]; // if its BNB price e.g. `b123` split('t')[1] will be undefined and skip BNB price entry\n\n      if (timestamp) {\n        var _prices$priceKey;\n\n        tokenPrices.push({\n          timestamp,\n          derivedBNB: ((_prices$priceKey = prices[priceKey]) === null || _prices$priceKey === void 0 ? void 0 : _prices$priceKey.derivedBNB) ? parseFloat(prices[priceKey].derivedBNB) : 0,\n          priceUSD: 0\n        });\n      }\n    }); // Go through BNB USD prices and calculate Token price based on it\n\n    Object.keys(prices).forEach(priceKey => {\n      const timestamp = priceKey.split('b')[1]; // if its Token price e.g. `t123` split('b')[1] will be undefined and skip Token price entry\n\n      if (timestamp) {\n        const tokenPriceIndex = tokenPrices.findIndex(tokenPrice => tokenPrice.timestamp === timestamp);\n\n        if (tokenPriceIndex >= 0) {\n          var _prices$priceKey$bnbP, _prices$priceKey2;\n\n          const {\n            derivedBNB\n          } = tokenPrices[tokenPriceIndex];\n          tokenPrices[tokenPriceIndex].priceUSD = parseFloat((_prices$priceKey$bnbP = (_prices$priceKey2 = prices[priceKey]) === null || _prices$priceKey2 === void 0 ? void 0 : _prices$priceKey2.bnbPrice) !== null && _prices$priceKey$bnbP !== void 0 ? _prices$priceKey$bnbP : 0) * derivedBNB;\n        }\n      }\n    }); // graphql-request does not guarantee same ordering of batched requests subqueries, hence sorting by timestamp from oldest to newest\n\n    tokenPrices.sort((a, b) => parseInt(a.timestamp, 10) - parseInt(b.timestamp, 10));\n    const formattedHistory = []; // for each timestamp, construct the open and close price\n\n    for (let i = 0; i < tokenPrices.length - 1; i++) {\n      formattedHistory.push({\n        time: parseFloat(tokenPrices[i].timestamp),\n        open: tokenPrices[i].priceUSD,\n        close: tokenPrices[i + 1].priceUSD,\n        high: tokenPrices[i + 1].priceUSD,\n        low: tokenPrices[i].priceUSD\n      });\n    }\n\n    return {\n      data: formattedHistory,\n      error: false\n    };\n  } catch (error) {\n    console.error(`Failed to fetch price data for token ${address}`, error);\n    return {\n      error: true\n    };\n  }\n};\n\nexport default fetchTokenPriceData;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/info/queries/tokens/priceData.ts"],"names":["getUnixTime","gql","getBlocksFromTimestamps","multiQuery","INFO_CLIENT","getPriceSubqueries","tokenAddress","blocks","map","block","timestamp","number","priceQueryConstructor","subqueries","fetchTokenPriceData","address","interval","startTimestamp","endTimestamp","Date","timestamps","time","push","length","console","error","prices","tokenPrices","Object","keys","forEach","priceKey","split","derivedBNB","parseFloat","priceUSD","tokenPriceIndex","findIndex","tokenPrice","bnbPrice","sort","a","b","parseInt","formattedHistory","i","open","close","high","low","data"],"mappings":"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","sourcesContent":["import { getUnixTime } from 'date-fns'\nimport { gql } from 'graphql-request'\nimport { getBlocksFromTimestamps } from 'views/Info/hooks/useBlocksFromTimestamps'\nimport { multiQuery } from 'views/Info/utils/infoQueryHelpers'\nimport { PriceChartEntry } from 'state/info/types'\nimport { INFO_CLIENT } from 'config/constants/endpoints'\n\nconst getPriceSubqueries = (tokenAddress: string, blocks: any) =>\n  blocks.map(\n    (block: any) => `\n      t${block.timestamp}:token(id:\"${tokenAddress}\", block: { number: ${block.number} }) { \n        derivedBNB\n      }\n      b${block.timestamp}: bundle(id:\"1\", block: { number: ${block.number} }) { \n        bnbPrice\n      }\n    `,\n  )\n\n/**\n * Price data for token and bnb based on block number\n */\nconst priceQueryConstructor = (subqueries: string[]) => {\n  return gql`\n    query tokenPriceData {\n      ${subqueries}\n    }\n  `\n}\n\nconst fetchTokenPriceData = async (\n  address: string,\n  interval: number,\n  startTimestamp: number,\n): Promise<{\n  data?: PriceChartEntry[]\n  error: boolean\n}> => {\n  // Construct timestamps to query against\n  const endTimestamp = getUnixTime(new Date())\n  const timestamps = []\n  let time = startTimestamp\n  while (time <= endTimestamp) {\n    timestamps.push(time)\n    time += interval\n  }\n  try {\n    const blocks = await getBlocksFromTimestamps(timestamps, 'asc', 500)\n    if (!blocks || blocks.length === 0) {\n      console.error('Error fetching blocks for timestamps', timestamps)\n      return {\n        error: false,\n      }\n    }\n\n    const prices: any | undefined = await multiQuery(\n      priceQueryConstructor,\n      getPriceSubqueries(address, blocks),\n      INFO_CLIENT,\n      200,\n    )\n\n    if (!prices) {\n      console.error('Price data failed to load')\n      return {\n        error: false,\n      }\n    }\n\n    // format token BNB price results\n    const tokenPrices: {\n      timestamp: string\n      derivedBNB: number\n      priceUSD: number\n    }[] = []\n\n    // Get Token prices in BNB\n    Object.keys(prices).forEach((priceKey) => {\n      const timestamp = priceKey.split('t')[1]\n      // if its BNB price e.g. `b123` split('t')[1] will be undefined and skip BNB price entry\n      if (timestamp) {\n        tokenPrices.push({\n          timestamp,\n          derivedBNB: prices[priceKey]?.derivedBNB ? parseFloat(prices[priceKey].derivedBNB) : 0,\n          priceUSD: 0,\n        })\n      }\n    })\n\n    // Go through BNB USD prices and calculate Token price based on it\n    Object.keys(prices).forEach((priceKey) => {\n      const timestamp = priceKey.split('b')[1]\n      // if its Token price e.g. `t123` split('b')[1] will be undefined and skip Token price entry\n      if (timestamp) {\n        const tokenPriceIndex = tokenPrices.findIndex((tokenPrice) => tokenPrice.timestamp === timestamp)\n        if (tokenPriceIndex >= 0) {\n          const { derivedBNB } = tokenPrices[tokenPriceIndex]\n          tokenPrices[tokenPriceIndex].priceUSD = parseFloat(prices[priceKey]?.bnbPrice ?? 0) * derivedBNB\n        }\n      }\n    })\n\n    // graphql-request does not guarantee same ordering of batched requests subqueries, hence sorting by timestamp from oldest to newest\n    tokenPrices.sort((a, b) => parseInt(a.timestamp, 10) - parseInt(b.timestamp, 10))\n\n    const formattedHistory = []\n\n    // for each timestamp, construct the open and close price\n    for (let i = 0; i < tokenPrices.length - 1; i++) {\n      formattedHistory.push({\n        time: parseFloat(tokenPrices[i].timestamp),\n        open: tokenPrices[i].priceUSD,\n        close: tokenPrices[i + 1].priceUSD,\n        high: tokenPrices[i + 1].priceUSD,\n        low: tokenPrices[i].priceUSD,\n      })\n    }\n\n    return { data: formattedHistory, error: false }\n  } catch (error) {\n    console.error(`Failed to fetch price data for token ${address}`, error)\n    return {\n      error: true,\n    }\n  }\n}\n\nexport default fetchTokenPriceData\n"]},"metadata":{},"sourceType":"module"}