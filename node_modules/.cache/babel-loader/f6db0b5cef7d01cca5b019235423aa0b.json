{"ast":null,"code":"import _regeneratorRuntime from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useState,useEffect}from'react';import{getAllPancakeBunniesLowestPrice,getAllPancakeBunniesRecentUpdatedAt,getNftsFromCollectionApi}from'state/nftMarket/helpers';import{pancakeBunniesAddress}from'../constants';// If collection is PancakeBunnies - gets all available bunnies, otherwise - null\nvar useAllPancakeBunnyNfts=function useAllPancakeBunnyNfts(collectionAddress){var _useState=useState(null),_useState2=_slicedToArray(_useState,2),allPancakeBunnyNfts=_useState2[0],setAllPancakeBunnyNfts=_useState2[1];var isPBCollection=collectionAddress===pancakeBunniesAddress;useEffect(function(){var fetchPancakeBunnies=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var _yield$getNftsFromCol,data,bunnyIds,lowestPrices,latestUpdates,allBunnies;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.next=2;return getNftsFromCollectionApi(pancakeBunniesAddress);case 2:_yield$getNftsFromCol=_context.sent;data=_yield$getNftsFromCol.data;bunnyIds=Object.keys(data);_context.next=7;return getAllPancakeBunniesLowestPrice(bunnyIds);case 7:lowestPrices=_context.sent;_context.next=10;return getAllPancakeBunniesRecentUpdatedAt(bunnyIds);case 10:latestUpdates=_context.sent;allBunnies=bunnyIds.map(function(bunnyId){return{// tokenId here is just a dummy one to satisfy TS. TokenID does not play any role in gird display below\ntokenId:data[bunnyId].name,name:data[bunnyId].name,description:data[bunnyId].description,collectionAddress:pancakeBunniesAddress,collectionName:data[bunnyId].collection.name,image:data[bunnyId].image,attributes:[{traitType:'bunnyId',value:bunnyId,displayType:null}],meta:{currentAskPrice:lowestPrices[bunnyId],updatedAt:latestUpdates[bunnyId]}};});setAllPancakeBunnyNfts(allBunnies);case 13:case\"end\":return _context.stop();}}},_callee);}));return function fetchPancakeBunnies(){return _ref.apply(this,arguments);};}();if(isPBCollection&&!allPancakeBunnyNfts){fetchPancakeBunnies();}},[isPBCollection,allPancakeBunnyNfts]);return allPancakeBunnyNfts;};export default useAllPancakeBunnyNfts;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/views/Nft/market/hooks/useAllPancakeBunnyNfts.ts"],"names":["useState","useEffect","getAllPancakeBunniesLowestPrice","getAllPancakeBunniesRecentUpdatedAt","getNftsFromCollectionApi","pancakeBunniesAddress","useAllPancakeBunnyNfts","collectionAddress","allPancakeBunnyNfts","setAllPancakeBunnyNfts","isPBCollection","fetchPancakeBunnies","data","bunnyIds","Object","keys","lowestPrices","latestUpdates","allBunnies","map","bunnyId","tokenId","name","description","collectionName","collection","image","attributes","traitType","value","displayType","meta","currentAskPrice","updatedAt"],"mappings":"qcAAA,OAASA,QAAT,CAAmBC,SAAnB,KAAoC,OAApC,CACA,OACEC,+BADF,CAEEC,mCAFF,CAGEC,wBAHF,KAIO,yBAJP,CAMA,OAASC,qBAAT,KAAsC,cAAtC,CAEA;AACA,GAAMC,CAAAA,sBAAsB,CAAG,QAAzBA,CAAAA,sBAAyB,CAACC,iBAAD,CAA+B,CAC5D,cAAsDP,QAAQ,CAAa,IAAb,CAA9D,wCAAOQ,mBAAP,eAA4BC,sBAA5B,eAEA,GAAMC,CAAAA,cAAc,CAAGH,iBAAiB,GAAKF,qBAA7C,CAEAJ,SAAS,CAAC,UAAM,CACd,GAAMU,CAAAA,mBAAmB,0FAAG,uOAKHP,CAAAA,wBAAwB,CAACC,qBAAD,CALrB,4CAKlBO,IALkB,uBAKlBA,IALkB,CAMpBC,QANoB,CAMTC,MAAM,CAACC,IAAP,CAAYH,IAAZ,CANS,uBAOCV,CAAAA,+BAA+B,CAACW,QAAD,CAPhC,QAOpBG,YAPoB,sCAQEb,CAAAA,mCAAmC,CAACU,QAAD,CARrC,SAQpBI,aARoB,eASpBC,UAToB,CASKL,QAAQ,CAACM,GAAT,CAAa,SAACC,OAAD,CAAa,CACvD,MAAO,CACL;AACAC,OAAO,CAAET,IAAI,CAACQ,OAAD,CAAJ,CAAcE,IAFlB,CAGLA,IAAI,CAAEV,IAAI,CAACQ,OAAD,CAAJ,CAAcE,IAHf,CAILC,WAAW,CAAEX,IAAI,CAACQ,OAAD,CAAJ,CAAcG,WAJtB,CAKLhB,iBAAiB,CAAEF,qBALd,CAMLmB,cAAc,CAAEZ,IAAI,CAACQ,OAAD,CAAJ,CAAcK,UAAd,CAAyBH,IANpC,CAOLI,KAAK,CAAEd,IAAI,CAACQ,OAAD,CAAJ,CAAcM,KAPhB,CAQLC,UAAU,CAAE,CACV,CACEC,SAAS,CAAE,SADb,CAEEC,KAAK,CAAET,OAFT,CAGEU,WAAW,CAAE,IAHf,CADU,CARP,CAeLC,IAAI,CAAE,CACJC,eAAe,CAAEhB,YAAY,CAACI,OAAD,CADzB,CAEJa,SAAS,CAAEhB,aAAa,CAACG,OAAD,CAFpB,CAfD,CAAP,CAoBD,CArB8B,CATL,CA+B1BX,sBAAsB,CAACS,UAAD,CAAtB,CA/B0B,uDAAH,kBAAnBP,CAAAA,mBAAmB,0CAAzB,CAiCA,GAAID,cAAc,EAAI,CAACF,mBAAvB,CAA4C,CAC1CG,mBAAmB,GACpB,CACF,CArCQ,CAqCN,CAACD,cAAD,CAAiBF,mBAAjB,CArCM,CAAT,CAuCA,MAAOA,CAAAA,mBAAP,CACD,CA7CD,CA+CA,cAAeF,CAAAA,sBAAf","sourcesContent":["import { useState, useEffect } from 'react'\nimport {\n  getAllPancakeBunniesLowestPrice,\n  getAllPancakeBunniesRecentUpdatedAt,\n  getNftsFromCollectionApi,\n} from 'state/nftMarket/helpers'\nimport { NftToken } from 'state/nftMarket/types'\nimport { pancakeBunniesAddress } from '../constants'\n\n// If collection is PancakeBunnies - gets all available bunnies, otherwise - null\nconst useAllPancakeBunnyNfts = (collectionAddress: string) => {\n  const [allPancakeBunnyNfts, setAllPancakeBunnyNfts] = useState<NftToken[]>(null)\n\n  const isPBCollection = collectionAddress === pancakeBunniesAddress\n\n  useEffect(() => {\n    const fetchPancakeBunnies = async () => {\n      // In order to not define special TS type just for PancakeBunnies display we're hacking a little bit into NftToken type.\n      // On this page we just want to display all bunnies with their lowest prices and updates on the market\n      // Since some bunnies might not be on the market at all, we don't refer to the redux nfts state (which stores NftToken with actual token ids)\n      // We merely request from API all available bunny ids with their metadata and query subgraph for lowest price and latest updates.\n      const { data } = await getNftsFromCollectionApi(pancakeBunniesAddress)\n      const bunnyIds = Object.keys(data)\n      const lowestPrices = await getAllPancakeBunniesLowestPrice(bunnyIds)\n      const latestUpdates = await getAllPancakeBunniesRecentUpdatedAt(bunnyIds)\n      const allBunnies: NftToken[] = bunnyIds.map((bunnyId) => {\n        return {\n          // tokenId here is just a dummy one to satisfy TS. TokenID does not play any role in gird display below\n          tokenId: data[bunnyId].name,\n          name: data[bunnyId].name,\n          description: data[bunnyId].description,\n          collectionAddress: pancakeBunniesAddress,\n          collectionName: data[bunnyId].collection.name,\n          image: data[bunnyId].image,\n          attributes: [\n            {\n              traitType: 'bunnyId',\n              value: bunnyId,\n              displayType: null,\n            },\n          ],\n          meta: {\n            currentAskPrice: lowestPrices[bunnyId],\n            updatedAt: latestUpdates[bunnyId],\n          },\n        }\n      })\n      setAllPancakeBunnyNfts(allBunnies)\n    }\n    if (isPBCollection && !allPancakeBunnyNfts) {\n      fetchPancakeBunnies()\n    }\n  }, [isPBCollection, allPancakeBunnyNfts])\n\n  return allPancakeBunnyNfts\n}\n\nexport default useAllPancakeBunnyNfts\n"]},"metadata":{},"sourceType":"module"}