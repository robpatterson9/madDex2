{"ast":null,"code":"import{useEffect,useMemo}from'react';import{useSelector}from'react-redux';import{useAppDispatch}from'state';import{pancakeBunniesAddress}from'views/Nft/market/constants';import{isAddress}from'utils';import useRefresh from'hooks/useRefresh';import{fetchCollections,fetchNftsByBunnyId,fetchNftsFromCollections,updateNftTokensData}from'./reducer';export var useFetchCollections=function useFetchCollections(){var dispatch=useAppDispatch();useEffect(function(){dispatch(fetchCollections());dispatch(fetchNftsFromCollections(pancakeBunniesAddress));},[dispatch]);};// Returns a function that fetches more NFTs when called and puts them into redux state.\n// Also returns loading flag and time of latest successful fetch\nexport var useFetchByBunnyId=function useFetchByBunnyId(bunnyId){var dispatch=useAppDispatch();var isFetchingMoreNfts=useSelector(function(state){return state.nftMarket.data.isFetchingMoreNfts;});var latestFetchAt=useSelector(function(state){return state.nftMarket.data.latestFetchAt;});// Extra guard in case market data shifts\n// we don't wanna fetch same tokens multiple times\nvar existingBunniesInState=useGetAllBunniesByBunnyId(bunnyId);var existingTokenIds=existingBunniesInState?existingBunniesInState.map(function(nft){return nft.tokenId;}):[];var firstBunny=existingBunniesInState.length>0?existingBunniesInState[0]:null;// If we already have NFT with this bunny id in state - we can reuse its metadata without making API request\nvar existingMetadata=useMemo(function(){return firstBunny?{name:firstBunny.name,description:firstBunny.description,collection:{name:firstBunny.collectionName},image:firstBunny.image}:null;},[firstBunny]);var fetchMorePancakeBunnies=function fetchMorePancakeBunnies(orderDirection){dispatch(fetchNftsByBunnyId({bunnyId:bunnyId,existingTokenIds:existingTokenIds,existingMetadata:existingMetadata,orderDirection:orderDirection}));};return{isFetchingMoreNfts:isFetchingMoreNfts,latestFetchAt:latestFetchAt,fetchMorePancakeBunnies:fetchMorePancakeBunnies};};// This hook gets all token ids stored in redux and periodically checks subgraph in case the data we have is staled\n// e.g. NFT gets sold - must be changed form isTradable: true to isTradable: false\nexport var useUpdateNftInfo=function useUpdateNftInfo(collectionAddress){var dispatch=useAppDispatch();var _useRefresh=useRefresh(),fastRefresh=_useRefresh.fastRefresh;var lastUpdateAt=useSelector(function(state){return state.nftMarket.data.lastUpdateAt;});var isFetchingMoreNfts=useSelector(function(state){return state.nftMarket.data.isFetchingMoreNfts;});var existingNfts=useNftsFromCollection(collectionAddress);useEffect(function(){var msSinceLastUpdate=Date.now()-lastUpdateAt;var existingTokenIds=existingNfts?existingNfts.map(function(nft){return nft.tokenId;}):[];if(msSinceLastUpdate>10000&&!isFetchingMoreNfts){dispatch(updateNftTokensData({collectionAddress:collectionAddress,existingTokenIds:existingTokenIds}));}},[dispatch,fastRefresh,collectionAddress,existingNfts,lastUpdateAt,isFetchingMoreNfts]);};export var useGetCollections=function useGetCollections(){return useSelector(function(state){return state.nftMarket.data.collections;});};export var useGetCollection=function useGetCollection(collectionAddress){var checksummedCollectionAddress=isAddress(collectionAddress)||'';var collections=useGetCollections();return collections[checksummedCollectionAddress];};export var useNftsFromCollection=function useNftsFromCollection(collectionAddress){var checksummedCollectionAddress=isAddress(collectionAddress)||'';var nfts=useSelector(function(state){return state.nftMarket.data.nfts[checksummedCollectionAddress];});return nfts;};export var useGetAllBunniesByBunnyId=function useGetAllBunniesByBunnyId(bunnyId){var nfts=useSelector(function(state){return state.nftMarket.data.nfts[pancakeBunniesAddress];});return nfts?nfts.filter(function(nft){return nft.attributes[0].value===bunnyId&&nft.marketData.isTradable;}):[];};export var useGetNFTInitializationState=function useGetNFTInitializationState(){return useSelector(function(state){return state.nftMarket.initializationState;});};export var useUserNfts=function useUserNfts(){return useSelector(function(state){return state.nftMarket.data.user;});};","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/nftMarket/hooks.ts"],"names":["useEffect","useMemo","useSelector","useAppDispatch","pancakeBunniesAddress","isAddress","useRefresh","fetchCollections","fetchNftsByBunnyId","fetchNftsFromCollections","updateNftTokensData","useFetchCollections","dispatch","useFetchByBunnyId","bunnyId","isFetchingMoreNfts","state","nftMarket","data","latestFetchAt","existingBunniesInState","useGetAllBunniesByBunnyId","existingTokenIds","map","nft","tokenId","firstBunny","length","existingMetadata","name","description","collection","collectionName","image","fetchMorePancakeBunnies","orderDirection","useUpdateNftInfo","collectionAddress","fastRefresh","lastUpdateAt","existingNfts","useNftsFromCollection","msSinceLastUpdate","Date","now","useGetCollections","collections","useGetCollection","checksummedCollectionAddress","nfts","filter","attributes","value","marketData","isTradable","useGetNFTInitializationState","initializationState","useUserNfts","user"],"mappings":"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","sourcesContent":["import { useEffect, useMemo } from 'react'\nimport { useSelector } from 'react-redux'\nimport { useAppDispatch } from 'state'\nimport { pancakeBunniesAddress } from 'views/Nft/market/constants'\nimport { isAddress } from 'utils'\nimport useRefresh from 'hooks/useRefresh'\nimport { fetchCollections, fetchNftsByBunnyId, fetchNftsFromCollections, updateNftTokensData } from './reducer'\nimport { State } from '../types'\nimport { NftToken, UserNftsState } from './types'\n\nexport const useFetchCollections = () => {\n  const dispatch = useAppDispatch()\n  useEffect(() => {\n    dispatch(fetchCollections())\n    dispatch(fetchNftsFromCollections(pancakeBunniesAddress))\n  }, [dispatch])\n}\n\n// Returns a function that fetches more NFTs when called and puts them into redux state.\n// Also returns loading flag and time of latest successful fetch\nexport const useFetchByBunnyId = (bunnyId: string) => {\n  const dispatch = useAppDispatch()\n\n  const isFetchingMoreNfts = useSelector((state: State) => state.nftMarket.data.isFetchingMoreNfts)\n  const latestFetchAt = useSelector((state: State) => state.nftMarket.data.latestFetchAt)\n\n  // Extra guard in case market data shifts\n  // we don't wanna fetch same tokens multiple times\n  const existingBunniesInState = useGetAllBunniesByBunnyId(bunnyId)\n  const existingTokenIds = existingBunniesInState ? existingBunniesInState.map((nft) => nft.tokenId) : []\n\n  const firstBunny = existingBunniesInState.length > 0 ? existingBunniesInState[0] : null\n\n  // If we already have NFT with this bunny id in state - we can reuse its metadata without making API request\n  const existingMetadata = useMemo(() => {\n    return firstBunny\n      ? {\n          name: firstBunny.name,\n          description: firstBunny.description,\n          collection: { name: firstBunny.collectionName },\n          image: firstBunny.image,\n        }\n      : null\n  }, [firstBunny])\n\n  const fetchMorePancakeBunnies = (orderDirection: 'asc' | 'desc') => {\n    dispatch(fetchNftsByBunnyId({ bunnyId, existingTokenIds, existingMetadata, orderDirection }))\n  }\n  return { isFetchingMoreNfts, latestFetchAt, fetchMorePancakeBunnies }\n}\n\n// This hook gets all token ids stored in redux and periodically checks subgraph in case the data we have is staled\n// e.g. NFT gets sold - must be changed form isTradable: true to isTradable: false\nexport const useUpdateNftInfo = (collectionAddress: string) => {\n  const dispatch = useAppDispatch()\n  const { fastRefresh } = useRefresh()\n\n  const lastUpdateAt = useSelector((state: State) => state.nftMarket.data.lastUpdateAt)\n  const isFetchingMoreNfts = useSelector((state: State) => state.nftMarket.data.isFetchingMoreNfts)\n\n  const existingNfts = useNftsFromCollection(collectionAddress)\n\n  useEffect(() => {\n    const msSinceLastUpdate = Date.now() - lastUpdateAt\n    const existingTokenIds = existingNfts ? existingNfts.map((nft) => nft.tokenId) : []\n    if (msSinceLastUpdate > 10000 && !isFetchingMoreNfts) {\n      dispatch(updateNftTokensData({ collectionAddress, existingTokenIds }))\n    }\n  }, [dispatch, fastRefresh, collectionAddress, existingNfts, lastUpdateAt, isFetchingMoreNfts])\n}\n\nexport const useGetCollections = () => {\n  return useSelector((state: State) => state.nftMarket.data.collections)\n}\n\nexport const useGetCollection = (collectionAddress: string) => {\n  const checksummedCollectionAddress = isAddress(collectionAddress) || ''\n  const collections = useGetCollections()\n  return collections[checksummedCollectionAddress]\n}\n\nexport const useNftsFromCollection = (collectionAddress: string) => {\n  const checksummedCollectionAddress = isAddress(collectionAddress) || ''\n  const nfts: NftToken[] = useSelector((state: State) => state.nftMarket.data.nfts[checksummedCollectionAddress])\n  return nfts\n}\n\nexport const useGetAllBunniesByBunnyId = (bunnyId: string) => {\n  const nfts: NftToken[] = useSelector((state: State) => state.nftMarket.data.nfts[pancakeBunniesAddress])\n  return nfts ? nfts.filter((nft) => nft.attributes[0].value === bunnyId && nft.marketData.isTradable) : []\n}\n\nexport const useGetNFTInitializationState = () => {\n  return useSelector((state: State) => state.nftMarket.initializationState)\n}\n\nexport const useUserNfts = (): UserNftsState => {\n  return useSelector((state: State) => state.nftMarket.data.user)\n}\n"]},"metadata":{},"sourceType":"module"}