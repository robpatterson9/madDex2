{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport { useWeb3React } from '@web3-react/core';\nimport { useSelector } from 'react-redux';\nimport { isAddress } from 'utils';\nimport { useAppDispatch } from 'state';\nimport usePreviousValue from 'hooks/usePreviousValue';\nimport { getAchievements } from 'state/achievements/helpers';\nimport { ProfileAvatarFetchStatus } from '../types';\nimport { fetchProfile, fetchProfileAvatar, fetchProfileUsername } from '.';\nimport { getProfile } from './helpers';\nexport const useFetchProfile = () => {\n  _s();\n\n  const {\n    account\n  } = useWeb3React();\n  const dispatch = useAppDispatch();\n  useEffect(() => {\n    if (account) {\n      dispatch(fetchProfile(account));\n    }\n  }, [account, dispatch]);\n};\n\n_s(useFetchProfile, \"+HYujYX/SnZ0I8i3/v+l9OV5PuY=\", false, function () {\n  return [useWeb3React, useAppDispatch];\n});\n\nexport const useProfileForAddress = address => {\n  _s2();\n\n  const [profileState, setProfileState] = useState({\n    profile: null,\n    isFetching: true\n  });\n  const previousAddress = usePreviousValue(address);\n  const hasAddressChanged = previousAddress !== address;\n  useEffect(() => {\n    const fetchProfileForAddress = async () => {\n      try {\n        const profile = await getProfile(address);\n        setProfileState({\n          profile,\n          isFetching: false\n        });\n      } catch (error) {\n        console.error(`Failed to fetch profile for address ${address}`, error);\n        setProfileState({\n          profile: null,\n          isFetching: false\n        });\n      }\n    };\n\n    if (hasAddressChanged || !profileState.isFetching && !profileState.profile) {\n      fetchProfileForAddress();\n    }\n  }, [profileState, address, hasAddressChanged]); // Clear state on account switch\n\n  useEffect(() => {\n    setProfileState({\n      profile: null,\n      isFetching: true\n    });\n  }, [address]);\n  return profileState;\n};\n\n_s2(useProfileForAddress, \"96tBKgRNdFe6bwnUVRgyRtLScXc=\", false, function () {\n  return [usePreviousValue];\n});\n\nexport const useAchievementsForAddress = address => {\n  _s3();\n\n  const [state, setState] = useState({\n    achievements: [],\n    isFetching: false\n  });\n  const previousAddress = usePreviousValue(address);\n  const hasAddressChanged = previousAddress !== address;\n  useEffect(() => {\n    const fetchProfileForAddress = async () => {\n      setState({\n        achievements: [],\n        isFetching: true\n      });\n\n      try {\n        const achievements = await getAchievements(address);\n        setState({\n          achievements,\n          isFetching: false\n        });\n      } catch (error) {\n        console.error(`Failed to fetch achievements for address ${address}`, error);\n        setState({\n          achievements: [],\n          isFetching: false\n        });\n      }\n    };\n\n    if (hasAddressChanged || !state.isFetching && !state.achievements) {\n      fetchProfileForAddress();\n    }\n  }, [state, address, hasAddressChanged]); // Clear state on account switch\n\n  useEffect(() => {\n    setState({\n      achievements: [],\n      isFetching: true\n    });\n  }, [address]);\n  return state;\n};\n\n_s3(useAchievementsForAddress, \"rfbqlhEc5pFICKf3xQNq3xdc5l4=\", false, function () {\n  return [usePreviousValue];\n});\n\nexport const useProfile = () => {\n  _s4();\n\n  const {\n    isInitialized,\n    isLoading,\n    data,\n    hasRegistered\n  } = useSelector(state => state.profile);\n  return {\n    profile: data,\n    hasProfile: isInitialized && hasRegistered,\n    isInitialized,\n    isLoading\n  };\n};\n\n_s4(useProfile, \"IKFRbj5HxYVQqavhAzR0F+CGiS4=\", false, function () {\n  return [useSelector];\n});\n\nexport const useGetProfileAvatar = account => {\n  _s5();\n\n  const profileAvatar = useSelector(state => state.profile.profileAvatars[account]);\n  const {\n    username,\n    nft,\n    hasRegistered,\n    usernameFetchStatus,\n    avatarFetchStatus\n  } = profileAvatar || {};\n  const dispatch = useAppDispatch();\n  useEffect(() => {\n    const address = isAddress(account);\n\n    if (!nft && avatarFetchStatus !== ProfileAvatarFetchStatus.FETCHED && address) {\n      dispatch(fetchProfileAvatar(account));\n    }\n\n    if (!username && avatarFetchStatus === ProfileAvatarFetchStatus.FETCHED && usernameFetchStatus !== ProfileAvatarFetchStatus.FETCHED && address) {\n      dispatch(fetchProfileUsername({\n        account,\n        hasRegistered\n      }));\n    }\n  }, [account, nft, username, hasRegistered, avatarFetchStatus, usernameFetchStatus, dispatch]);\n  return {\n    username,\n    nft,\n    usernameFetchStatus,\n    avatarFetchStatus\n  };\n};\n\n_s5(useGetProfileAvatar, \"thufEyAtLBSWh9n2bdVZ/Nsh8eg=\", false, function () {\n  return [useSelector, useAppDispatch];\n});","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/profile/hooks.ts"],"names":["useState","useEffect","useWeb3React","useSelector","isAddress","useAppDispatch","usePreviousValue","getAchievements","ProfileAvatarFetchStatus","fetchProfile","fetchProfileAvatar","fetchProfileUsername","getProfile","useFetchProfile","account","dispatch","useProfileForAddress","address","profileState","setProfileState","profile","isFetching","previousAddress","hasAddressChanged","fetchProfileForAddress","error","console","useAchievementsForAddress","state","setState","achievements","useProfile","isInitialized","isLoading","data","hasRegistered","hasProfile","useGetProfileAvatar","profileAvatar","profileAvatars","username","nft","usernameFetchStatus","avatarFetchStatus","FETCHED"],"mappings":"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","sourcesContent":["import { useState, useEffect } from 'react'\nimport { useWeb3React } from '@web3-react/core'\nimport { useSelector } from 'react-redux'\nimport { isAddress } from 'utils'\nimport { useAppDispatch } from 'state'\nimport usePreviousValue from 'hooks/usePreviousValue'\nimport { getAchievements } from 'state/achievements/helpers'\nimport { State, ProfileState, Achievement, ProfileAvatarFetchStatus } from '../types'\nimport { fetchProfile, fetchProfileAvatar, fetchProfileUsername } from '.'\nimport { getProfile, GetProfileResponse } from './helpers'\n\nexport const useFetchProfile = () => {\n  const { account } = useWeb3React()\n  const dispatch = useAppDispatch()\n\n  useEffect(() => {\n    if (account) {\n      dispatch(fetchProfile(account))\n    }\n  }, [account, dispatch])\n}\n\nexport const useProfileForAddress = (address: string) => {\n  const [profileState, setProfileState] = useState<{ profile: GetProfileResponse; isFetching: boolean }>({\n    profile: null,\n    isFetching: true,\n  })\n  const previousAddress = usePreviousValue(address)\n  const hasAddressChanged = previousAddress !== address\n\n  useEffect(() => {\n    const fetchProfileForAddress = async () => {\n      try {\n        const profile = await getProfile(address)\n        setProfileState({ profile, isFetching: false })\n      } catch (error) {\n        console.error(`Failed to fetch profile for address ${address}`, error)\n        setProfileState({ profile: null, isFetching: false })\n      }\n    }\n    if (hasAddressChanged || (!profileState.isFetching && !profileState.profile)) {\n      fetchProfileForAddress()\n    }\n  }, [profileState, address, hasAddressChanged])\n\n  // Clear state on account switch\n  useEffect(() => {\n    setProfileState({ profile: null, isFetching: true })\n  }, [address])\n\n  return profileState\n}\n\nexport const useAchievementsForAddress = (address: string) => {\n  const [state, setState] = useState<{ achievements: Achievement[]; isFetching: boolean }>({\n    achievements: [],\n    isFetching: false,\n  })\n  const previousAddress = usePreviousValue(address)\n  const hasAddressChanged = previousAddress !== address\n\n  useEffect(() => {\n    const fetchProfileForAddress = async () => {\n      setState({ achievements: [], isFetching: true })\n      try {\n        const achievements = await getAchievements(address)\n        setState({ achievements, isFetching: false })\n      } catch (error) {\n        console.error(`Failed to fetch achievements for address ${address}`, error)\n        setState({ achievements: [], isFetching: false })\n      }\n    }\n    if (hasAddressChanged || (!state.isFetching && !state.achievements)) {\n      fetchProfileForAddress()\n    }\n  }, [state, address, hasAddressChanged])\n\n  // Clear state on account switch\n  useEffect(() => {\n    setState({ achievements: [], isFetching: true })\n  }, [address])\n\n  return state\n}\n\nexport const useProfile = () => {\n  const { isInitialized, isLoading, data, hasRegistered }: ProfileState = useSelector((state: State) => state.profile)\n  return { profile: data, hasProfile: isInitialized && hasRegistered, isInitialized, isLoading }\n}\n\nexport const useGetProfileAvatar = (account: string) => {\n  const profileAvatar = useSelector((state: State) => state.profile.profileAvatars[account])\n  const { username, nft, hasRegistered, usernameFetchStatus, avatarFetchStatus } = profileAvatar || {}\n  const dispatch = useAppDispatch()\n\n  useEffect(() => {\n    const address = isAddress(account)\n\n    if (!nft && avatarFetchStatus !== ProfileAvatarFetchStatus.FETCHED && address) {\n      dispatch(fetchProfileAvatar(account))\n    }\n\n    if (\n      !username &&\n      avatarFetchStatus === ProfileAvatarFetchStatus.FETCHED &&\n      usernameFetchStatus !== ProfileAvatarFetchStatus.FETCHED &&\n      address\n    ) {\n      dispatch(fetchProfileUsername({ account, hasRegistered }))\n    }\n  }, [account, nft, username, hasRegistered, avatarFetchStatus, usernameFetchStatus, dispatch])\n\n  return { username, nft, usernameFetchStatus, avatarFetchStatus }\n}\n"]},"metadata":{},"sourceType":"module"}