{"ast":null,"code":"import { request, gql } from 'graphql-request';\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints';\nimport { getRoundIdsArray, fetchMultipleLotteries, hasRoundBeenClaimed } from './helpers';\nimport { fetchUserTicketsForMultipleRounds } from './getUserTicketsData';\nexport const MAX_USER_LOTTERIES_REQUEST_SIZE = 100;\n/* eslint-disable camelcase */\n\nconst applyNodeDataToUserGraphResponse = (userNodeData, userGraphData, lotteryNodeData) => {\n  //   If no graph rounds response - return node data\n  if (userGraphData.length === 0) {\n    return lotteryNodeData.map(nodeRound => {\n      const ticketDataForRound = userNodeData.find(roundTickets => roundTickets.roundId === nodeRound.lotteryId);\n      return {\n        endTime: nodeRound.endTime,\n        status: nodeRound.status,\n        lotteryId: nodeRound.lotteryId.toString(),\n        claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\n        totalTickets: `${ticketDataForRound.userTickets.length.toString()}`,\n        tickets: ticketDataForRound.userTickets\n      };\n    });\n  } // Return the rounds with combined node + subgraph data, plus all remaining subgraph rounds.\n\n\n  const nodeRoundsWithGraphData = userNodeData.map(userNodeRound => {\n    const userGraphRound = userGraphData.find(graphResponseRound => graphResponseRound.lotteryId === userNodeRound.roundId);\n    const nodeRoundData = lotteryNodeData.find(nodeRound => nodeRound.lotteryId === userNodeRound.roundId);\n    return {\n      endTime: nodeRoundData.endTime,\n      status: nodeRoundData.status,\n      lotteryId: nodeRoundData.lotteryId.toString(),\n      claimed: hasRoundBeenClaimed(userNodeRound.userTickets),\n      totalTickets: (userGraphRound === null || userGraphRound === void 0 ? void 0 : userGraphRound.totalTickets) || userNodeRound.userTickets.length.toString(),\n      tickets: userNodeRound.userTickets\n    };\n  }); // Return the rounds with combined data, plus all remaining subgraph rounds.\n\n  const [lastCombinedDataRound] = nodeRoundsWithGraphData.slice(-1);\n  const lastCombinedDataRoundIndex = userGraphData.map(graphRound => graphRound === null || graphRound === void 0 ? void 0 : graphRound.lotteryId).indexOf(lastCombinedDataRound === null || lastCombinedDataRound === void 0 ? void 0 : lastCombinedDataRound.lotteryId);\n  const remainingSubgraphRounds = userGraphData ? userGraphData.splice(lastCombinedDataRoundIndex + 1) : [];\n  const mergedResponse = [...nodeRoundsWithGraphData, ...remainingSubgraphRounds];\n  return mergedResponse;\n};\n\nexport const getGraphLotteryUser = async (account, first = MAX_USER_LOTTERIES_REQUEST_SIZE, skip = 0, where = {}) => {\n  let user;\n  const blankUser = {\n    account,\n    totalCake: '',\n    totalTickets: '',\n    rounds: []\n  };\n\n  try {\n    const response = await request(GRAPH_API_LOTTERY, gql`\n        query getUserLotteries($account: ID!, $first: Int!, $skip: Int!, $where: Round_filter) {\n          user(id: $account) {\n            id\n            totalTickets\n            totalCake\n            rounds(first: $first, skip: $skip, where: $where, orderDirection: desc, orderBy: block) {\n              id\n              lottery {\n                id\n                endTime\n                status\n              }\n              claimed\n              totalTickets\n            }\n          }\n        }\n      `, {\n      account: account.toLowerCase(),\n      first,\n      skip,\n      where\n    });\n    const userRes = response.user; // If no user returned - return blank user\n\n    if (!userRes) {\n      user = blankUser;\n    } else {\n      user = {\n        account: userRes.id,\n        totalCake: userRes.totalCake,\n        totalTickets: userRes.totalTickets,\n        rounds: userRes.rounds.map(round => {\n          var _round$lottery, _round$lottery2, _round$lottery3;\n\n          return {\n            lotteryId: round === null || round === void 0 ? void 0 : (_round$lottery = round.lottery) === null || _round$lottery === void 0 ? void 0 : _round$lottery.id,\n            endTime: round === null || round === void 0 ? void 0 : (_round$lottery2 = round.lottery) === null || _round$lottery2 === void 0 ? void 0 : _round$lottery2.endTime,\n            claimed: round === null || round === void 0 ? void 0 : round.claimed,\n            totalTickets: round === null || round === void 0 ? void 0 : round.totalTickets,\n            status: round === null || round === void 0 ? void 0 : (_round$lottery3 = round.lottery) === null || _round$lottery3 === void 0 ? void 0 : _round$lottery3.status.toLowerCase()\n          };\n        })\n      };\n    }\n  } catch (error) {\n    console.error(error);\n    user = blankUser;\n  }\n\n  return user;\n};\n\nconst getUserLotteryData = async (account, currentLotteryId) => {\n  const idsForTicketsNodeCall = getRoundIdsArray(currentLotteryId);\n  const roundDataAndUserTickets = await fetchUserTicketsForMultipleRounds(idsForTicketsNodeCall, account);\n  const userRoundsNodeData = roundDataAndUserTickets.filter(round => round.userTickets.length > 0);\n  const idsForLotteriesNodeCall = userRoundsNodeData.map(round => round.roundId);\n  const lotteriesNodeData = await fetchMultipleLotteries(idsForLotteriesNodeCall);\n  const graphResponse = await getGraphLotteryUser(account);\n  const mergedRoundData = applyNodeDataToUserGraphResponse(userRoundsNodeData, graphResponse.rounds, lotteriesNodeData);\n  const graphResponseWithNodeRounds = { ...graphResponse,\n    rounds: mergedRoundData\n  };\n  return graphResponseWithNodeRounds;\n};\n\nexport default getUserLotteryData;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/lottery/getUserLotteryData.ts"],"names":["request","gql","GRAPH_API_LOTTERY","getRoundIdsArray","fetchMultipleLotteries","hasRoundBeenClaimed","fetchUserTicketsForMultipleRounds","MAX_USER_LOTTERIES_REQUEST_SIZE","applyNodeDataToUserGraphResponse","userNodeData","userGraphData","lotteryNodeData","length","map","nodeRound","ticketDataForRound","find","roundTickets","roundId","lotteryId","endTime","status","toString","claimed","userTickets","totalTickets","tickets","nodeRoundsWithGraphData","userNodeRound","userGraphRound","graphResponseRound","nodeRoundData","lastCombinedDataRound","slice","lastCombinedDataRoundIndex","graphRound","indexOf","remainingSubgraphRounds","splice","mergedResponse","getGraphLotteryUser","account","first","skip","where","user","blankUser","totalCake","rounds","response","toLowerCase","userRes","id","round","lottery","error","console","getUserLotteryData","currentLotteryId","idsForTicketsNodeCall","roundDataAndUserTickets","userRoundsNodeData","filter","idsForLotteriesNodeCall","lotteriesNodeData","graphResponse","mergedRoundData","graphResponseWithNodeRounds"],"mappings":"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","sourcesContent":["import { request, gql } from 'graphql-request'\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints'\nimport { LotteryTicket } from 'config/constants/types'\nimport { LotteryUserGraphEntity, LotteryResponse, UserRound } from 'state/types'\nimport { getRoundIdsArray, fetchMultipleLotteries, hasRoundBeenClaimed } from './helpers'\nimport { fetchUserTicketsForMultipleRounds } from './getUserTicketsData'\n\nexport const MAX_USER_LOTTERIES_REQUEST_SIZE = 100\n\n/* eslint-disable camelcase */\ntype UserLotteriesWhere = { lottery_in?: string[] }\n\nconst applyNodeDataToUserGraphResponse = (\n  userNodeData: { roundId: string; userTickets: LotteryTicket[] }[],\n  userGraphData: UserRound[],\n  lotteryNodeData: LotteryResponse[],\n): UserRound[] => {\n  //   If no graph rounds response - return node data\n  if (userGraphData.length === 0) {\n    return lotteryNodeData.map((nodeRound) => {\n      const ticketDataForRound = userNodeData.find((roundTickets) => roundTickets.roundId === nodeRound.lotteryId)\n      return {\n        endTime: nodeRound.endTime,\n        status: nodeRound.status,\n        lotteryId: nodeRound.lotteryId.toString(),\n        claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\n        totalTickets: `${ticketDataForRound.userTickets.length.toString()}`,\n        tickets: ticketDataForRound.userTickets,\n      }\n    })\n  }\n\n  // Return the rounds with combined node + subgraph data, plus all remaining subgraph rounds.\n  const nodeRoundsWithGraphData = userNodeData.map((userNodeRound) => {\n    const userGraphRound = userGraphData.find(\n      (graphResponseRound) => graphResponseRound.lotteryId === userNodeRound.roundId,\n    )\n    const nodeRoundData = lotteryNodeData.find((nodeRound) => nodeRound.lotteryId === userNodeRound.roundId)\n    return {\n      endTime: nodeRoundData.endTime,\n      status: nodeRoundData.status,\n      lotteryId: nodeRoundData.lotteryId.toString(),\n      claimed: hasRoundBeenClaimed(userNodeRound.userTickets),\n      totalTickets: userGraphRound?.totalTickets || userNodeRound.userTickets.length.toString(),\n      tickets: userNodeRound.userTickets,\n    }\n  })\n\n  // Return the rounds with combined data, plus all remaining subgraph rounds.\n  const [lastCombinedDataRound] = nodeRoundsWithGraphData.slice(-1)\n  const lastCombinedDataRoundIndex = userGraphData\n    .map((graphRound) => graphRound?.lotteryId)\n    .indexOf(lastCombinedDataRound?.lotteryId)\n  const remainingSubgraphRounds = userGraphData ? userGraphData.splice(lastCombinedDataRoundIndex + 1) : []\n  const mergedResponse = [...nodeRoundsWithGraphData, ...remainingSubgraphRounds]\n  return mergedResponse\n}\n\nexport const getGraphLotteryUser = async (\n  account: string,\n  first = MAX_USER_LOTTERIES_REQUEST_SIZE,\n  skip = 0,\n  where: UserLotteriesWhere = {},\n): Promise<LotteryUserGraphEntity> => {\n  let user\n  const blankUser = {\n    account,\n    totalCake: '',\n    totalTickets: '',\n    rounds: [],\n  }\n\n  try {\n    const response = await request(\n      GRAPH_API_LOTTERY,\n      gql`\n        query getUserLotteries($account: ID!, $first: Int!, $skip: Int!, $where: Round_filter) {\n          user(id: $account) {\n            id\n            totalTickets\n            totalCake\n            rounds(first: $first, skip: $skip, where: $where, orderDirection: desc, orderBy: block) {\n              id\n              lottery {\n                id\n                endTime\n                status\n              }\n              claimed\n              totalTickets\n            }\n          }\n        }\n      `,\n      { account: account.toLowerCase(), first, skip, where },\n    )\n    const userRes = response.user\n\n    // If no user returned - return blank user\n    if (!userRes) {\n      user = blankUser\n    } else {\n      user = {\n        account: userRes.id,\n        totalCake: userRes.totalCake,\n        totalTickets: userRes.totalTickets,\n        rounds: userRes.rounds.map((round) => {\n          return {\n            lotteryId: round?.lottery?.id,\n            endTime: round?.lottery?.endTime,\n            claimed: round?.claimed,\n            totalTickets: round?.totalTickets,\n            status: round?.lottery?.status.toLowerCase(),\n          }\n        }),\n      }\n    }\n  } catch (error) {\n    console.error(error)\n    user = blankUser\n  }\n\n  return user\n}\n\nconst getUserLotteryData = async (account: string, currentLotteryId: string): Promise<LotteryUserGraphEntity> => {\n  const idsForTicketsNodeCall = getRoundIdsArray(currentLotteryId)\n  const roundDataAndUserTickets = await fetchUserTicketsForMultipleRounds(idsForTicketsNodeCall, account)\n  const userRoundsNodeData = roundDataAndUserTickets.filter((round) => round.userTickets.length > 0)\n  const idsForLotteriesNodeCall = userRoundsNodeData.map((round) => round.roundId)\n  const lotteriesNodeData = await fetchMultipleLotteries(idsForLotteriesNodeCall)\n  const graphResponse = await getGraphLotteryUser(account)\n  const mergedRoundData = applyNodeDataToUserGraphResponse(userRoundsNodeData, graphResponse.rounds, lotteriesNodeData)\n  const graphResponseWithNodeRounds = { ...graphResponse, rounds: mergedRoundData }\n  return graphResponseWithNodeRounds\n}\n\nexport default getUserLotteryData\n"]},"metadata":{},"sourceType":"module"}