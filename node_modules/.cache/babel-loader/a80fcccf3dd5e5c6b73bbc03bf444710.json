{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { pancakeBunniesAddress } from 'views/Nft/market/constants';\nimport { getNftsFromCollectionApi, getNftsFromCollectionSg, getNftsMarketData, getCollectionsApi, getCollectionsSg, getUserActivity, combineCollectionData, getCollectionSg, getCollectionApi, getNftsFromDifferentCollectionsApi, getCompleteAccountNftData, getNftsByBunnyIdSg, getMarketDataForTokenIds } from './helpers';\nimport { NFTMarketInitializationState, UserNftInitializationState, NftLocation } from './types';\nconst initialState = {\n  initializationState: NFTMarketInitializationState.UNINITIALIZED,\n  data: {\n    collections: {},\n    nfts: {},\n    isFetchingMoreNfts: false,\n    latestFetchAt: 0,\n    lastUpdateAt: Date.now(),\n    users: {},\n    user: {\n      userNftsInitializationState: UserNftInitializationState.UNINITIALIZED,\n      nfts: [],\n      activity: {\n        initializationState: UserNftInitializationState.UNINITIALIZED,\n        askOrderHistory: [],\n        buyTradeHistory: [],\n        sellTradeHistory: []\n      }\n    }\n  }\n};\n/**\n * Fetch all collections data by combining data from the API (static metadata) and the Subgraph (dynamic market data)\n */\n\nexport const fetchCollections = createAsyncThunk('nft/fetchCollections', async () => {\n  const [collections, collectionsMarket] = await Promise.all([getCollectionsApi(), getCollectionsSg()]);\n  return combineCollectionData(collections, collectionsMarket);\n});\n/**\n * Fetch collection data by combining data from the API (static metadata) and the Subgraph (dynamic market data)\n */\n\nexport const fetchCollection = createAsyncThunk('nft/fetchCollection', async collectionAddress => {\n  const [collection, collectionMarket] = await Promise.all([getCollectionApi(collectionAddress), getCollectionSg(collectionAddress)]);\n  return combineCollectionData([collection], [collectionMarket]);\n});\n/**\n * Fetch all NFT data for a collections by combining data from the API (static metadata)\n * and the Subgraph (dynamic market data)\n * @param collectionAddress\n */\n\nexport const fetchNftsFromCollections = createAsyncThunk('nft/fetchNftsFromCollections', async collectionAddress => {\n  try {\n    const [nfts, nftsMarket] = await Promise.all([getNftsFromCollectionApi(collectionAddress), getNftsFromCollectionSg(collectionAddress)]);\n\n    if (!(nfts === null || nfts === void 0 ? void 0 : nfts.data)) {\n      return [];\n    }\n\n    if (collectionAddress === pancakeBunniesAddress) {\n      return nftsMarket.map(marketData => {\n        var _nfts$data$marketData;\n\n        // The fallback is just for the testnet where some bunnies don't exist\n        const apiMetadata = (_nfts$data$marketData = nfts.data[marketData.otherId]) !== null && _nfts$data$marketData !== void 0 ? _nfts$data$marketData : {\n          name: '',\n          description: '',\n          collection: {\n            name: 'Pancake Bunnies'\n          },\n          image: {\n            original: '',\n            thumbnail: ''\n          }\n        }; // Generating attributes field that is not returned by API but can be \"faked\" since objects are keyed with bunny id\n\n        const attributes = [{\n          traitType: 'bunnyId',\n          value: marketData.otherId,\n          displayType: null\n        }];\n        return {\n          tokenId: marketData.tokenId,\n          name: apiMetadata.name,\n          description: apiMetadata.description,\n          collectionName: apiMetadata.collection.name,\n          collectionAddress,\n          image: apiMetadata.image,\n          marketData,\n          attributes\n        };\n      });\n    } // TODO: revisit this for other collecitons\n\n\n    return [];\n  } catch (error) {\n    console.error(`Failed to fetch collection NFTs for ${collectionAddress}`, error);\n    return [];\n  }\n});\n/**\n * Fetch fresh marketdata for existing tokens in the store\n */\n\nexport const updateNftTokensData = createAsyncThunk('nft/updateNftTokensData', async ({\n  collectionAddress,\n  existingTokenIds\n}) => {\n  try {\n    // TODO: this kinda should work for other collections too, but doublecheck during Squad integration\n    const [nfts, nftsMarket] = await Promise.all([getNftsFromCollectionApi(collectionAddress), getMarketDataForTokenIds(collectionAddress, existingTokenIds)]);\n\n    if (!(nfts === null || nfts === void 0 ? void 0 : nfts.data)) {\n      return [];\n    }\n\n    return nftsMarket.map(marketData => {\n      var _nfts$data$marketData2;\n\n      // The fallback is just for the testnet where some bunnies don't exist\n      const apiMetadata = (_nfts$data$marketData2 = nfts.data[marketData.otherId]) !== null && _nfts$data$marketData2 !== void 0 ? _nfts$data$marketData2 : {\n        name: '',\n        description: '',\n        collection: {\n          name: 'Pancake Bunnies'\n        },\n        image: {\n          original: '',\n          thumbnail: ''\n        }\n      }; // Generating attributes field that is not returned by API but can be \"faked\" since objects are keyed with bunny id\n\n      const attributes = [{\n        traitType: 'bunnyId',\n        value: marketData.otherId,\n        displayType: null\n      }];\n      return {\n        tokenId: marketData.tokenId,\n        name: apiMetadata.name,\n        description: apiMetadata.description,\n        collectionName: apiMetadata.collection.name,\n        collectionAddress: pancakeBunniesAddress,\n        image: apiMetadata.image,\n        marketData,\n        attributes\n      };\n    });\n  } catch (error) {\n    console.error(`Failed to update collection NFTs for ${collectionAddress}`, error);\n    return [];\n  }\n});\n/**\n * Fetch all 30 on sale NFTs with specified bunny id\n */\n\nexport const fetchNftsByBunnyId = createAsyncThunk('nft/fetchNftsByBunnyId', async ({\n  bunnyId,\n  existingTokenIds,\n  existingMetadata,\n  orderDirection\n}) => {\n  try {\n    var _nfts;\n\n    let nfts = {\n      data: {\n        [bunnyId]: existingMetadata\n      }\n    };\n\n    if (!existingMetadata) {\n      nfts = await getNftsFromCollectionApi(pancakeBunniesAddress);\n    }\n\n    const nftsMarket = await getNftsByBunnyIdSg(bunnyId, existingTokenIds, orderDirection);\n\n    if (!((_nfts = nfts) === null || _nfts === void 0 ? void 0 : _nfts.data)) {\n      return [];\n    }\n\n    return nftsMarket.map(marketData => {\n      var _nfts$data$marketData3;\n\n      // The fallback is just for the testnet where some bunnies don't exist\n      const apiMetadata = (_nfts$data$marketData3 = nfts.data[marketData.otherId]) !== null && _nfts$data$marketData3 !== void 0 ? _nfts$data$marketData3 : {\n        name: '',\n        description: '',\n        collection: {\n          name: 'Pancake Bunnies'\n        },\n        image: {\n          original: '',\n          thumbnail: ''\n        }\n      }; // Generating attributes field that is not returned by API but can be \"faked\" since objects are keyed with bunny id\n\n      const attributes = [{\n        traitType: 'bunnyId',\n        value: marketData.otherId,\n        displayType: null\n      }];\n      return {\n        tokenId: marketData.tokenId,\n        name: apiMetadata.name,\n        description: apiMetadata.description,\n        collectionName: apiMetadata.collection.name,\n        collectionAddress: pancakeBunniesAddress,\n        image: apiMetadata.image,\n        marketData,\n        attributes\n      };\n    });\n  } catch (error) {\n    console.error(`Failed to fetch collection NFTs for bunny id ${bunnyId}`, error);\n    return [];\n  }\n});\nexport const fetchUserNfts = createAsyncThunk('nft/fetchUserNfts', async ({\n  account,\n  profileNftWithCollectionAddress,\n  collections\n}) => {\n  const completeNftData = await getCompleteAccountNftData(account, collections, profileNftWithCollectionAddress);\n  return completeNftData;\n});\nexport const updateUserNft = createAsyncThunk('nft/updateUserNft', async ({\n  tokenId,\n  collectionAddress,\n  location = NftLocation.WALLET\n}) => {\n  const marketDataForNft = await getNftsMarketData({\n    tokenId_in: [tokenId]\n  });\n  const metadataForNft = await getNftsFromDifferentCollectionsApi([{\n    tokenId,\n    collectionAddress\n  }]);\n  const completeNftData = { ...metadataForNft[0],\n    location,\n    marketData: marketDataForNft[0]\n  };\n  return completeNftData;\n});\nexport const removeUserNft = createAsyncThunk('nft/removeUserNft', async ({\n  tokenId\n}) => tokenId);\nexport const addUserNft = createAsyncThunk('nft/addUserNft', async ({\n  tokenId,\n  collectionAddress,\n  nftLocation = NftLocation.WALLET\n}) => {\n  const marketDataForNft = await getNftsMarketData({\n    tokenId_in: [tokenId]\n  });\n  const metadataForNft = await getNftsFromDifferentCollectionsApi([{\n    tokenId,\n    collectionAddress\n  }]);\n  const tokens = {\n    [tokenId]: { ...marketDataForNft[0],\n      nftLocation\n    }\n  };\n  const completeNftData = { ...metadataForNft[0],\n    tokens\n  };\n  return completeNftData;\n});\nexport const fetchUserActivity = createAsyncThunk('nft/fetchUserActivity', async address => {\n  const userActivity = await getUserActivity(address.toLocaleLowerCase());\n  return userActivity;\n});\nexport const NftMarket = createSlice({\n  name: 'NftMarket',\n  initialState,\n  reducers: {},\n  extraReducers: builder => {\n    builder.addCase(fetchCollection.fulfilled, (state, action) => {\n      state.data.collections = { ...state.data.collections,\n        ...action.payload\n      };\n    });\n    builder.addCase(fetchCollections.fulfilled, (state, action) => {\n      state.data.collections = action.payload;\n      state.initializationState = NFTMarketInitializationState.INITIALIZED;\n    });\n    builder.addCase(fetchNftsFromCollections.fulfilled, (state, action) => {\n      state.data.nfts[action.meta.arg] = action.payload;\n    });\n    builder.addCase(updateNftTokensData.fulfilled, (state, action) => {\n      if (action.payload.length > 0) {\n        state.data.nfts[action.meta.arg.collectionAddress] = action.payload;\n        state.data.lastUpdateAt = Date.now();\n      }\n    });\n    builder.addCase(updateNftTokensData.rejected, state => {\n      state.data.lastUpdateAt = Date.now();\n    });\n    builder.addCase(fetchNftsByBunnyId.pending, state => {\n      state.data.isFetchingMoreNfts = true;\n    });\n    builder.addCase(fetchNftsByBunnyId.fulfilled, (state, action) => {\n      const existingNftsInState = state.data.nfts[pancakeBunniesAddress] || [];\n      state.data.nfts[pancakeBunniesAddress] = [...existingNftsInState, ...action.payload];\n      state.data.isFetchingMoreNfts = false;\n      state.data.latestFetchAt = Date.now();\n    });\n    builder.addCase(fetchNftsByBunnyId.rejected, state => {\n      state.data.isFetchingMoreNfts = false;\n    });\n    builder.addCase(fetchUserNfts.rejected, state => {\n      state.data.user.userNftsInitializationState = UserNftInitializationState.ERROR;\n    });\n    builder.addCase(fetchUserNfts.pending, state => {\n      state.data.user.userNftsInitializationState = UserNftInitializationState.INITIALIZING;\n    });\n    builder.addCase(fetchUserNfts.fulfilled, (state, action) => {\n      state.data.user.nfts = action.payload;\n      state.data.user.userNftsInitializationState = UserNftInitializationState.INITIALIZED;\n    });\n    builder.addCase(updateUserNft.fulfilled, (state, action) => {\n      const userNftsState = state.data.user.nfts;\n      const nftToUpdate = userNftsState.find(nft => nft.tokenId === action.payload.tokenId);\n      const indexInState = userNftsState.indexOf(nftToUpdate);\n      state.data.user.nfts[indexInState] = action.payload;\n    });\n    builder.addCase(removeUserNft.fulfilled, (state, action) => {\n      const copyOfState = [...state.data.user.nfts];\n      const nftToRemove = copyOfState.find(nft => nft.tokenId === action.payload);\n      const indexInState = copyOfState.indexOf(nftToRemove);\n      copyOfState.splice(indexInState, 1);\n      state.data.user.nfts = copyOfState;\n    });\n    builder.addCase(addUserNft.fulfilled, (state, action) => {\n      state.data.user.nfts = [...state.data.user.nfts, action.payload];\n    });\n    builder.addCase(fetchUserActivity.fulfilled, (state, action) => {\n      state.data.user.activity = { ...action.payload,\n        initializationState: UserNftInitializationState.INITIALIZED\n      };\n    });\n    builder.addCase(fetchUserActivity.rejected, state => {\n      state.data.user.activity.initializationState = UserNftInitializationState.ERROR;\n    });\n    builder.addCase(fetchUserActivity.pending, state => {\n      state.data.user.activity.initializationState = UserNftInitializationState.INITIALIZING;\n    });\n  }\n});\nexport default NftMarket.reducer;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/nftMarket/reducer.ts"],"names":["createSlice","createAsyncThunk","pancakeBunniesAddress","getNftsFromCollectionApi","getNftsFromCollectionSg","getNftsMarketData","getCollectionsApi","getCollectionsSg","getUserActivity","combineCollectionData","getCollectionSg","getCollectionApi","getNftsFromDifferentCollectionsApi","getCompleteAccountNftData","getNftsByBunnyIdSg","getMarketDataForTokenIds","NFTMarketInitializationState","UserNftInitializationState","NftLocation","initialState","initializationState","UNINITIALIZED","data","collections","nfts","isFetchingMoreNfts","latestFetchAt","lastUpdateAt","Date","now","users","user","userNftsInitializationState","activity","askOrderHistory","buyTradeHistory","sellTradeHistory","fetchCollections","collectionsMarket","Promise","all","fetchCollection","collectionAddress","collection","collectionMarket","fetchNftsFromCollections","nftsMarket","map","marketData","apiMetadata","otherId","name","description","image","original","thumbnail","attributes","traitType","value","displayType","tokenId","collectionName","error","console","updateNftTokensData","existingTokenIds","fetchNftsByBunnyId","bunnyId","existingMetadata","orderDirection","fetchUserNfts","account","profileNftWithCollectionAddress","completeNftData","updateUserNft","location","WALLET","marketDataForNft","tokenId_in","metadataForNft","removeUserNft","addUserNft","nftLocation","tokens","fetchUserActivity","address","userActivity","toLocaleLowerCase","NftMarket","reducers","extraReducers","builder","addCase","fulfilled","state","action","payload","INITIALIZED","meta","arg","length","rejected","pending","existingNftsInState","ERROR","INITIALIZING","userNftsState","nftToUpdate","find","nft","indexInState","indexOf","copyOfState","nftToRemove","splice","reducer"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,gBAAtB,QAA8C,kBAA9C;AACA,SAASC,qBAAT,QAAsC,4BAAtC;AACA,SACEC,wBADF,EAEEC,uBAFF,EAGEC,iBAHF,EAIEC,iBAJF,EAKEC,gBALF,EAMEC,eANF,EAOEC,qBAPF,EAQEC,eARF,EASEC,gBATF,EAUEC,kCAVF,EAWEC,yBAXF,EAYEC,kBAZF,EAaEC,wBAbF,QAcO,WAdP;AAeA,SAKEC,4BALF,EAMEC,0BANF,EAQEC,WARF,QAUO,SAVP;AAYA,MAAMC,YAAmB,GAAG;AAC1BC,EAAAA,mBAAmB,EAAEJ,4BAA4B,CAACK,aADxB;AAE1BC,EAAAA,IAAI,EAAE;AACJC,IAAAA,WAAW,EAAE,EADT;AAEJC,IAAAA,IAAI,EAAE,EAFF;AAGJC,IAAAA,kBAAkB,EAAE,KAHhB;AAIJC,IAAAA,aAAa,EAAE,CAJX;AAKJC,IAAAA,YAAY,EAAEC,IAAI,CAACC,GAAL,EALV;AAMJC,IAAAA,KAAK,EAAE,EANH;AAOJC,IAAAA,IAAI,EAAE;AACJC,MAAAA,2BAA2B,EAAEf,0BAA0B,CAACI,aADpD;AAEJG,MAAAA,IAAI,EAAE,EAFF;AAGJS,MAAAA,QAAQ,EAAE;AACRb,QAAAA,mBAAmB,EAAEH,0BAA0B,CAACI,aADxC;AAERa,QAAAA,eAAe,EAAE,EAFT;AAGRC,QAAAA,eAAe,EAAE,EAHT;AAIRC,QAAAA,gBAAgB,EAAE;AAJV;AAHN;AAPF;AAFoB,CAA5B;AAsBA;AACA;AACA;;AACA,OAAO,MAAMC,gBAAgB,GAAGpC,gBAAgB,CAA6B,sBAA7B,EAAqD,YAAY;AAC/G,QAAM,CAACsB,WAAD,EAAce,iBAAd,IAAmC,MAAMC,OAAO,CAACC,GAAR,CAAY,CAAClC,iBAAiB,EAAlB,EAAsBC,gBAAgB,EAAtC,CAAZ,CAA/C;AACA,SAAOE,qBAAqB,CAACc,WAAD,EAAce,iBAAd,CAA5B;AACD,CAH+C,CAAzC;AAKP;AACA;AACA;;AACA,OAAO,MAAMG,eAAe,GAAGxC,gBAAgB,CAC7C,qBAD6C,EAE7C,MAAOyC,iBAAP,IAA6B;AAC3B,QAAM,CAACC,UAAD,EAAaC,gBAAb,IAAiC,MAAML,OAAO,CAACC,GAAR,CAAY,CACvD7B,gBAAgB,CAAC+B,iBAAD,CADuC,EAEvDhC,eAAe,CAACgC,iBAAD,CAFwC,CAAZ,CAA7C;AAKA,SAAOjC,qBAAqB,CAAC,CAACkC,UAAD,CAAD,EAAe,CAACC,gBAAD,CAAf,CAA5B;AACD,CAT4C,CAAxC;AAYP;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,wBAAwB,GAAG5C,gBAAgB,CACtD,8BADsD,EAEtD,MAAOyC,iBAAP,IAAqC;AACnC,MAAI;AACF,UAAM,CAAClB,IAAD,EAAOsB,UAAP,IAAqB,MAAMP,OAAO,CAACC,GAAR,CAAY,CAC3CrC,wBAAwB,CAACuC,iBAAD,CADmB,EAE3CtC,uBAAuB,CAACsC,iBAAD,CAFoB,CAAZ,CAAjC;;AAKA,QAAI,EAAClB,IAAD,aAACA,IAAD,uBAACA,IAAI,CAAEF,IAAP,CAAJ,EAAiB;AACf,aAAO,EAAP;AACD;;AAED,QAAIoB,iBAAiB,KAAKxC,qBAA1B,EAAiD;AAC/C,aAAO4C,UAAU,CAACC,GAAX,CAAgBC,UAAD,IAAgB;AAAA;;AACpC;AACA,cAAMC,WAAW,4BAAGzB,IAAI,CAACF,IAAL,CAAU0B,UAAU,CAACE,OAArB,CAAH,yEAAoC;AACnDC,UAAAA,IAAI,EAAE,EAD6C;AAEnDC,UAAAA,WAAW,EAAE,EAFsC;AAGnDT,UAAAA,UAAU,EAAE;AAAEQ,YAAAA,IAAI,EAAE;AAAR,WAHuC;AAInDE,UAAAA,KAAK,EAAE;AACLC,YAAAA,QAAQ,EAAE,EADL;AAELC,YAAAA,SAAS,EAAE;AAFN;AAJ4C,SAArD,CAFoC,CAWpC;;AACA,cAAMC,UAAU,GAAG,CACjB;AACEC,UAAAA,SAAS,EAAE,SADb;AAEEC,UAAAA,KAAK,EAAEV,UAAU,CAACE,OAFpB;AAGES,UAAAA,WAAW,EAAE;AAHf,SADiB,CAAnB;AAOA,eAAO;AACLC,UAAAA,OAAO,EAAEZ,UAAU,CAACY,OADf;AAELT,UAAAA,IAAI,EAAEF,WAAW,CAACE,IAFb;AAGLC,UAAAA,WAAW,EAAEH,WAAW,CAACG,WAHpB;AAILS,UAAAA,cAAc,EAAEZ,WAAW,CAACN,UAAZ,CAAuBQ,IAJlC;AAKLT,UAAAA,iBALK;AAMLW,UAAAA,KAAK,EAAEJ,WAAW,CAACI,KANd;AAOLL,UAAAA,UAPK;AAQLQ,UAAAA;AARK,SAAP;AAUD,OA7BM,CAAP;AA8BD,KAzCC,CA2CF;;;AACA,WAAO,EAAP;AACD,GA7CD,CA6CE,OAAOM,KAAP,EAAc;AACdC,IAAAA,OAAO,CAACD,KAAR,CAAe,uCAAsCpB,iBAAkB,EAAvE,EAA0EoB,KAA1E;AACA,WAAO,EAAP;AACD;AACF,CApDqD,CAAjD;AAuDP;AACA;AACA;;AACA,OAAO,MAAME,mBAAmB,GAAG/D,gBAAgB,CAGjD,yBAHiD,EAGtB,OAAO;AAAEyC,EAAAA,iBAAF;AAAqBuB,EAAAA;AAArB,CAAP,KAAmD;AAC9E,MAAI;AACF;AACA,UAAM,CAACzC,IAAD,EAAOsB,UAAP,IAAqB,MAAMP,OAAO,CAACC,GAAR,CAAY,CAC3CrC,wBAAwB,CAACuC,iBAAD,CADmB,EAE3C3B,wBAAwB,CAAC2B,iBAAD,EAAoBuB,gBAApB,CAFmB,CAAZ,CAAjC;;AAKA,QAAI,EAACzC,IAAD,aAACA,IAAD,uBAACA,IAAI,CAAEF,IAAP,CAAJ,EAAiB;AACf,aAAO,EAAP;AACD;;AAED,WAAOwB,UAAU,CAACC,GAAX,CAAgBC,UAAD,IAAgB;AAAA;;AACpC;AACA,YAAMC,WAAW,6BAAGzB,IAAI,CAACF,IAAL,CAAU0B,UAAU,CAACE,OAArB,CAAH,2EAAoC;AACnDC,QAAAA,IAAI,EAAE,EAD6C;AAEnDC,QAAAA,WAAW,EAAE,EAFsC;AAGnDT,QAAAA,UAAU,EAAE;AAAEQ,UAAAA,IAAI,EAAE;AAAR,SAHuC;AAInDE,QAAAA,KAAK,EAAE;AACLC,UAAAA,QAAQ,EAAE,EADL;AAELC,UAAAA,SAAS,EAAE;AAFN;AAJ4C,OAArD,CAFoC,CAWpC;;AACA,YAAMC,UAAU,GAAG,CACjB;AACEC,QAAAA,SAAS,EAAE,SADb;AAEEC,QAAAA,KAAK,EAAEV,UAAU,CAACE,OAFpB;AAGES,QAAAA,WAAW,EAAE;AAHf,OADiB,CAAnB;AAOA,aAAO;AACLC,QAAAA,OAAO,EAAEZ,UAAU,CAACY,OADf;AAELT,QAAAA,IAAI,EAAEF,WAAW,CAACE,IAFb;AAGLC,QAAAA,WAAW,EAAEH,WAAW,CAACG,WAHpB;AAILS,QAAAA,cAAc,EAAEZ,WAAW,CAACN,UAAZ,CAAuBQ,IAJlC;AAKLT,QAAAA,iBAAiB,EAAExC,qBALd;AAMLmD,QAAAA,KAAK,EAAEJ,WAAW,CAACI,KANd;AAOLL,QAAAA,UAPK;AAQLQ,QAAAA;AARK,OAAP;AAUD,KA7BM,CAAP;AA8BD,GAzCD,CAyCE,OAAOM,KAAP,EAAc;AACdC,IAAAA,OAAO,CAACD,KAAR,CAAe,wCAAuCpB,iBAAkB,EAAxE,EAA2EoB,KAA3E;AACA,WAAO,EAAP;AACD;AACF,CAjDkD,CAA5C;AAmDP;AACA;AACA;;AACA,OAAO,MAAMI,kBAAkB,GAAGjE,gBAAgB,CAGhD,wBAHgD,EAGtB,OAAO;AAAEkE,EAAAA,OAAF;AAAWF,EAAAA,gBAAX;AAA6BG,EAAAA,gBAA7B;AAA+CC,EAAAA;AAA/C,CAAP,KAA2E;AACrG,MAAI;AAAA;;AACF,QAAI7C,IAAI,GAAG;AAAEF,MAAAA,IAAI,EAAE;AAAE,SAAC6C,OAAD,GAAWC;AAAb;AAAR,KAAX;;AACA,QAAI,CAACA,gBAAL,EAAuB;AACrB5C,MAAAA,IAAI,GAAG,MAAMrB,wBAAwB,CAACD,qBAAD,CAArC;AACD;;AACD,UAAM4C,UAAU,GAAG,MAAMhC,kBAAkB,CAACqD,OAAD,EAAUF,gBAAV,EAA4BI,cAA5B,CAA3C;;AAEA,QAAI,WAAC7C,IAAD,0CAAC,MAAMF,IAAP,CAAJ,EAAiB;AACf,aAAO,EAAP;AACD;;AAED,WAAOwB,UAAU,CAACC,GAAX,CAAgBC,UAAD,IAAgB;AAAA;;AACpC;AACA,YAAMC,WAAW,6BAAGzB,IAAI,CAACF,IAAL,CAAU0B,UAAU,CAACE,OAArB,CAAH,2EAAoC;AACnDC,QAAAA,IAAI,EAAE,EAD6C;AAEnDC,QAAAA,WAAW,EAAE,EAFsC;AAGnDT,QAAAA,UAAU,EAAE;AAAEQ,UAAAA,IAAI,EAAE;AAAR,SAHuC;AAInDE,QAAAA,KAAK,EAAE;AACLC,UAAAA,QAAQ,EAAE,EADL;AAELC,UAAAA,SAAS,EAAE;AAFN;AAJ4C,OAArD,CAFoC,CAWpC;;AACA,YAAMC,UAAU,GAAG,CACjB;AACEC,QAAAA,SAAS,EAAE,SADb;AAEEC,QAAAA,KAAK,EAAEV,UAAU,CAACE,OAFpB;AAGES,QAAAA,WAAW,EAAE;AAHf,OADiB,CAAnB;AAOA,aAAO;AACLC,QAAAA,OAAO,EAAEZ,UAAU,CAACY,OADf;AAELT,QAAAA,IAAI,EAAEF,WAAW,CAACE,IAFb;AAGLC,QAAAA,WAAW,EAAEH,WAAW,CAACG,WAHpB;AAILS,QAAAA,cAAc,EAAEZ,WAAW,CAACN,UAAZ,CAAuBQ,IAJlC;AAKLT,QAAAA,iBAAiB,EAAExC,qBALd;AAMLmD,QAAAA,KAAK,EAAEJ,WAAW,CAACI,KANd;AAOLL,QAAAA,UAPK;AAQLQ,QAAAA;AARK,OAAP;AAUD,KA7BM,CAAP;AA8BD,GAzCD,CAyCE,OAAOM,KAAP,EAAc;AACdC,IAAAA,OAAO,CAACD,KAAR,CAAe,gDAA+CK,OAAQ,EAAtE,EAAyEL,KAAzE;AACA,WAAO,EAAP;AACD;AACF,CAjDiD,CAA3C;AAmDP,OAAO,MAAMQ,aAAa,GAAGrE,gBAAgB,CAG3C,mBAH2C,EAGtB,OAAO;AAAEsE,EAAAA,OAAF;AAAWC,EAAAA,+BAAX;AAA4CjD,EAAAA;AAA5C,CAAP,KAAqE;AAC1F,QAAMkD,eAAe,GAAG,MAAM5D,yBAAyB,CAAC0D,OAAD,EAAUhD,WAAV,EAAuBiD,+BAAvB,CAAvD;AACA,SAAOC,eAAP;AACD,CAN4C,CAAtC;AAQP,OAAO,MAAMC,aAAa,GAAGzE,gBAAgB,CAG3C,mBAH2C,EAGtB,OAAO;AAAE2D,EAAAA,OAAF;AAAWlB,EAAAA,iBAAX;AAA8BiC,EAAAA,QAAQ,GAAGzD,WAAW,CAAC0D;AAArD,CAAP,KAAyE;AAC9F,QAAMC,gBAAgB,GAAG,MAAMxE,iBAAiB,CAAC;AAAEyE,IAAAA,UAAU,EAAE,CAAClB,OAAD;AAAd,GAAD,CAAhD;AACA,QAAMmB,cAAc,GAAG,MAAMnE,kCAAkC,CAAC,CAAC;AAAEgD,IAAAA,OAAF;AAAWlB,IAAAA;AAAX,GAAD,CAAD,CAA/D;AACA,QAAM+B,eAAe,GAAG,EAAE,GAAGM,cAAc,CAAC,CAAD,CAAnB;AAAwBJ,IAAAA,QAAxB;AAAkC3B,IAAAA,UAAU,EAAE6B,gBAAgB,CAAC,CAAD;AAA9D,GAAxB;AAEA,SAAOJ,eAAP;AACD,CAT4C,CAAtC;AAWP,OAAO,MAAMO,aAAa,GAAG/E,gBAAgB,CAC3C,mBAD2C,EAE3C,OAAO;AAAE2D,EAAAA;AAAF,CAAP,KAAuBA,OAFoB,CAAtC;AAKP,OAAO,MAAMqB,UAAU,GAAGhF,gBAAgB,CAGxC,gBAHwC,EAGtB,OAAO;AAAE2D,EAAAA,OAAF;AAAWlB,EAAAA,iBAAX;AAA8BwC,EAAAA,WAAW,GAAGhE,WAAW,CAAC0D;AAAxD,CAAP,KAA4E;AAC9F,QAAMC,gBAAgB,GAAG,MAAMxE,iBAAiB,CAAC;AAAEyE,IAAAA,UAAU,EAAE,CAAClB,OAAD;AAAd,GAAD,CAAhD;AACA,QAAMmB,cAAc,GAAG,MAAMnE,kCAAkC,CAAC,CAAC;AAAEgD,IAAAA,OAAF;AAAWlB,IAAAA;AAAX,GAAD,CAAD,CAA/D;AAEA,QAAMyC,MAAM,GAAG;AAAE,KAACvB,OAAD,GAAW,EAAE,GAAGiB,gBAAgB,CAAC,CAAD,CAArB;AAA0BK,MAAAA;AAA1B;AAAb,GAAf;AACA,QAAMT,eAAe,GAAG,EAAE,GAAGM,cAAc,CAAC,CAAD,CAAnB;AAAwBI,IAAAA;AAAxB,GAAxB;AAEA,SAAOV,eAAP;AACD,CAXyC,CAAnC;AAaP,OAAO,MAAMW,iBAAiB,GAAGnF,gBAAgB,CAAC,uBAAD,EAA0B,MAAOoF,OAAP,IAA2B;AACpG,QAAMC,YAAY,GAAG,MAAM9E,eAAe,CAAC6E,OAAO,CAACE,iBAAR,EAAD,CAA1C;AACA,SAAOD,YAAP;AACD,CAHgD,CAA1C;AAKP,OAAO,MAAME,SAAS,GAAGxF,WAAW,CAAC;AACnCmD,EAAAA,IAAI,EAAE,WAD6B;AAEnChC,EAAAA,YAFmC;AAGnCsE,EAAAA,QAAQ,EAAE,EAHyB;AAInCC,EAAAA,aAAa,EAAGC,OAAD,IAAa;AAC1BA,IAAAA,OAAO,CAACC,OAAR,CAAgBnD,eAAe,CAACoD,SAAhC,EAA2C,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC5DD,MAAAA,KAAK,CAACxE,IAAN,CAAWC,WAAX,GAAyB,EAAE,GAAGuE,KAAK,CAACxE,IAAN,CAAWC,WAAhB;AAA6B,WAAGwE,MAAM,CAACC;AAAvC,OAAzB;AACD,KAFD;AAGAL,IAAAA,OAAO,CAACC,OAAR,CAAgBvD,gBAAgB,CAACwD,SAAjC,EAA4C,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC7DD,MAAAA,KAAK,CAACxE,IAAN,CAAWC,WAAX,GAAyBwE,MAAM,CAACC,OAAhC;AACAF,MAAAA,KAAK,CAAC1E,mBAAN,GAA4BJ,4BAA4B,CAACiF,WAAzD;AACD,KAHD;AAIAN,IAAAA,OAAO,CAACC,OAAR,CAAgB/C,wBAAwB,CAACgD,SAAzC,EAAoD,CAACC,KAAD,EAAQC,MAAR,KAAmB;AACrED,MAAAA,KAAK,CAACxE,IAAN,CAAWE,IAAX,CAAgBuE,MAAM,CAACG,IAAP,CAAYC,GAA5B,IAAmCJ,MAAM,CAACC,OAA1C;AACD,KAFD;AAGAL,IAAAA,OAAO,CAACC,OAAR,CAAgB5B,mBAAmB,CAAC6B,SAApC,EAA+C,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAChE,UAAIA,MAAM,CAACC,OAAP,CAAeI,MAAf,GAAwB,CAA5B,EAA+B;AAC7BN,QAAAA,KAAK,CAACxE,IAAN,CAAWE,IAAX,CAAgBuE,MAAM,CAACG,IAAP,CAAYC,GAAZ,CAAgBzD,iBAAhC,IAAqDqD,MAAM,CAACC,OAA5D;AACAF,QAAAA,KAAK,CAACxE,IAAN,CAAWK,YAAX,GAA0BC,IAAI,CAACC,GAAL,EAA1B;AACD;AACF,KALD;AAMA8D,IAAAA,OAAO,CAACC,OAAR,CAAgB5B,mBAAmB,CAACqC,QAApC,EAA+CP,KAAD,IAAW;AACvDA,MAAAA,KAAK,CAACxE,IAAN,CAAWK,YAAX,GAA0BC,IAAI,CAACC,GAAL,EAA1B;AACD,KAFD;AAGA8D,IAAAA,OAAO,CAACC,OAAR,CAAgB1B,kBAAkB,CAACoC,OAAnC,EAA6CR,KAAD,IAAW;AACrDA,MAAAA,KAAK,CAACxE,IAAN,CAAWG,kBAAX,GAAgC,IAAhC;AACD,KAFD;AAGAkE,IAAAA,OAAO,CAACC,OAAR,CAAgB1B,kBAAkB,CAAC2B,SAAnC,EAA8C,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC/D,YAAMQ,mBAAmB,GAAGT,KAAK,CAACxE,IAAN,CAAWE,IAAX,CAAgBtB,qBAAhB,KAA0C,EAAtE;AACA4F,MAAAA,KAAK,CAACxE,IAAN,CAAWE,IAAX,CAAgBtB,qBAAhB,IAAyC,CAAC,GAAGqG,mBAAJ,EAAyB,GAAGR,MAAM,CAACC,OAAnC,CAAzC;AACAF,MAAAA,KAAK,CAACxE,IAAN,CAAWG,kBAAX,GAAgC,KAAhC;AACAqE,MAAAA,KAAK,CAACxE,IAAN,CAAWI,aAAX,GAA2BE,IAAI,CAACC,GAAL,EAA3B;AACD,KALD;AAMA8D,IAAAA,OAAO,CAACC,OAAR,CAAgB1B,kBAAkB,CAACmC,QAAnC,EAA8CP,KAAD,IAAW;AACtDA,MAAAA,KAAK,CAACxE,IAAN,CAAWG,kBAAX,GAAgC,KAAhC;AACD,KAFD;AAGAkE,IAAAA,OAAO,CAACC,OAAR,CAAgBtB,aAAa,CAAC+B,QAA9B,EAAyCP,KAAD,IAAW;AACjDA,MAAAA,KAAK,CAACxE,IAAN,CAAWS,IAAX,CAAgBC,2BAAhB,GAA8Cf,0BAA0B,CAACuF,KAAzE;AACD,KAFD;AAGAb,IAAAA,OAAO,CAACC,OAAR,CAAgBtB,aAAa,CAACgC,OAA9B,EAAwCR,KAAD,IAAW;AAChDA,MAAAA,KAAK,CAACxE,IAAN,CAAWS,IAAX,CAAgBC,2BAAhB,GAA8Cf,0BAA0B,CAACwF,YAAzE;AACD,KAFD;AAGAd,IAAAA,OAAO,CAACC,OAAR,CAAgBtB,aAAa,CAACuB,SAA9B,EAAyC,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC1DD,MAAAA,KAAK,CAACxE,IAAN,CAAWS,IAAX,CAAgBP,IAAhB,GAAuBuE,MAAM,CAACC,OAA9B;AACAF,MAAAA,KAAK,CAACxE,IAAN,CAAWS,IAAX,CAAgBC,2BAAhB,GAA8Cf,0BAA0B,CAACgF,WAAzE;AACD,KAHD;AAIAN,IAAAA,OAAO,CAACC,OAAR,CAAgBlB,aAAa,CAACmB,SAA9B,EAAyC,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC1D,YAAMW,aAAyB,GAAGZ,KAAK,CAACxE,IAAN,CAAWS,IAAX,CAAgBP,IAAlD;AACA,YAAMmF,WAAW,GAAGD,aAAa,CAACE,IAAd,CAAoBC,GAAD,IAASA,GAAG,CAACjD,OAAJ,KAAgBmC,MAAM,CAACC,OAAP,CAAepC,OAA3D,CAApB;AACA,YAAMkD,YAAY,GAAGJ,aAAa,CAACK,OAAd,CAAsBJ,WAAtB,CAArB;AACAb,MAAAA,KAAK,CAACxE,IAAN,CAAWS,IAAX,CAAgBP,IAAhB,CAAqBsF,YAArB,IAAqCf,MAAM,CAACC,OAA5C;AACD,KALD;AAMAL,IAAAA,OAAO,CAACC,OAAR,CAAgBZ,aAAa,CAACa,SAA9B,EAAyC,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC1D,YAAMiB,WAAuB,GAAG,CAAC,GAAGlB,KAAK,CAACxE,IAAN,CAAWS,IAAX,CAAgBP,IAApB,CAAhC;AACA,YAAMyF,WAAW,GAAGD,WAAW,CAACJ,IAAZ,CAAkBC,GAAD,IAASA,GAAG,CAACjD,OAAJ,KAAgBmC,MAAM,CAACC,OAAjD,CAApB;AACA,YAAMc,YAAY,GAAGE,WAAW,CAACD,OAAZ,CAAoBE,WAApB,CAArB;AACAD,MAAAA,WAAW,CAACE,MAAZ,CAAmBJ,YAAnB,EAAiC,CAAjC;AACAhB,MAAAA,KAAK,CAACxE,IAAN,CAAWS,IAAX,CAAgBP,IAAhB,GAAuBwF,WAAvB;AACD,KAND;AAOArB,IAAAA,OAAO,CAACC,OAAR,CAAgBX,UAAU,CAACY,SAA3B,EAAsC,CAACC,KAAD,EAAQC,MAAR,KAAmB;AACvDD,MAAAA,KAAK,CAACxE,IAAN,CAAWS,IAAX,CAAgBP,IAAhB,GAAuB,CAAC,GAAGsE,KAAK,CAACxE,IAAN,CAAWS,IAAX,CAAgBP,IAApB,EAA0BuE,MAAM,CAACC,OAAjC,CAAvB;AACD,KAFD;AAGAL,IAAAA,OAAO,CAACC,OAAR,CAAgBR,iBAAiB,CAACS,SAAlC,EAA6C,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC9DD,MAAAA,KAAK,CAACxE,IAAN,CAAWS,IAAX,CAAgBE,QAAhB,GAA2B,EAAE,GAAG8D,MAAM,CAACC,OAAZ;AAAqB5E,QAAAA,mBAAmB,EAAEH,0BAA0B,CAACgF;AAArE,OAA3B;AACD,KAFD;AAGAN,IAAAA,OAAO,CAACC,OAAR,CAAgBR,iBAAiB,CAACiB,QAAlC,EAA6CP,KAAD,IAAW;AACrDA,MAAAA,KAAK,CAACxE,IAAN,CAAWS,IAAX,CAAgBE,QAAhB,CAAyBb,mBAAzB,GAA+CH,0BAA0B,CAACuF,KAA1E;AACD,KAFD;AAGAb,IAAAA,OAAO,CAACC,OAAR,CAAgBR,iBAAiB,CAACkB,OAAlC,EAA4CR,KAAD,IAAW;AACpDA,MAAAA,KAAK,CAACxE,IAAN,CAAWS,IAAX,CAAgBE,QAAhB,CAAyBb,mBAAzB,GAA+CH,0BAA0B,CAACwF,YAA1E;AACD,KAFD;AAGD;AAvEkC,CAAD,CAA7B;AA0EP,eAAejB,SAAS,CAAC2B,OAAzB","sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'\nimport { pancakeBunniesAddress } from 'views/Nft/market/constants'\nimport {\n  getNftsFromCollectionApi,\n  getNftsFromCollectionSg,\n  getNftsMarketData,\n  getCollectionsApi,\n  getCollectionsSg,\n  getUserActivity,\n  combineCollectionData,\n  getCollectionSg,\n  getCollectionApi,\n  getNftsFromDifferentCollectionsApi,\n  getCompleteAccountNftData,\n  getNftsByBunnyIdSg,\n  getMarketDataForTokenIds,\n} from './helpers'\nimport {\n  State,\n  Collection,\n  ApiCollections,\n  TokenIdWithCollectionAddress,\n  NFTMarketInitializationState,\n  UserNftInitializationState,\n  NftToken,\n  NftLocation,\n  ApiSingleTokenData,\n} from './types'\n\nconst initialState: State = {\n  initializationState: NFTMarketInitializationState.UNINITIALIZED,\n  data: {\n    collections: {},\n    nfts: {},\n    isFetchingMoreNfts: false,\n    latestFetchAt: 0,\n    lastUpdateAt: Date.now(),\n    users: {},\n    user: {\n      userNftsInitializationState: UserNftInitializationState.UNINITIALIZED,\n      nfts: [],\n      activity: {\n        initializationState: UserNftInitializationState.UNINITIALIZED,\n        askOrderHistory: [],\n        buyTradeHistory: [],\n        sellTradeHistory: [],\n      },\n    },\n  },\n}\n\n/**\n * Fetch all collections data by combining data from the API (static metadata) and the Subgraph (dynamic market data)\n */\nexport const fetchCollections = createAsyncThunk<Record<string, Collection>>('nft/fetchCollections', async () => {\n  const [collections, collectionsMarket] = await Promise.all([getCollectionsApi(), getCollectionsSg()])\n  return combineCollectionData(collections, collectionsMarket)\n})\n\n/**\n * Fetch collection data by combining data from the API (static metadata) and the Subgraph (dynamic market data)\n */\nexport const fetchCollection = createAsyncThunk<Record<string, Collection>, string>(\n  'nft/fetchCollection',\n  async (collectionAddress) => {\n    const [collection, collectionMarket] = await Promise.all([\n      getCollectionApi(collectionAddress),\n      getCollectionSg(collectionAddress),\n    ])\n\n    return combineCollectionData([collection], [collectionMarket])\n  },\n)\n\n/**\n * Fetch all NFT data for a collections by combining data from the API (static metadata)\n * and the Subgraph (dynamic market data)\n * @param collectionAddress\n */\nexport const fetchNftsFromCollections = createAsyncThunk(\n  'nft/fetchNftsFromCollections',\n  async (collectionAddress: string) => {\n    try {\n      const [nfts, nftsMarket] = await Promise.all([\n        getNftsFromCollectionApi(collectionAddress),\n        getNftsFromCollectionSg(collectionAddress),\n      ])\n\n      if (!nfts?.data) {\n        return []\n      }\n\n      if (collectionAddress === pancakeBunniesAddress) {\n        return nftsMarket.map((marketData) => {\n          // The fallback is just for the testnet where some bunnies don't exist\n          const apiMetadata = nfts.data[marketData.otherId] ?? {\n            name: '',\n            description: '',\n            collection: { name: 'Pancake Bunnies' },\n            image: {\n              original: '',\n              thumbnail: '',\n            },\n          }\n          // Generating attributes field that is not returned by API but can be \"faked\" since objects are keyed with bunny id\n          const attributes = [\n            {\n              traitType: 'bunnyId',\n              value: marketData.otherId,\n              displayType: null,\n            },\n          ]\n          return {\n            tokenId: marketData.tokenId,\n            name: apiMetadata.name,\n            description: apiMetadata.description,\n            collectionName: apiMetadata.collection.name,\n            collectionAddress,\n            image: apiMetadata.image,\n            marketData,\n            attributes,\n          }\n        })\n      }\n\n      // TODO: revisit this for other collecitons\n      return []\n    } catch (error) {\n      console.error(`Failed to fetch collection NFTs for ${collectionAddress}`, error)\n      return []\n    }\n  },\n)\n\n/**\n * Fetch fresh marketdata for existing tokens in the store\n */\nexport const updateNftTokensData = createAsyncThunk<\n  NftToken[],\n  { collectionAddress: string; existingTokenIds: string[] }\n>('nft/updateNftTokensData', async ({ collectionAddress, existingTokenIds }) => {\n  try {\n    // TODO: this kinda should work for other collections too, but doublecheck during Squad integration\n    const [nfts, nftsMarket] = await Promise.all([\n      getNftsFromCollectionApi(collectionAddress),\n      getMarketDataForTokenIds(collectionAddress, existingTokenIds),\n    ])\n\n    if (!nfts?.data) {\n      return []\n    }\n\n    return nftsMarket.map((marketData) => {\n      // The fallback is just for the testnet where some bunnies don't exist\n      const apiMetadata = nfts.data[marketData.otherId] ?? {\n        name: '',\n        description: '',\n        collection: { name: 'Pancake Bunnies' },\n        image: {\n          original: '',\n          thumbnail: '',\n        },\n      }\n      // Generating attributes field that is not returned by API but can be \"faked\" since objects are keyed with bunny id\n      const attributes = [\n        {\n          traitType: 'bunnyId',\n          value: marketData.otherId,\n          displayType: null,\n        },\n      ]\n      return {\n        tokenId: marketData.tokenId,\n        name: apiMetadata.name,\n        description: apiMetadata.description,\n        collectionName: apiMetadata.collection.name,\n        collectionAddress: pancakeBunniesAddress,\n        image: apiMetadata.image,\n        marketData,\n        attributes,\n      }\n    })\n  } catch (error) {\n    console.error(`Failed to update collection NFTs for ${collectionAddress}`, error)\n    return []\n  }\n})\n\n/**\n * Fetch all 30 on sale NFTs with specified bunny id\n */\nexport const fetchNftsByBunnyId = createAsyncThunk<\n  NftToken[],\n  { bunnyId: string; existingTokenIds: string[]; existingMetadata: ApiSingleTokenData; orderDirection: 'asc' | 'desc' }\n>('nft/fetchNftsByBunnyId', async ({ bunnyId, existingTokenIds, existingMetadata, orderDirection }) => {\n  try {\n    let nfts = { data: { [bunnyId]: existingMetadata } }\n    if (!existingMetadata) {\n      nfts = await getNftsFromCollectionApi(pancakeBunniesAddress)\n    }\n    const nftsMarket = await getNftsByBunnyIdSg(bunnyId, existingTokenIds, orderDirection)\n\n    if (!nfts?.data) {\n      return []\n    }\n\n    return nftsMarket.map((marketData) => {\n      // The fallback is just for the testnet where some bunnies don't exist\n      const apiMetadata = nfts.data[marketData.otherId] ?? {\n        name: '',\n        description: '',\n        collection: { name: 'Pancake Bunnies' },\n        image: {\n          original: '',\n          thumbnail: '',\n        },\n      }\n      // Generating attributes field that is not returned by API but can be \"faked\" since objects are keyed with bunny id\n      const attributes = [\n        {\n          traitType: 'bunnyId',\n          value: marketData.otherId,\n          displayType: null,\n        },\n      ]\n      return {\n        tokenId: marketData.tokenId,\n        name: apiMetadata.name,\n        description: apiMetadata.description,\n        collectionName: apiMetadata.collection.name,\n        collectionAddress: pancakeBunniesAddress,\n        image: apiMetadata.image,\n        marketData,\n        attributes,\n      }\n    })\n  } catch (error) {\n    console.error(`Failed to fetch collection NFTs for bunny id ${bunnyId}`, error)\n    return []\n  }\n})\n\nexport const fetchUserNfts = createAsyncThunk<\n  NftToken[],\n  { account: string; profileNftWithCollectionAddress?: TokenIdWithCollectionAddress; collections: ApiCollections }\n>('nft/fetchUserNfts', async ({ account, profileNftWithCollectionAddress, collections }) => {\n  const completeNftData = await getCompleteAccountNftData(account, collections, profileNftWithCollectionAddress)\n  return completeNftData\n})\n\nexport const updateUserNft = createAsyncThunk<\n  NftToken,\n  { tokenId: string; collectionAddress: string; location?: NftLocation }\n>('nft/updateUserNft', async ({ tokenId, collectionAddress, location = NftLocation.WALLET }) => {\n  const marketDataForNft = await getNftsMarketData({ tokenId_in: [tokenId] })\n  const metadataForNft = await getNftsFromDifferentCollectionsApi([{ tokenId, collectionAddress }])\n  const completeNftData = { ...metadataForNft[0], location, marketData: marketDataForNft[0] }\n\n  return completeNftData\n})\n\nexport const removeUserNft = createAsyncThunk<string, { tokenId: string }>(\n  'nft/removeUserNft',\n  async ({ tokenId }) => tokenId,\n)\n\nexport const addUserNft = createAsyncThunk<\n  NftToken,\n  { tokenId: string; collectionAddress: string; nftLocation?: NftLocation }\n>('nft/addUserNft', async ({ tokenId, collectionAddress, nftLocation = NftLocation.WALLET }) => {\n  const marketDataForNft = await getNftsMarketData({ tokenId_in: [tokenId] })\n  const metadataForNft = await getNftsFromDifferentCollectionsApi([{ tokenId, collectionAddress }])\n\n  const tokens = { [tokenId]: { ...marketDataForNft[0], nftLocation } }\n  const completeNftData = { ...metadataForNft[0], tokens }\n\n  return completeNftData\n})\n\nexport const fetchUserActivity = createAsyncThunk('nft/fetchUserActivity', async (address: string) => {\n  const userActivity = await getUserActivity(address.toLocaleLowerCase())\n  return userActivity\n})\n\nexport const NftMarket = createSlice({\n  name: 'NftMarket',\n  initialState,\n  reducers: {},\n  extraReducers: (builder) => {\n    builder.addCase(fetchCollection.fulfilled, (state, action) => {\n      state.data.collections = { ...state.data.collections, ...action.payload }\n    })\n    builder.addCase(fetchCollections.fulfilled, (state, action) => {\n      state.data.collections = action.payload\n      state.initializationState = NFTMarketInitializationState.INITIALIZED\n    })\n    builder.addCase(fetchNftsFromCollections.fulfilled, (state, action) => {\n      state.data.nfts[action.meta.arg] = action.payload\n    })\n    builder.addCase(updateNftTokensData.fulfilled, (state, action) => {\n      if (action.payload.length > 0) {\n        state.data.nfts[action.meta.arg.collectionAddress] = action.payload\n        state.data.lastUpdateAt = Date.now()\n      }\n    })\n    builder.addCase(updateNftTokensData.rejected, (state) => {\n      state.data.lastUpdateAt = Date.now()\n    })\n    builder.addCase(fetchNftsByBunnyId.pending, (state) => {\n      state.data.isFetchingMoreNfts = true\n    })\n    builder.addCase(fetchNftsByBunnyId.fulfilled, (state, action) => {\n      const existingNftsInState = state.data.nfts[pancakeBunniesAddress] || []\n      state.data.nfts[pancakeBunniesAddress] = [...existingNftsInState, ...action.payload]\n      state.data.isFetchingMoreNfts = false\n      state.data.latestFetchAt = Date.now()\n    })\n    builder.addCase(fetchNftsByBunnyId.rejected, (state) => {\n      state.data.isFetchingMoreNfts = false\n    })\n    builder.addCase(fetchUserNfts.rejected, (state) => {\n      state.data.user.userNftsInitializationState = UserNftInitializationState.ERROR\n    })\n    builder.addCase(fetchUserNfts.pending, (state) => {\n      state.data.user.userNftsInitializationState = UserNftInitializationState.INITIALIZING\n    })\n    builder.addCase(fetchUserNfts.fulfilled, (state, action) => {\n      state.data.user.nfts = action.payload\n      state.data.user.userNftsInitializationState = UserNftInitializationState.INITIALIZED\n    })\n    builder.addCase(updateUserNft.fulfilled, (state, action) => {\n      const userNftsState: NftToken[] = state.data.user.nfts\n      const nftToUpdate = userNftsState.find((nft) => nft.tokenId === action.payload.tokenId)\n      const indexInState = userNftsState.indexOf(nftToUpdate)\n      state.data.user.nfts[indexInState] = action.payload\n    })\n    builder.addCase(removeUserNft.fulfilled, (state, action) => {\n      const copyOfState: NftToken[] = [...state.data.user.nfts]\n      const nftToRemove = copyOfState.find((nft) => nft.tokenId === action.payload)\n      const indexInState = copyOfState.indexOf(nftToRemove)\n      copyOfState.splice(indexInState, 1)\n      state.data.user.nfts = copyOfState\n    })\n    builder.addCase(addUserNft.fulfilled, (state, action) => {\n      state.data.user.nfts = [...state.data.user.nfts, action.payload]\n    })\n    builder.addCase(fetchUserActivity.fulfilled, (state, action) => {\n      state.data.user.activity = { ...action.payload, initializationState: UserNftInitializationState.INITIALIZED }\n    })\n    builder.addCase(fetchUserActivity.rejected, (state) => {\n      state.data.user.activity.initializationState = UserNftInitializationState.ERROR\n    })\n    builder.addCase(fetchUserActivity.pending, (state) => {\n      state.data.user.activity.initializationState = UserNftInitializationState.INITIALIZING\n    })\n  },\n})\n\nexport default NftMarket.reducer\n"]},"metadata":{},"sourceType":"module"}