{"ast":null,"code":"import _regeneratorRuntime from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _objectSpread from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _asyncToGenerator from\"/Volumes/evo970/lou/madDex-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import BigNumber from'bignumber.js';import{LotteryStatus}from'config/constants/types';import{multicallv2}from'utils/multicall';import lotteryV2Abi from'config/abi/lotteryV2.json';import{NUM_ROUNDS_TO_CHECK_FOR_REWARDS}from'config/constants/lottery';import{getLotteryV2Address}from'utils/addressHelpers';import{BIG_ZERO}from'utils/bigNumber';import{fetchUserTicketsForMultipleRounds}from'./getUserTicketsData';import{MAX_LOTTERIES_REQUEST_SIZE}from'./getLotteriesData';var lotteryAddress=getLotteryV2Address();var fetchCakeRewardsForTickets=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(winningTickets){var calls,cakeRewards,cakeTotal,ticketsWithUnclaimedRewards;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:calls=winningTickets.map(function(winningTicket){var roundId=winningTicket.roundId,id=winningTicket.id,rewardBracket=winningTicket.rewardBracket;return{name:'viewRewardsForTicketId',address:lotteryAddress,params:[roundId,id,rewardBracket]};});_context.prev=1;_context.next=4;return multicallv2(lotteryV2Abi,calls);case 4:cakeRewards=_context.sent;cakeTotal=cakeRewards.reduce(function(accum,cakeReward){return accum.plus(new BigNumber(cakeReward[0].toString()));},BIG_ZERO);ticketsWithUnclaimedRewards=winningTickets.map(function(winningTicket,index){return _objectSpread(_objectSpread({},winningTicket),{},{cakeReward:cakeRewards[index]});});return _context.abrupt(\"return\",{ticketsWithUnclaimedRewards:ticketsWithUnclaimedRewards,cakeTotal:cakeTotal});case 10:_context.prev=10;_context.t0=_context[\"catch\"](1);console.error(_context.t0);return _context.abrupt(\"return\",{ticketsWithUnclaimedRewards:null,cakeTotal:null});case 14:case\"end\":return _context.stop();}}},_callee,null,[[1,10]]);}));return function fetchCakeRewardsForTickets(_x){return _ref.apply(this,arguments);};}();var getRewardBracketByNumber=function getRewardBracketByNumber(ticketNumber,finalNumber){// Winning numbers are evaluated right-to-left in the smart contract, so we reverse their order for validation here:\n// i.e. '1123456' should be evaluated as '6543211'\nvar ticketNumAsArray=ticketNumber.split('').reverse();var winningNumsAsArray=finalNumber.split('').reverse();var matchingNumbers=[];// The number at index 6 in all tickets is 1 and will always match, so finish at index 5\nfor(var index=0;index<winningNumsAsArray.length-1;index++){if(ticketNumAsArray[index]!==winningNumsAsArray[index]){break;}matchingNumbers.push(ticketNumAsArray[index]);}// Reward brackets refer to indexes, 0 = 1 match, 5 = 6 matches. Deduct 1 from matchingNumbers' length to get the reward bracket\nvar rewardBracket=matchingNumbers.length-1;return rewardBracket;};export var getWinningTickets=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(roundDataAndUserTickets){var roundId,userTickets,finalNumber,ticketsWithRewardBrackets,allWinningTickets,unclaimedWinningTickets,_yield$fetchCakeRewar,ticketsWithUnclaimedRewards,cakeTotal;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:roundId=roundDataAndUserTickets.roundId,userTickets=roundDataAndUserTickets.userTickets,finalNumber=roundDataAndUserTickets.finalNumber;ticketsWithRewardBrackets=userTickets.map(function(ticket){return{roundId:roundId,id:ticket.id,number:ticket.number,status:ticket.status,rewardBracket:getRewardBracketByNumber(ticket.number,finalNumber)};});// A rewardBracket of -1 means no matches. 0 and above means there has been a match\nallWinningTickets=ticketsWithRewardBrackets.filter(function(ticket){return ticket.rewardBracket>=0;});// If ticket.status is true, the ticket has already been claimed\nunclaimedWinningTickets=allWinningTickets.filter(function(ticket){return!ticket.status;});if(!(unclaimedWinningTickets.length>0)){_context2.next=11;break;}_context2.next=7;return fetchCakeRewardsForTickets(unclaimedWinningTickets);case 7:_yield$fetchCakeRewar=_context2.sent;ticketsWithUnclaimedRewards=_yield$fetchCakeRewar.ticketsWithUnclaimedRewards;cakeTotal=_yield$fetchCakeRewar.cakeTotal;return _context2.abrupt(\"return\",{ticketsWithUnclaimedRewards:ticketsWithUnclaimedRewards,allWinningTickets:allWinningTickets,cakeTotal:cakeTotal,roundId:roundId});case 11:if(!(allWinningTickets.length>0)){_context2.next=13;break;}return _context2.abrupt(\"return\",{ticketsWithUnclaimedRewards:null,allWinningTickets:allWinningTickets,cakeTotal:null,roundId:roundId});case 13:return _context2.abrupt(\"return\",null);case 14:case\"end\":return _context2.stop();}}},_callee2);}));return function getWinningTickets(_x2){return _ref2.apply(this,arguments);};}();var getWinningNumbersForRound=function getWinningNumbersForRound(targetRoundId,lotteriesData){var targetRound=lotteriesData.find(function(pastLottery){return pastLottery.id===targetRoundId;});return targetRound===null||targetRound===void 0?void 0:targetRound.finalNumber;};var fetchUnclaimedUserRewards=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(account,userLotteryData,lotteriesData,currentLotteryId){var rounds,roundsInRange,claimableRounds,roundsWithPossibleWinnings,roundsToCheck,idsToCheck,userTicketData,roundsWithTickets,roundDataAndWinningTickets,winningTicketsForPastRounds,roundsWithWinningTickets,roundsWithUnclaimedWinningTickets;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:rounds=userLotteryData.rounds;// If there is no user round history - return an empty array\nif(!(rounds.length===0)){_context3.next=3;break;}return _context3.abrupt(\"return\",[]);case 3:if(!(userLotteryData.account.toLowerCase()!==account.toLowerCase())){_context3.next=5;break;}return _context3.abrupt(\"return\",[]);case 5:// Filter out rounds without subgraph data (i.e. >100 rounds ago)\nroundsInRange=rounds.filter(function(round){var lastCheckableRoundId=parseInt(currentLotteryId,10)-MAX_LOTTERIES_REQUEST_SIZE;var roundId=parseInt(round.lotteryId,10);return roundId>=lastCheckableRoundId;});// Filter out non-claimable rounds\nclaimableRounds=roundsInRange.filter(function(round){return round.status.toLowerCase()===LotteryStatus.CLAIMABLE;});// Rounds with no tickets claimed OR rounds where a user has over 100 tickets, could have prizes\nroundsWithPossibleWinnings=claimableRounds.filter(function(round){return!round.claimed||parseInt(round.totalTickets,10)>100;});// Check the X  most recent rounds, where X is NUM_ROUNDS_TO_CHECK_FOR_REWARDS\nroundsToCheck=roundsWithPossibleWinnings.slice(0,NUM_ROUNDS_TO_CHECK_FOR_REWARDS);if(!(roundsToCheck.length>0)){_context3.next=22;break;}idsToCheck=roundsToCheck.map(function(round){return round.lotteryId;});_context3.next=13;return fetchUserTicketsForMultipleRounds(idsToCheck,account);case 13:userTicketData=_context3.sent;roundsWithTickets=userTicketData.filter(function(roundData){var _roundData$userTicket;return(roundData===null||roundData===void 0?void 0:(_roundData$userTicket=roundData.userTickets)===null||_roundData$userTicket===void 0?void 0:_roundData$userTicket.length)>0;});roundDataAndWinningTickets=roundsWithTickets.map(function(roundData){return _objectSpread(_objectSpread({},roundData),{},{finalNumber:getWinningNumbersForRound(roundData.roundId,lotteriesData)});});_context3.next=18;return Promise.all(roundDataAndWinningTickets.map(function(roundData){return getWinningTickets(roundData);}));case 18:winningTicketsForPastRounds=_context3.sent;// Filter out null values (returned when no winning tickets found for past round)\nroundsWithWinningTickets=winningTicketsForPastRounds.filter(function(winningTicketData){return winningTicketData!==null;});// Filter to only rounds with unclaimed tickets\nroundsWithUnclaimedWinningTickets=roundsWithWinningTickets.filter(function(winningTicketData){return winningTicketData.ticketsWithUnclaimedRewards;});return _context3.abrupt(\"return\",roundsWithUnclaimedWinningTickets);case 22:return _context3.abrupt(\"return\",[]);case 23:case\"end\":return _context3.stop();}}},_callee3);}));return function fetchUnclaimedUserRewards(_x3,_x4,_x5,_x6){return _ref3.apply(this,arguments);};}();export default fetchUnclaimedUserRewards;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/lottery/fetchUnclaimedUserRewards.ts"],"names":["BigNumber","LotteryStatus","multicallv2","lotteryV2Abi","NUM_ROUNDS_TO_CHECK_FOR_REWARDS","getLotteryV2Address","BIG_ZERO","fetchUserTicketsForMultipleRounds","MAX_LOTTERIES_REQUEST_SIZE","lotteryAddress","fetchCakeRewardsForTickets","winningTickets","calls","map","winningTicket","roundId","id","rewardBracket","name","address","params","cakeRewards","cakeTotal","reduce","accum","cakeReward","plus","toString","ticketsWithUnclaimedRewards","index","console","error","getRewardBracketByNumber","ticketNumber","finalNumber","ticketNumAsArray","split","reverse","winningNumsAsArray","matchingNumbers","length","push","getWinningTickets","roundDataAndUserTickets","userTickets","ticketsWithRewardBrackets","ticket","number","status","allWinningTickets","filter","unclaimedWinningTickets","getWinningNumbersForRound","targetRoundId","lotteriesData","targetRound","find","pastLottery","fetchUnclaimedUserRewards","account","userLotteryData","currentLotteryId","rounds","toLowerCase","roundsInRange","round","lastCheckableRoundId","parseInt","lotteryId","claimableRounds","CLAIMABLE","roundsWithPossibleWinnings","claimed","totalTickets","roundsToCheck","slice","idsToCheck","userTicketData","roundsWithTickets","roundData","roundDataAndWinningTickets","Promise","all","winningTicketsForPastRounds","roundsWithWinningTickets","winningTicketData","roundsWithUnclaimedWinningTickets"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js'\nimport { ethers } from 'ethers'\nimport { LotteryStatus, LotteryTicket, LotteryTicketClaimData } from 'config/constants/types'\nimport { LotteryUserGraphEntity, LotteryRoundGraphEntity } from 'state/types'\nimport { multicallv2 } from 'utils/multicall'\nimport lotteryV2Abi from 'config/abi/lotteryV2.json'\nimport { NUM_ROUNDS_TO_CHECK_FOR_REWARDS } from 'config/constants/lottery'\nimport { getLotteryV2Address } from 'utils/addressHelpers'\nimport { BIG_ZERO } from 'utils/bigNumber'\nimport { fetchUserTicketsForMultipleRounds } from './getUserTicketsData'\nimport { MAX_LOTTERIES_REQUEST_SIZE } from './getLotteriesData'\n\ninterface RoundDataAndUserTickets {\n  roundId: string\n  userTickets: LotteryTicket[]\n  finalNumber: string\n}\n\nconst lotteryAddress = getLotteryV2Address()\n\nconst fetchCakeRewardsForTickets = async (\n  winningTickets: LotteryTicket[],\n): Promise<{ ticketsWithUnclaimedRewards: LotteryTicket[]; cakeTotal: BigNumber }> => {\n  const calls = winningTickets.map((winningTicket) => {\n    const { roundId, id, rewardBracket } = winningTicket\n    return {\n      name: 'viewRewardsForTicketId',\n      address: lotteryAddress,\n      params: [roundId, id, rewardBracket],\n    }\n  })\n\n  try {\n    const cakeRewards = await multicallv2(lotteryV2Abi, calls)\n\n    const cakeTotal = cakeRewards.reduce((accum: BigNumber, cakeReward: ethers.BigNumber[]) => {\n      return accum.plus(new BigNumber(cakeReward[0].toString()))\n    }, BIG_ZERO)\n\n    const ticketsWithUnclaimedRewards = winningTickets.map((winningTicket, index) => {\n      return { ...winningTicket, cakeReward: cakeRewards[index] }\n    })\n    return { ticketsWithUnclaimedRewards, cakeTotal }\n  } catch (error) {\n    console.error(error)\n    return { ticketsWithUnclaimedRewards: null, cakeTotal: null }\n  }\n}\n\nconst getRewardBracketByNumber = (ticketNumber: string, finalNumber: string): number => {\n  // Winning numbers are evaluated right-to-left in the smart contract, so we reverse their order for validation here:\n  // i.e. '1123456' should be evaluated as '6543211'\n  const ticketNumAsArray = ticketNumber.split('').reverse()\n  const winningNumsAsArray = finalNumber.split('').reverse()\n  const matchingNumbers = []\n\n  // The number at index 6 in all tickets is 1 and will always match, so finish at index 5\n  for (let index = 0; index < winningNumsAsArray.length - 1; index++) {\n    if (ticketNumAsArray[index] !== winningNumsAsArray[index]) {\n      break\n    }\n    matchingNumbers.push(ticketNumAsArray[index])\n  }\n\n  // Reward brackets refer to indexes, 0 = 1 match, 5 = 6 matches. Deduct 1 from matchingNumbers' length to get the reward bracket\n  const rewardBracket = matchingNumbers.length - 1\n  return rewardBracket\n}\n\nexport const getWinningTickets = async (\n  roundDataAndUserTickets: RoundDataAndUserTickets,\n): Promise<LotteryTicketClaimData> => {\n  const { roundId, userTickets, finalNumber } = roundDataAndUserTickets\n\n  const ticketsWithRewardBrackets = userTickets.map((ticket) => {\n    return {\n      roundId,\n      id: ticket.id,\n      number: ticket.number,\n      status: ticket.status,\n      rewardBracket: getRewardBracketByNumber(ticket.number, finalNumber),\n    }\n  })\n\n  // A rewardBracket of -1 means no matches. 0 and above means there has been a match\n  const allWinningTickets = ticketsWithRewardBrackets.filter((ticket) => {\n    return ticket.rewardBracket >= 0\n  })\n\n  // If ticket.status is true, the ticket has already been claimed\n  const unclaimedWinningTickets = allWinningTickets.filter((ticket) => {\n    return !ticket.status\n  })\n\n  if (unclaimedWinningTickets.length > 0) {\n    const { ticketsWithUnclaimedRewards, cakeTotal } = await fetchCakeRewardsForTickets(unclaimedWinningTickets)\n    return { ticketsWithUnclaimedRewards, allWinningTickets, cakeTotal, roundId }\n  }\n\n  if (allWinningTickets.length > 0) {\n    return { ticketsWithUnclaimedRewards: null, allWinningTickets, cakeTotal: null, roundId }\n  }\n\n  return null\n}\n\nconst getWinningNumbersForRound = (targetRoundId: string, lotteriesData: LotteryRoundGraphEntity[]) => {\n  const targetRound = lotteriesData.find((pastLottery) => pastLottery.id === targetRoundId)\n  return targetRound?.finalNumber\n}\n\nconst fetchUnclaimedUserRewards = async (\n  account: string,\n  userLotteryData: LotteryUserGraphEntity,\n  lotteriesData: LotteryRoundGraphEntity[],\n  currentLotteryId: string,\n): Promise<LotteryTicketClaimData[]> => {\n  const { rounds } = userLotteryData\n\n  // If there is no user round history - return an empty array\n  if (rounds.length === 0) {\n    return []\n  }\n\n  // If the web3 provider account doesn't equal the userLotteryData account, return an empty array - this is effectively a loading state as the user switches accounts\n  if (userLotteryData.account.toLowerCase() !== account.toLowerCase()) {\n    return []\n  }\n\n  // Filter out rounds without subgraph data (i.e. >100 rounds ago)\n  const roundsInRange = rounds.filter((round) => {\n    const lastCheckableRoundId = parseInt(currentLotteryId, 10) - MAX_LOTTERIES_REQUEST_SIZE\n    const roundId = parseInt(round.lotteryId, 10)\n    return roundId >= lastCheckableRoundId\n  })\n\n  // Filter out non-claimable rounds\n  const claimableRounds = roundsInRange.filter((round) => {\n    return round.status.toLowerCase() === LotteryStatus.CLAIMABLE\n  })\n\n  // Rounds with no tickets claimed OR rounds where a user has over 100 tickets, could have prizes\n  const roundsWithPossibleWinnings = claimableRounds.filter((round) => {\n    return !round.claimed || parseInt(round.totalTickets, 10) > 100\n  })\n\n  // Check the X  most recent rounds, where X is NUM_ROUNDS_TO_CHECK_FOR_REWARDS\n  const roundsToCheck = roundsWithPossibleWinnings.slice(0, NUM_ROUNDS_TO_CHECK_FOR_REWARDS)\n\n  if (roundsToCheck.length > 0) {\n    const idsToCheck = roundsToCheck.map((round) => round.lotteryId)\n    const userTicketData = await fetchUserTicketsForMultipleRounds(idsToCheck, account)\n    const roundsWithTickets = userTicketData.filter((roundData) => roundData?.userTickets?.length > 0)\n\n    const roundDataAndWinningTickets = roundsWithTickets.map((roundData) => {\n      return { ...roundData, finalNumber: getWinningNumbersForRound(roundData.roundId, lotteriesData) }\n    })\n\n    const winningTicketsForPastRounds = await Promise.all(\n      roundDataAndWinningTickets.map((roundData) => getWinningTickets(roundData)),\n    )\n\n    // Filter out null values (returned when no winning tickets found for past round)\n    const roundsWithWinningTickets = winningTicketsForPastRounds.filter(\n      (winningTicketData) => winningTicketData !== null,\n    )\n\n    // Filter to only rounds with unclaimed tickets\n    const roundsWithUnclaimedWinningTickets = roundsWithWinningTickets.filter(\n      (winningTicketData) => winningTicketData.ticketsWithUnclaimedRewards,\n    )\n\n    return roundsWithUnclaimedWinningTickets\n  }\n  // All rounds claimed, return empty array\n  return []\n}\n\nexport default fetchUnclaimedUserRewards\n"]},"metadata":{},"sourceType":"module"}