{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport { ProfileAvatarFetchStatus } from 'state/types';\nimport { getProfile, getProfileAvatar, getUsername } from './helpers';\nconst initialState = {\n  isInitialized: false,\n  isLoading: true,\n  hasRegistered: false,\n  data: null,\n  profileAvatars: {}\n};\nexport const fetchProfileAvatar = createAsyncThunk('profile/fetchProfileAvatar', async account => {\n  const {\n    nft,\n    hasRegistered\n  } = await getProfileAvatar(account);\n  return {\n    account,\n    nft,\n    hasRegistered\n  };\n});\nexport const fetchProfileUsername = createAsyncThunk('profile/fetchProfileUsername', async ({\n  account,\n  hasRegistered\n}) => {\n  if (!hasRegistered) {\n    return {\n      account,\n      username: ''\n    };\n  }\n\n  const username = await getUsername(account);\n  return {\n    account,\n    username\n  };\n});\nexport const profileSlice = createSlice({\n  name: 'profile',\n  initialState,\n  reducers: {\n    profileFetchStart: state => {\n      state.isLoading = true;\n    },\n    profileFetchSucceeded: (state, action) => {\n      const {\n        profile,\n        hasRegistered\n      } = action.payload;\n      state.isInitialized = true;\n      state.isLoading = false;\n      state.hasRegistered = hasRegistered;\n      state.data = profile;\n    },\n    profileFetchFailed: state => {\n      state.isLoading = false;\n      state.isInitialized = true;\n    },\n    profileClear: () => ({ ...initialState,\n      isLoading: false\n    }),\n    addPoints: (state, action) => {\n      state.data.points += action.payload;\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(fetchProfileUsername.pending, (state, action) => {\n      const {\n        account\n      } = action.meta.arg;\n\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = { ...state.profileAvatars[account],\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHING\n        };\n      } else {\n        state.profileAvatars[account] = {\n          hasRegistered: false,\n          username: null,\n          nft: null,\n          // I think in theory this else should never be reached since we only check for username after we checked for profile/avatar\n          // just in case I set isFetchingAvatar will be ProfileAvatarFetchStatus.FETCHED at this point to avoid refetching\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHING,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED\n        };\n      }\n    });\n    builder.addCase(fetchProfileUsername.fulfilled, (state, action) => {\n      const {\n        account,\n        username\n      } = action.payload;\n\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = { ...state.profileAvatars[account],\n          username,\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHED\n        };\n      } else {\n        state.profileAvatars[account] = {\n          username,\n          nft: null,\n          hasRegistered: true,\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n          // I think in theory this else should never be reached since we only check for username after we checked for profile/avatar\n          // just in case I set isFetchingAvatar will be ProfileAvatarFetchStatus.FETCHED at this point to avoid refetching\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED\n        };\n      }\n    });\n    builder.addCase(fetchProfileUsername.rejected, (state, action) => {\n      const {\n        account\n      } = action.meta.arg;\n\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = { ...state.profileAvatars[account],\n          username: '',\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHED\n        };\n      } else {\n        state.profileAvatars[account] = {\n          hasRegistered: false,\n          username: '',\n          nft: null,\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED\n        };\n      }\n    });\n    builder.addCase(fetchProfileAvatar.pending, (state, action) => {\n      const account = action.meta.arg;\n\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = { ...state.profileAvatars[account],\n          hasRegistered: false,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHING\n        };\n      } else {\n        state.profileAvatars[account] = {\n          username: null,\n          nft: null,\n          hasRegistered: false,\n          usernameFetchStatus: ProfileAvatarFetchStatus.NOT_FETCHED,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHING\n        };\n      }\n    });\n    builder.addCase(fetchProfileAvatar.fulfilled, (state, action) => {\n      const {\n        account,\n        nft,\n        hasRegistered\n      } = action.payload;\n\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = { ...state.profileAvatars[account],\n          nft,\n          hasRegistered,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED\n        };\n      } else {\n        state.profileAvatars[account] = {\n          username: null,\n          nft,\n          hasRegistered,\n          usernameFetchStatus: ProfileAvatarFetchStatus.NOT_FETCHED,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED\n        };\n      }\n    });\n    builder.addCase(fetchProfileAvatar.rejected, (state, action) => {\n      const account = action.meta.arg;\n\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = { ...state.profileAvatars[account],\n          nft: null,\n          hasRegistered: false,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED\n        };\n      } else {\n        state.profileAvatars[account] = {\n          username: null,\n          nft: null,\n          hasRegistered: false,\n          usernameFetchStatus: ProfileAvatarFetchStatus.NOT_FETCHED,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED\n        };\n      }\n    });\n  }\n}); // Actions\n\nexport const {\n  profileFetchStart,\n  profileFetchSucceeded,\n  profileFetchFailed,\n  profileClear,\n  addPoints\n} = profileSlice.actions; // Thunks\n// TODO: this should be an AsyncThunk\n\nexport const fetchProfile = address => async dispatch => {\n  try {\n    dispatch(profileFetchStart());\n    const response = await getProfile(address);\n    dispatch(profileFetchSucceeded(response));\n  } catch (e) {\n    console.error(e);\n    dispatch(profileFetchFailed());\n  }\n};\nexport default profileSlice.reducer;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/profile/index.tsx"],"names":["createAsyncThunk","createSlice","ProfileAvatarFetchStatus","getProfile","getProfileAvatar","getUsername","initialState","isInitialized","isLoading","hasRegistered","data","profileAvatars","fetchProfileAvatar","account","nft","fetchProfileUsername","username","profileSlice","name","reducers","profileFetchStart","state","profileFetchSucceeded","action","profile","payload","profileFetchFailed","profileClear","addPoints","points","extraReducers","builder","addCase","pending","meta","arg","usernameFetchStatus","FETCHING","avatarFetchStatus","FETCHED","fulfilled","rejected","NOT_FETCHED","actions","fetchProfile","address","dispatch","response","e","console","error","reducer"],"mappings":"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","sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport { ProfileState, ProfileAvatarFetchStatus } from 'state/types'\nimport type { AppDispatch } from 'state'\nimport { NftToken } from 'state/nftMarket/types'\nimport { getProfile, getProfileAvatar, GetProfileResponse, getUsername } from './helpers'\n\nconst initialState: ProfileState = {\n  isInitialized: false,\n  isLoading: true,\n  hasRegistered: false,\n  data: null,\n  profileAvatars: {},\n}\n\nexport const fetchProfileAvatar = createAsyncThunk<{ account: string; nft: NftToken; hasRegistered: boolean }, string>(\n  'profile/fetchProfileAvatar',\n  async (account) => {\n    const { nft, hasRegistered } = await getProfileAvatar(account)\n    return { account, nft, hasRegistered }\n  },\n)\n\nexport const fetchProfileUsername = createAsyncThunk<\n  { account: string; username: string },\n  { account: string; hasRegistered: boolean }\n>('profile/fetchProfileUsername', async ({ account, hasRegistered }) => {\n  if (!hasRegistered) {\n    return { account, username: '' }\n  }\n  const username = await getUsername(account)\n  return { account, username }\n})\n\nexport const profileSlice = createSlice({\n  name: 'profile',\n  initialState,\n  reducers: {\n    profileFetchStart: (state) => {\n      state.isLoading = true\n    },\n    profileFetchSucceeded: (state, action: PayloadAction<GetProfileResponse>) => {\n      const { profile, hasRegistered } = action.payload\n\n      state.isInitialized = true\n      state.isLoading = false\n      state.hasRegistered = hasRegistered\n      state.data = profile\n    },\n    profileFetchFailed: (state) => {\n      state.isLoading = false\n      state.isInitialized = true\n    },\n    profileClear: () => ({\n      ...initialState,\n      isLoading: false,\n    }),\n    addPoints: (state, action: PayloadAction<number>) => {\n      state.data.points += action.payload\n    },\n  },\n  extraReducers: (builder) => {\n    builder.addCase(fetchProfileUsername.pending, (state, action) => {\n      const { account } = action.meta.arg\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = {\n          ...state.profileAvatars[account],\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHING,\n        }\n      } else {\n        state.profileAvatars[account] = {\n          hasRegistered: false,\n          username: null,\n          nft: null,\n          // I think in theory this else should never be reached since we only check for username after we checked for profile/avatar\n          // just in case I set isFetchingAvatar will be ProfileAvatarFetchStatus.FETCHED at this point to avoid refetching\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHING,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      }\n    })\n    builder.addCase(fetchProfileUsername.fulfilled, (state, action) => {\n      const { account, username } = action.payload\n\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = {\n          ...state.profileAvatars[account],\n          username,\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      } else {\n        state.profileAvatars[account] = {\n          username,\n          nft: null,\n          hasRegistered: true,\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n          // I think in theory this else should never be reached since we only check for username after we checked for profile/avatar\n          // just in case I set isFetchingAvatar will be ProfileAvatarFetchStatus.FETCHED at this point to avoid refetching\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      }\n    })\n    builder.addCase(fetchProfileUsername.rejected, (state, action) => {\n      const { account } = action.meta.arg\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = {\n          ...state.profileAvatars[account],\n          username: '',\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      } else {\n        state.profileAvatars[account] = {\n          hasRegistered: false,\n          username: '',\n          nft: null,\n          usernameFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      }\n    })\n    builder.addCase(fetchProfileAvatar.pending, (state, action) => {\n      const account = action.meta.arg\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = {\n          ...state.profileAvatars[account],\n          hasRegistered: false,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHING,\n        }\n      } else {\n        state.profileAvatars[account] = {\n          username: null,\n          nft: null,\n          hasRegistered: false,\n          usernameFetchStatus: ProfileAvatarFetchStatus.NOT_FETCHED,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHING,\n        }\n      }\n    })\n    builder.addCase(fetchProfileAvatar.fulfilled, (state, action) => {\n      const { account, nft, hasRegistered } = action.payload\n\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = {\n          ...state.profileAvatars[account],\n          nft,\n          hasRegistered,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      } else {\n        state.profileAvatars[account] = {\n          username: null,\n          nft,\n          hasRegistered,\n          usernameFetchStatus: ProfileAvatarFetchStatus.NOT_FETCHED,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      }\n    })\n    builder.addCase(fetchProfileAvatar.rejected, (state, action) => {\n      const account = action.meta.arg\n\n      if (state.profileAvatars[account]) {\n        state.profileAvatars[account] = {\n          ...state.profileAvatars[account],\n          nft: null,\n          hasRegistered: false,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      } else {\n        state.profileAvatars[account] = {\n          username: null,\n          nft: null,\n          hasRegistered: false,\n          usernameFetchStatus: ProfileAvatarFetchStatus.NOT_FETCHED,\n          avatarFetchStatus: ProfileAvatarFetchStatus.FETCHED,\n        }\n      }\n    })\n  },\n})\n\n// Actions\nexport const { profileFetchStart, profileFetchSucceeded, profileFetchFailed, profileClear, addPoints } =\n  profileSlice.actions\n\n// Thunks\n// TODO: this should be an AsyncThunk\nexport const fetchProfile = (address: string) => async (dispatch: AppDispatch) => {\n  try {\n    dispatch(profileFetchStart())\n    const response = await getProfile(address)\n    dispatch(profileFetchSucceeded(response))\n  } catch (e) {\n    console.error(e)\n    dispatch(profileFetchFailed())\n  }\n}\n\nexport default profileSlice.reducer\n"]},"metadata":{},"sourceType":"module"}