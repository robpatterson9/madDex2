{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport { ethers } from 'ethers';\nimport { formatUnits } from 'ethers/lib/utils';\nimport maxBy from 'lodash/maxBy';\nimport merge from 'lodash/merge';\nimport range from 'lodash/range';\nimport { BIG_ZERO } from 'utils/bigNumber';\nimport { HistoryFilter, PredictionStatus, BetPosition, LeaderboardLoadingState } from 'state/types';\nimport { getPredictionsContract } from 'utils/contractHelpers';\nimport { FUTURE_ROUND_COUNT, LEADERBOARD_MIN_ROUNDS_PLAYED, PAST_ROUND_COUNT, ROUNDS_PER_PAGE, ROUND_BUFFER } from './config';\nimport { getBetHistory, transformBetResponse, makeFutureRoundResponse, makeRoundData, getRoundsData, getPredictionData, getLedgerData, makeLedgerData, serializePredictionsRoundsResponse, getClaimStatuses, fetchUsersRoundsLength, fetchUserRounds, getPredictionUsers, transformUserResponse, LEADERBOARD_RESULTS_PER_PAGE, getPredictionUser } from './helpers';\nconst initialState = {\n  status: PredictionStatus.INITIAL,\n  isLoading: false,\n  isHistoryPaneOpen: false,\n  isChartPaneOpen: false,\n  isFetchingHistory: false,\n  historyFilter: HistoryFilter.ALL,\n  currentEpoch: 0,\n  intervalSeconds: 300,\n  minBetAmount: '10000000000000',\n  bufferSeconds: 60,\n  lastOraclePrice: BIG_ZERO.toJSON(),\n  rounds: {},\n  history: [],\n  totalHistory: 0,\n  currentHistoryPage: 1,\n  hasHistoryLoaded: false,\n  ledgers: {},\n  claimableStatuses: {},\n  leaderboard: {\n    selectedAddress: null,\n    loadingState: LeaderboardLoadingState.INITIAL,\n    filters: {\n      address: null,\n      orderBy: 'netBNB',\n      timePeriod: 'all'\n    },\n    skip: 0,\n    hasMoreResults: true,\n    addressResults: {},\n    results: []\n  }\n}; // Thunks\n\nexport const initializePredictions = createAsyncThunk('predictions/intialize', async (account = null) => {\n  // Static values\n  const marketData = await getPredictionData();\n  const epochs = marketData.currentEpoch > PAST_ROUND_COUNT ? range(marketData.currentEpoch, marketData.currentEpoch - PAST_ROUND_COUNT) : [marketData.currentEpoch]; // Round data\n\n  const roundsResponse = await getRoundsData(epochs);\n  const initialRoundData = roundsResponse.reduce((accum, roundResponse) => {\n    const reduxNodeRound = serializePredictionsRoundsResponse(roundResponse);\n    return { ...accum,\n      [reduxNodeRound.epoch.toString()]: reduxNodeRound\n    };\n  }, {});\n  const initializedData = { ...marketData,\n    rounds: initialRoundData,\n    ledgers: {},\n    claimableStatuses: {}\n  };\n\n  if (!account) {\n    return initializedData;\n  } // Bet data\n\n\n  const ledgerResponses = await getLedgerData(account, epochs); // Claim statuses\n\n  const claimableStatuses = await getClaimStatuses(account, epochs);\n  return merge({}, initializedData, {\n    ledgers: makeLedgerData(account, ledgerResponses, epochs),\n    claimableStatuses\n  });\n});\nexport const fetchRound = createAsyncThunk('predictions/fetchRound', async epoch => {\n  const predictionContract = getPredictionsContract();\n  const response = await predictionContract.rounds(epoch);\n  return serializePredictionsRoundsResponse(response);\n});\nexport const fetchRounds = createAsyncThunk('predictions/fetchRounds', async epochs => {\n  const rounds = await getRoundsData(epochs);\n  return rounds.reduce((accum, round) => {\n    if (!round) {\n      return accum;\n    }\n\n    const reduxNodeRound = serializePredictionsRoundsResponse(round);\n    return { ...accum,\n      [reduxNodeRound.epoch.toString()]: reduxNodeRound\n    };\n  }, {});\n});\nexport const fetchMarketData = createAsyncThunk('predictions/fetchMarketData', async () => {\n  const marketData = await getPredictionData();\n  return marketData;\n});\nexport const fetchLedgerData = createAsyncThunk('predictions/fetchLedgerData', async ({\n  account,\n  epochs\n}) => {\n  const ledgers = await getLedgerData(account, epochs);\n  return makeLedgerData(account, ledgers, epochs);\n});\nexport const fetchClaimableStatuses = createAsyncThunk('predictions/fetchClaimableStatuses', async ({\n  account,\n  epochs\n}) => {\n  const ledgers = await getClaimStatuses(account, epochs);\n  return ledgers;\n});\nexport const fetchHistory = createAsyncThunk('predictions/fetchHistory', async ({\n  account,\n  claimed\n}) => {\n  const response = await getBetHistory({\n    user: account.toLowerCase(),\n    claimed\n  });\n  const bets = response.map(transformBetResponse);\n  return {\n    account,\n    bets\n  };\n});\nexport const fetchNodeHistory = createAsyncThunk('predictions/fetchNodeHistory', async ({\n  account,\n  page = 1\n}) => {\n  const userRoundsLength = await fetchUsersRoundsLength(account);\n  const emptyResult = {\n    bets: [],\n    claimableStatuses: {},\n    totalHistory: userRoundsLength.toNumber()\n  };\n  const maxPages = userRoundsLength.lte(ROUNDS_PER_PAGE) ? 1 : Math.ceil(userRoundsLength.toNumber() / ROUNDS_PER_PAGE);\n\n  if (userRoundsLength.eq(0)) {\n    return emptyResult;\n  }\n\n  if (page > maxPages) {\n    return emptyResult;\n  }\n\n  const cursor = userRoundsLength.sub(ROUNDS_PER_PAGE * page); // If the page request is the final one we only want to retrieve the amount of rounds up to the next cursor.\n\n  const size = maxPages === page ? userRoundsLength.sub(ROUNDS_PER_PAGE * (page - 1)) // Previous page's cursor\n  .toNumber() : ROUNDS_PER_PAGE;\n  const userRounds = await fetchUserRounds(account, cursor.lt(0) ? 0 : cursor.toNumber(), size);\n\n  if (!userRounds) {\n    return emptyResult;\n  }\n\n  const epochs = Object.keys(userRounds).map(epochStr => Number(epochStr));\n  const roundData = await getRoundsData(epochs);\n  const claimableStatuses = await getClaimStatuses(account, epochs); // Turn the data from the node into an Bet object that comes from the graph\n\n  const bets = roundData.reduce((accum, round) => {\n    const reduxRound = serializePredictionsRoundsResponse(round);\n    const ledger = userRounds[reduxRound.epoch];\n    const ledgerAmount = ethers.BigNumber.from(ledger.amount);\n    const closePrice = round.closePrice ? parseFloat(formatUnits(round.closePrice, 8)) : null;\n    const lockPrice = round.lockPrice ? parseFloat(formatUnits(round.lockPrice, 8)) : null;\n\n    const getRoundPosition = () => {\n      if (!closePrice) {\n        return null;\n      }\n\n      if (round.closePrice.eq(round.lockPrice)) {\n        return BetPosition.HOUSE;\n      }\n\n      return round.closePrice.gt(round.lockPrice) ? BetPosition.BULL : BetPosition.BEAR;\n    };\n\n    return [...accum, {\n      id: null,\n      hash: null,\n      amount: parseFloat(formatUnits(ledgerAmount)),\n      position: ledger.position,\n      claimed: ledger.claimed,\n      claimedAt: null,\n      claimedHash: null,\n      claimedBNB: 0,\n      claimedNetBNB: 0,\n      createdAt: null,\n      updatedAt: null,\n      block: 0,\n      round: {\n        id: null,\n        epoch: round.epoch.toNumber(),\n        failed: false,\n        startBlock: null,\n        startAt: round.startTimestamp ? round.startTimestamp.toNumber() : null,\n        startHash: null,\n        lockAt: round.lockTimestamp ? round.lockTimestamp.toNumber() : null,\n        lockBlock: null,\n        lockPrice,\n        lockHash: null,\n        lockRoundId: round.lockOracleId ? round.lockOracleId.toString() : null,\n        closeRoundId: round.closeOracleId ? round.closeOracleId.toString() : null,\n        closeHash: null,\n        closeAt: null,\n        closePrice,\n        closeBlock: null,\n        totalBets: 0,\n        totalAmount: parseFloat(formatUnits(round.totalAmount)),\n        bullBets: 0,\n        bullAmount: parseFloat(formatUnits(round.bullAmount)),\n        bearBets: 0,\n        bearAmount: parseFloat(formatUnits(round.bearAmount)),\n        position: getRoundPosition()\n      }\n    }];\n  }, []);\n  return {\n    bets,\n    claimableStatuses,\n    page,\n    totalHistory: userRoundsLength.toNumber()\n  };\n}); // Leaderboard\n\nexport const filterLeaderboard = createAsyncThunk('predictions/filterLeaderboard', async ({\n  filters\n}) => {\n  const usersResponse = await getPredictionUsers({\n    skip: 0,\n    orderBy: filters.orderBy,\n    where: {\n      totalBets_gte: LEADERBOARD_MIN_ROUNDS_PLAYED,\n      [`${filters.orderBy}_gt`]: 0\n    }\n  });\n  return {\n    results: usersResponse.map(transformUserResponse)\n  };\n});\nexport const fetchAddressResult = createAsyncThunk('predictions/fetchAddressResult', async (account, {\n  rejectWithValue\n}) => {\n  const userResponse = await getPredictionUser(account);\n\n  if (!userResponse) {\n    return rejectWithValue(account);\n  }\n\n  return {\n    account,\n    data: transformUserResponse(userResponse)\n  };\n});\nexport const filterNextPageLeaderboard = createAsyncThunk('predictions/filterNextPageLeaderboard', async (skip, {\n  getState\n}) => {\n  const state = getState();\n  const usersResponse = await getPredictionUsers({\n    skip,\n    orderBy: state.predictions.leaderboard.filters.orderBy,\n    where: {\n      totalBets_gte: LEADERBOARD_MIN_ROUNDS_PLAYED,\n      [`${state.predictions.leaderboard.filters.orderBy}_gt`]: 0\n    }\n  });\n  return {\n    results: usersResponse.map(transformUserResponse),\n    skip\n  };\n});\nexport const predictionsSlice = createSlice({\n  name: 'predictions',\n  initialState,\n  reducers: {\n    setLeaderboardFilter: (state, action) => {\n      state.leaderboard.filters = { ...state.leaderboard.filters,\n        ...action.payload\n      }; // Anytime we filters change we need to reset back to page 1\n\n      state.leaderboard.skip = 0;\n      state.leaderboard.hasMoreResults = true;\n    },\n    setPredictionStatus: (state, action) => {\n      state.status = action.payload;\n    },\n    setHistoryPaneState: (state, action) => {\n      state.isHistoryPaneOpen = action.payload;\n      state.historyFilter = HistoryFilter.ALL;\n    },\n    setChartPaneState: (state, action) => {\n      state.isChartPaneOpen = action.payload;\n    },\n    setHistoryFilter: (state, action) => {\n      state.historyFilter = action.payload;\n    },\n    setCurrentEpoch: (state, action) => {\n      state.currentEpoch = action.payload;\n    },\n    setLastOraclePrice: (state, action) => {\n      state.lastOraclePrice = action.payload;\n    },\n    markAsCollected: (state, action) => {\n      state.claimableStatuses = { ...state.claimableStatuses,\n        ...action.payload\n      };\n    },\n    setSelectedAddress: (state, action) => {\n      state.leaderboard.selectedAddress = action.payload;\n    }\n  },\n  extraReducers: builder => {\n    // Leaderboard filter\n    builder.addCase(filterLeaderboard.pending, state => {\n      // Only mark as loading if we come from IDLE. This allows initialization.\n      if (state.leaderboard.loadingState === LeaderboardLoadingState.IDLE) {\n        state.leaderboard.loadingState = LeaderboardLoadingState.LOADING;\n      }\n    });\n    builder.addCase(filterLeaderboard.fulfilled, (state, action) => {\n      const {\n        results\n      } = action.payload;\n      state.leaderboard.loadingState = LeaderboardLoadingState.IDLE;\n      state.leaderboard.results = results;\n\n      if (results.length < LEADERBOARD_RESULTS_PER_PAGE) {\n        state.leaderboard.hasMoreResults = false;\n      } // Populate address results to reduce calls\n\n\n      state.leaderboard.addressResults = { ...state.leaderboard.addressResults,\n        ...results.reduce((accum, result) => {\n          return { ...accum,\n            [result.id]: result\n          };\n        }, {})\n      };\n    }); // Leaderboard account result\n\n    builder.addCase(fetchAddressResult.pending, state => {\n      state.leaderboard.loadingState = LeaderboardLoadingState.LOADING;\n    });\n    builder.addCase(fetchAddressResult.fulfilled, (state, action) => {\n      const {\n        account,\n        data\n      } = action.payload;\n      state.leaderboard.loadingState = LeaderboardLoadingState.IDLE;\n      state.leaderboard.addressResults[account] = data;\n    });\n    builder.addCase(fetchAddressResult.rejected, (state, action) => {\n      state.leaderboard.loadingState = LeaderboardLoadingState.IDLE;\n      state.leaderboard.addressResults[action.payload] = null;\n    }); // Leaderboard next page\n\n    builder.addCase(filterNextPageLeaderboard.pending, state => {\n      state.leaderboard.loadingState = LeaderboardLoadingState.LOADING;\n    });\n    builder.addCase(filterNextPageLeaderboard.fulfilled, (state, action) => {\n      const {\n        results,\n        skip\n      } = action.payload;\n      state.leaderboard.loadingState = LeaderboardLoadingState.IDLE;\n      state.leaderboard.results = [...state.leaderboard.results, ...results];\n      state.leaderboard.skip = skip;\n\n      if (results.length < LEADERBOARD_RESULTS_PER_PAGE) {\n        state.leaderboard.hasMoreResults = false;\n      }\n    }); // Claimable statuses\n\n    builder.addCase(fetchClaimableStatuses.fulfilled, (state, action) => {\n      state.claimableStatuses = merge({}, state.claimableStatuses, action.payload);\n    }); // Ledger (bet) records\n\n    builder.addCase(fetchLedgerData.fulfilled, (state, action) => {\n      state.ledgers = merge({}, state.ledgers, action.payload);\n    }); // Get static market data\n\n    builder.addCase(fetchMarketData.fulfilled, (state, action) => {\n      const {\n        status,\n        currentEpoch,\n        intervalSeconds,\n        minBetAmount\n      } = action.payload; // If the round has change add a new future round\n\n      if (state.currentEpoch !== currentEpoch) {\n        const newestRound = maxBy(Object.values(state.rounds), 'epoch');\n        const futureRound = makeFutureRoundResponse(newestRound.epoch + 1, newestRound.startTimestamp + intervalSeconds + ROUND_BUFFER);\n        state.rounds[futureRound.epoch] = futureRound;\n      }\n\n      state.status = status;\n      state.currentEpoch = currentEpoch;\n      state.intervalSeconds = intervalSeconds;\n      state.minBetAmount = minBetAmount;\n    }); // Initialize predictions\n\n    builder.addCase(initializePredictions.fulfilled, (state, action) => {\n      const {\n        status,\n        currentEpoch,\n        intervalSeconds,\n        bufferSeconds,\n        rounds,\n        claimableStatuses,\n        ledgers\n      } = action.payload;\n      const futureRounds = [];\n      const currentRound = rounds[currentEpoch];\n\n      for (let i = 1; i <= FUTURE_ROUND_COUNT; i++) {\n        futureRounds.push(makeFutureRoundResponse(currentEpoch + i, currentRound.startTimestamp + intervalSeconds * i));\n      }\n\n      return { ...state,\n        status,\n        currentEpoch,\n        intervalSeconds,\n        bufferSeconds,\n        claimableStatuses,\n        ledgers,\n        rounds: merge({}, rounds, makeRoundData(futureRounds))\n      };\n    }); // Get single round\n\n    builder.addCase(fetchRound.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, {\n        [action.payload.epoch.toString()]: action.payload\n      });\n    }); // Get multiple rounds\n\n    builder.addCase(fetchRounds.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, action.payload);\n    }); // Show History\n\n    builder.addCase(fetchHistory.pending, state => {\n      state.isFetchingHistory = true;\n    });\n    builder.addCase(fetchHistory.rejected, state => {\n      state.isFetchingHistory = false;\n    });\n    builder.addCase(fetchHistory.fulfilled, (state, action) => {\n      var _state$history$accoun;\n\n      const {\n        account,\n        bets\n      } = action.payload;\n      state.isFetchingHistory = false;\n      state.history[account] = merge([], (_state$history$accoun = state.history[account]) !== null && _state$history$accoun !== void 0 ? _state$history$accoun : [], bets);\n    }); // History from the node\n\n    builder.addCase(fetchNodeHistory.pending, state => {\n      state.isFetchingHistory = true;\n    });\n    builder.addCase(fetchNodeHistory.rejected, state => {\n      state.isFetchingHistory = false;\n    });\n    builder.addCase(fetchNodeHistory.fulfilled, (state, action) => {\n      const {\n        bets,\n        claimableStatuses,\n        page,\n        totalHistory\n      } = action.payload;\n      state.isFetchingHistory = false;\n      state.history = page === 1 ? bets : [...state.history, ...bets];\n      state.claimableStatuses = { ...state.claimableStatuses,\n        ...claimableStatuses\n      };\n      state.hasHistoryLoaded = state.history.length === totalHistory || bets.length === 0;\n      state.totalHistory = totalHistory;\n      state.currentHistoryPage = page;\n    });\n  }\n}); // Actions\n\nexport const {\n  setChartPaneState,\n  setCurrentEpoch,\n  setHistoryFilter,\n  setHistoryPaneState,\n  setPredictionStatus,\n  setLastOraclePrice,\n  markAsCollected,\n  setLeaderboardFilter,\n  setSelectedAddress\n} = predictionsSlice.actions;\nexport default predictionsSlice.reducer;","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/predictions/index.ts"],"names":["createAsyncThunk","createSlice","ethers","formatUnits","maxBy","merge","range","BIG_ZERO","HistoryFilter","PredictionStatus","BetPosition","LeaderboardLoadingState","getPredictionsContract","FUTURE_ROUND_COUNT","LEADERBOARD_MIN_ROUNDS_PLAYED","PAST_ROUND_COUNT","ROUNDS_PER_PAGE","ROUND_BUFFER","getBetHistory","transformBetResponse","makeFutureRoundResponse","makeRoundData","getRoundsData","getPredictionData","getLedgerData","makeLedgerData","serializePredictionsRoundsResponse","getClaimStatuses","fetchUsersRoundsLength","fetchUserRounds","getPredictionUsers","transformUserResponse","LEADERBOARD_RESULTS_PER_PAGE","getPredictionUser","initialState","status","INITIAL","isLoading","isHistoryPaneOpen","isChartPaneOpen","isFetchingHistory","historyFilter","ALL","currentEpoch","intervalSeconds","minBetAmount","bufferSeconds","lastOraclePrice","toJSON","rounds","history","totalHistory","currentHistoryPage","hasHistoryLoaded","ledgers","claimableStatuses","leaderboard","selectedAddress","loadingState","filters","address","orderBy","timePeriod","skip","hasMoreResults","addressResults","results","initializePredictions","account","marketData","epochs","roundsResponse","initialRoundData","reduce","accum","roundResponse","reduxNodeRound","epoch","toString","initializedData","ledgerResponses","fetchRound","predictionContract","response","fetchRounds","round","fetchMarketData","fetchLedgerData","fetchClaimableStatuses","fetchHistory","claimed","user","toLowerCase","bets","map","fetchNodeHistory","page","userRoundsLength","emptyResult","toNumber","maxPages","lte","Math","ceil","eq","cursor","sub","size","userRounds","lt","Object","keys","epochStr","Number","roundData","reduxRound","ledger","ledgerAmount","BigNumber","from","amount","closePrice","parseFloat","lockPrice","getRoundPosition","HOUSE","gt","BULL","BEAR","id","hash","position","claimedAt","claimedHash","claimedBNB","claimedNetBNB","createdAt","updatedAt","block","failed","startBlock","startAt","startTimestamp","startHash","lockAt","lockTimestamp","lockBlock","lockHash","lockRoundId","lockOracleId","closeRoundId","closeOracleId","closeHash","closeAt","closeBlock","totalBets","totalAmount","bullBets","bullAmount","bearBets","bearAmount","filterLeaderboard","usersResponse","where","totalBets_gte","fetchAddressResult","rejectWithValue","userResponse","data","filterNextPageLeaderboard","getState","state","predictions","predictionsSlice","name","reducers","setLeaderboardFilter","action","payload","setPredictionStatus","setHistoryPaneState","setChartPaneState","setHistoryFilter","setCurrentEpoch","setLastOraclePrice","markAsCollected","setSelectedAddress","extraReducers","builder","addCase","pending","IDLE","LOADING","fulfilled","length","result","rejected","newestRound","values","futureRound","futureRounds","currentRound","i","push","actions","reducer"],"mappings":"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","sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport { ethers } from 'ethers'\nimport { formatUnits } from 'ethers/lib/utils'\nimport maxBy from 'lodash/maxBy'\nimport merge from 'lodash/merge'\nimport range from 'lodash/range'\nimport { BIG_ZERO } from 'utils/bigNumber'\nimport {\n  Bet,\n  LedgerData,\n  HistoryFilter,\n  PredictionsState,\n  PredictionStatus,\n  ReduxNodeRound,\n  BetPosition,\n  LeaderboardLoadingState,\n  PredictionUser,\n  LeaderboardFilter,\n  State,\n} from 'state/types'\nimport { getPredictionsContract } from 'utils/contractHelpers'\nimport {\n  FUTURE_ROUND_COUNT,\n  LEADERBOARD_MIN_ROUNDS_PLAYED,\n  PAST_ROUND_COUNT,\n  ROUNDS_PER_PAGE,\n  ROUND_BUFFER,\n} from './config'\nimport {\n  getBetHistory,\n  transformBetResponse,\n  makeFutureRoundResponse,\n  makeRoundData,\n  getRoundsData,\n  getPredictionData,\n  MarketData,\n  getLedgerData,\n  makeLedgerData,\n  serializePredictionsRoundsResponse,\n  getClaimStatuses,\n  fetchUsersRoundsLength,\n  fetchUserRounds,\n  getPredictionUsers,\n  transformUserResponse,\n  LEADERBOARD_RESULTS_PER_PAGE,\n  getPredictionUser,\n} from './helpers'\n\nconst initialState: PredictionsState = {\n  status: PredictionStatus.INITIAL,\n  isLoading: false,\n  isHistoryPaneOpen: false,\n  isChartPaneOpen: false,\n  isFetchingHistory: false,\n  historyFilter: HistoryFilter.ALL,\n  currentEpoch: 0,\n  intervalSeconds: 300,\n  minBetAmount: '10000000000000',\n  bufferSeconds: 60,\n  lastOraclePrice: BIG_ZERO.toJSON(),\n  rounds: {},\n  history: [],\n  totalHistory: 0,\n  currentHistoryPage: 1,\n  hasHistoryLoaded: false,\n  ledgers: {},\n  claimableStatuses: {},\n  leaderboard: {\n    selectedAddress: null,\n    loadingState: LeaderboardLoadingState.INITIAL,\n    filters: {\n      address: null,\n      orderBy: 'netBNB',\n      timePeriod: 'all',\n    },\n    skip: 0,\n    hasMoreResults: true,\n    addressResults: {},\n    results: [],\n  },\n}\n\n// Thunks\ntype PredictionInitialization = Pick<\n  PredictionsState,\n  | 'status'\n  | 'currentEpoch'\n  | 'intervalSeconds'\n  | 'minBetAmount'\n  | 'rounds'\n  | 'ledgers'\n  | 'claimableStatuses'\n  | 'bufferSeconds'\n>\nexport const initializePredictions = createAsyncThunk<PredictionInitialization, string>(\n  'predictions/intialize',\n  async (account = null) => {\n    // Static values\n    const marketData = await getPredictionData()\n    const epochs =\n      marketData.currentEpoch > PAST_ROUND_COUNT\n        ? range(marketData.currentEpoch, marketData.currentEpoch - PAST_ROUND_COUNT)\n        : [marketData.currentEpoch]\n\n    // Round data\n    const roundsResponse = await getRoundsData(epochs)\n    const initialRoundData: { [key: string]: ReduxNodeRound } = roundsResponse.reduce((accum, roundResponse) => {\n      const reduxNodeRound = serializePredictionsRoundsResponse(roundResponse)\n\n      return {\n        ...accum,\n        [reduxNodeRound.epoch.toString()]: reduxNodeRound,\n      }\n    }, {})\n\n    const initializedData = {\n      ...marketData,\n      rounds: initialRoundData,\n      ledgers: {},\n      claimableStatuses: {},\n    }\n\n    if (!account) {\n      return initializedData\n    }\n\n    // Bet data\n    const ledgerResponses = await getLedgerData(account, epochs)\n\n    // Claim statuses\n    const claimableStatuses = await getClaimStatuses(account, epochs)\n\n    return merge({}, initializedData, {\n      ledgers: makeLedgerData(account, ledgerResponses, epochs),\n      claimableStatuses,\n    })\n  },\n)\n\nexport const fetchRound = createAsyncThunk<ReduxNodeRound, number>('predictions/fetchRound', async (epoch) => {\n  const predictionContract = getPredictionsContract()\n  const response = await predictionContract.rounds(epoch)\n  return serializePredictionsRoundsResponse(response)\n})\n\nexport const fetchRounds = createAsyncThunk<{ [key: string]: ReduxNodeRound }, number[]>(\n  'predictions/fetchRounds',\n  async (epochs) => {\n    const rounds = await getRoundsData(epochs)\n    return rounds.reduce((accum, round) => {\n      if (!round) {\n        return accum\n      }\n\n      const reduxNodeRound = serializePredictionsRoundsResponse(round)\n\n      return {\n        ...accum,\n        [reduxNodeRound.epoch.toString()]: reduxNodeRound,\n      }\n    }, {})\n  },\n)\n\nexport const fetchMarketData = createAsyncThunk<MarketData>('predictions/fetchMarketData', async () => {\n  const marketData = await getPredictionData()\n  return marketData\n})\n\nexport const fetchLedgerData = createAsyncThunk<LedgerData, { account: string; epochs: number[] }>(\n  'predictions/fetchLedgerData',\n  async ({ account, epochs }) => {\n    const ledgers = await getLedgerData(account, epochs)\n    return makeLedgerData(account, ledgers, epochs)\n  },\n)\n\nexport const fetchClaimableStatuses = createAsyncThunk<\n  PredictionsState['claimableStatuses'],\n  { account: string; epochs: number[] }\n>('predictions/fetchClaimableStatuses', async ({ account, epochs }) => {\n  const ledgers = await getClaimStatuses(account, epochs)\n  return ledgers\n})\n\nexport const fetchHistory = createAsyncThunk<{ account: string; bets: Bet[] }, { account: string; claimed?: boolean }>(\n  'predictions/fetchHistory',\n  async ({ account, claimed }) => {\n    const response = await getBetHistory({\n      user: account.toLowerCase(),\n      claimed,\n    })\n    const bets = response.map(transformBetResponse)\n\n    return { account, bets }\n  },\n)\n\nexport const fetchNodeHistory = createAsyncThunk<\n  { bets: Bet[]; claimableStatuses: PredictionsState['claimableStatuses']; page?: number; totalHistory: number },\n  { account: string; page?: number }\n>('predictions/fetchNodeHistory', async ({ account, page = 1 }) => {\n  const userRoundsLength = await fetchUsersRoundsLength(account)\n  const emptyResult = { bets: [], claimableStatuses: {}, totalHistory: userRoundsLength.toNumber() }\n  const maxPages = userRoundsLength.lte(ROUNDS_PER_PAGE) ? 1 : Math.ceil(userRoundsLength.toNumber() / ROUNDS_PER_PAGE)\n\n  if (userRoundsLength.eq(0)) {\n    return emptyResult\n  }\n\n  if (page > maxPages) {\n    return emptyResult\n  }\n\n  const cursor = userRoundsLength.sub(ROUNDS_PER_PAGE * page)\n\n  // If the page request is the final one we only want to retrieve the amount of rounds up to the next cursor.\n  const size =\n    maxPages === page\n      ? userRoundsLength\n          .sub(ROUNDS_PER_PAGE * (page - 1)) // Previous page's cursor\n          .toNumber()\n      : ROUNDS_PER_PAGE\n  const userRounds = await fetchUserRounds(account, cursor.lt(0) ? 0 : cursor.toNumber(), size)\n\n  if (!userRounds) {\n    return emptyResult\n  }\n\n  const epochs = Object.keys(userRounds).map((epochStr) => Number(epochStr))\n  const roundData = await getRoundsData(epochs)\n  const claimableStatuses = await getClaimStatuses(account, epochs)\n\n  // Turn the data from the node into an Bet object that comes from the graph\n  const bets: Bet[] = roundData.reduce((accum, round) => {\n    const reduxRound = serializePredictionsRoundsResponse(round)\n    const ledger = userRounds[reduxRound.epoch]\n    const ledgerAmount = ethers.BigNumber.from(ledger.amount)\n    const closePrice = round.closePrice ? parseFloat(formatUnits(round.closePrice, 8)) : null\n    const lockPrice = round.lockPrice ? parseFloat(formatUnits(round.lockPrice, 8)) : null\n\n    const getRoundPosition = () => {\n      if (!closePrice) {\n        return null\n      }\n\n      if (round.closePrice.eq(round.lockPrice)) {\n        return BetPosition.HOUSE\n      }\n\n      return round.closePrice.gt(round.lockPrice) ? BetPosition.BULL : BetPosition.BEAR\n    }\n\n    return [\n      ...accum,\n      {\n        id: null,\n        hash: null,\n        amount: parseFloat(formatUnits(ledgerAmount)),\n        position: ledger.position,\n        claimed: ledger.claimed,\n        claimedAt: null,\n        claimedHash: null,\n        claimedBNB: 0,\n        claimedNetBNB: 0,\n        createdAt: null,\n        updatedAt: null,\n        block: 0,\n        round: {\n          id: null,\n          epoch: round.epoch.toNumber(),\n          failed: false,\n          startBlock: null,\n          startAt: round.startTimestamp ? round.startTimestamp.toNumber() : null,\n          startHash: null,\n          lockAt: round.lockTimestamp ? round.lockTimestamp.toNumber() : null,\n          lockBlock: null,\n          lockPrice,\n          lockHash: null,\n          lockRoundId: round.lockOracleId ? round.lockOracleId.toString() : null,\n          closeRoundId: round.closeOracleId ? round.closeOracleId.toString() : null,\n          closeHash: null,\n          closeAt: null,\n          closePrice,\n          closeBlock: null,\n          totalBets: 0,\n          totalAmount: parseFloat(formatUnits(round.totalAmount)),\n          bullBets: 0,\n          bullAmount: parseFloat(formatUnits(round.bullAmount)),\n          bearBets: 0,\n          bearAmount: parseFloat(formatUnits(round.bearAmount)),\n          position: getRoundPosition(),\n        },\n      },\n    ]\n  }, [])\n\n  return { bets, claimableStatuses, page, totalHistory: userRoundsLength.toNumber() }\n})\n\n// Leaderboard\nexport const filterLeaderboard = createAsyncThunk<{ results: PredictionUser[] }, { filters: LeaderboardFilter }>(\n  'predictions/filterLeaderboard',\n  async ({ filters }) => {\n    const usersResponse = await getPredictionUsers({\n      skip: 0,\n      orderBy: filters.orderBy,\n      where: { totalBets_gte: LEADERBOARD_MIN_ROUNDS_PLAYED, [`${filters.orderBy}_gt`]: 0 },\n    })\n\n    return { results: usersResponse.map(transformUserResponse) }\n  },\n)\n\nexport const fetchAddressResult = createAsyncThunk<\n  { account: string; data: PredictionUser },\n  string,\n  { rejectValue: string }\n>('predictions/fetchAddressResult', async (account, { rejectWithValue }) => {\n  const userResponse = await getPredictionUser(account)\n\n  if (!userResponse) {\n    return rejectWithValue(account)\n  }\n\n  return { account, data: transformUserResponse(userResponse) }\n})\n\nexport const filterNextPageLeaderboard = createAsyncThunk<\n  { results: PredictionUser[]; skip: number },\n  number,\n  { state: State }\n>('predictions/filterNextPageLeaderboard', async (skip, { getState }) => {\n  const state = getState()\n  const usersResponse = await getPredictionUsers({\n    skip,\n    orderBy: state.predictions.leaderboard.filters.orderBy,\n    where: { totalBets_gte: LEADERBOARD_MIN_ROUNDS_PLAYED, [`${state.predictions.leaderboard.filters.orderBy}_gt`]: 0 },\n  })\n\n  return { results: usersResponse.map(transformUserResponse), skip }\n})\n\nexport const predictionsSlice = createSlice({\n  name: 'predictions',\n  initialState,\n  reducers: {\n    setLeaderboardFilter: (state, action: PayloadAction<Partial<LeaderboardFilter>>) => {\n      state.leaderboard.filters = {\n        ...state.leaderboard.filters,\n        ...action.payload,\n      }\n\n      // Anytime we filters change we need to reset back to page 1\n      state.leaderboard.skip = 0\n      state.leaderboard.hasMoreResults = true\n    },\n    setPredictionStatus: (state, action: PayloadAction<PredictionStatus>) => {\n      state.status = action.payload\n    },\n    setHistoryPaneState: (state, action: PayloadAction<boolean>) => {\n      state.isHistoryPaneOpen = action.payload\n      state.historyFilter = HistoryFilter.ALL\n    },\n    setChartPaneState: (state, action: PayloadAction<boolean>) => {\n      state.isChartPaneOpen = action.payload\n    },\n    setHistoryFilter: (state, action: PayloadAction<HistoryFilter>) => {\n      state.historyFilter = action.payload\n    },\n    setCurrentEpoch: (state, action: PayloadAction<number>) => {\n      state.currentEpoch = action.payload\n    },\n    setLastOraclePrice: (state, action: PayloadAction<string>) => {\n      state.lastOraclePrice = action.payload\n    },\n    markAsCollected: (state, action: PayloadAction<{ [key: string]: boolean }>) => {\n      state.claimableStatuses = { ...state.claimableStatuses, ...action.payload }\n    },\n    setSelectedAddress: (state, action: PayloadAction<string>) => {\n      state.leaderboard.selectedAddress = action.payload\n    },\n  },\n  extraReducers: (builder) => {\n    // Leaderboard filter\n    builder.addCase(filterLeaderboard.pending, (state) => {\n      // Only mark as loading if we come from IDLE. This allows initialization.\n      if (state.leaderboard.loadingState === LeaderboardLoadingState.IDLE) {\n        state.leaderboard.loadingState = LeaderboardLoadingState.LOADING\n      }\n    })\n    builder.addCase(filterLeaderboard.fulfilled, (state, action) => {\n      const { results } = action.payload\n\n      state.leaderboard.loadingState = LeaderboardLoadingState.IDLE\n      state.leaderboard.results = results\n\n      if (results.length < LEADERBOARD_RESULTS_PER_PAGE) {\n        state.leaderboard.hasMoreResults = false\n      }\n\n      // Populate address results to reduce calls\n      state.leaderboard.addressResults = {\n        ...state.leaderboard.addressResults,\n        ...results.reduce((accum, result) => {\n          return {\n            ...accum,\n            [result.id]: result,\n          }\n        }, {}),\n      }\n    })\n\n    // Leaderboard account result\n    builder.addCase(fetchAddressResult.pending, (state) => {\n      state.leaderboard.loadingState = LeaderboardLoadingState.LOADING\n    })\n    builder.addCase(fetchAddressResult.fulfilled, (state, action) => {\n      const { account, data } = action.payload\n      state.leaderboard.loadingState = LeaderboardLoadingState.IDLE\n      state.leaderboard.addressResults[account] = data\n    })\n    builder.addCase(fetchAddressResult.rejected, (state, action) => {\n      state.leaderboard.loadingState = LeaderboardLoadingState.IDLE\n      state.leaderboard.addressResults[action.payload] = null\n    })\n\n    // Leaderboard next page\n    builder.addCase(filterNextPageLeaderboard.pending, (state) => {\n      state.leaderboard.loadingState = LeaderboardLoadingState.LOADING\n    })\n    builder.addCase(filterNextPageLeaderboard.fulfilled, (state, action) => {\n      const { results, skip } = action.payload\n\n      state.leaderboard.loadingState = LeaderboardLoadingState.IDLE\n      state.leaderboard.results = [...state.leaderboard.results, ...results]\n      state.leaderboard.skip = skip\n\n      if (results.length < LEADERBOARD_RESULTS_PER_PAGE) {\n        state.leaderboard.hasMoreResults = false\n      }\n    })\n\n    // Claimable statuses\n    builder.addCase(fetchClaimableStatuses.fulfilled, (state, action) => {\n      state.claimableStatuses = merge({}, state.claimableStatuses, action.payload)\n    })\n\n    // Ledger (bet) records\n    builder.addCase(fetchLedgerData.fulfilled, (state, action) => {\n      state.ledgers = merge({}, state.ledgers, action.payload)\n    })\n\n    // Get static market data\n    builder.addCase(fetchMarketData.fulfilled, (state, action) => {\n      const { status, currentEpoch, intervalSeconds, minBetAmount } = action.payload\n\n      // If the round has change add a new future round\n      if (state.currentEpoch !== currentEpoch) {\n        const newestRound = maxBy(Object.values(state.rounds), 'epoch')\n        const futureRound = makeFutureRoundResponse(\n          newestRound.epoch + 1,\n          newestRound.startTimestamp + intervalSeconds + ROUND_BUFFER,\n        )\n\n        state.rounds[futureRound.epoch] = futureRound\n      }\n\n      state.status = status\n      state.currentEpoch = currentEpoch\n      state.intervalSeconds = intervalSeconds\n      state.minBetAmount = minBetAmount\n    })\n\n    // Initialize predictions\n    builder.addCase(initializePredictions.fulfilled, (state, action) => {\n      const { status, currentEpoch, intervalSeconds, bufferSeconds, rounds, claimableStatuses, ledgers } =\n        action.payload\n      const futureRounds: ReduxNodeRound[] = []\n      const currentRound = rounds[currentEpoch]\n\n      for (let i = 1; i <= FUTURE_ROUND_COUNT; i++) {\n        futureRounds.push(makeFutureRoundResponse(currentEpoch + i, currentRound.startTimestamp + intervalSeconds * i))\n      }\n\n      return {\n        ...state,\n        status,\n        currentEpoch,\n        intervalSeconds,\n        bufferSeconds,\n        claimableStatuses,\n        ledgers,\n        rounds: merge({}, rounds, makeRoundData(futureRounds)),\n      }\n    })\n\n    // Get single round\n    builder.addCase(fetchRound.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, {\n        [action.payload.epoch.toString()]: action.payload,\n      })\n    })\n\n    // Get multiple rounds\n    builder.addCase(fetchRounds.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, action.payload)\n    })\n\n    // Show History\n    builder.addCase(fetchHistory.pending, (state) => {\n      state.isFetchingHistory = true\n    })\n    builder.addCase(fetchHistory.rejected, (state) => {\n      state.isFetchingHistory = false\n    })\n    builder.addCase(fetchHistory.fulfilled, (state, action) => {\n      const { account, bets } = action.payload\n\n      state.isFetchingHistory = false\n      state.history[account] = merge([], state.history[account] ?? [], bets)\n    })\n\n    // History from the node\n    builder.addCase(fetchNodeHistory.pending, (state) => {\n      state.isFetchingHistory = true\n    })\n    builder.addCase(fetchNodeHistory.rejected, (state) => {\n      state.isFetchingHistory = false\n    })\n    builder.addCase(fetchNodeHistory.fulfilled, (state, action) => {\n      const { bets, claimableStatuses, page, totalHistory } = action.payload\n\n      state.isFetchingHistory = false\n      state.history = page === 1 ? bets : [...state.history, ...bets]\n      state.claimableStatuses = { ...state.claimableStatuses, ...claimableStatuses }\n      state.hasHistoryLoaded = state.history.length === totalHistory || bets.length === 0\n      state.totalHistory = totalHistory\n      state.currentHistoryPage = page\n    })\n  },\n})\n\n// Actions\nexport const {\n  setChartPaneState,\n  setCurrentEpoch,\n  setHistoryFilter,\n  setHistoryPaneState,\n  setPredictionStatus,\n  setLastOraclePrice,\n  markAsCollected,\n  setLeaderboardFilter,\n  setSelectedAddress,\n} = predictionsSlice.actions\n\nexport default predictionsSlice.reducer\n"]},"metadata":{},"sourceType":"module"}