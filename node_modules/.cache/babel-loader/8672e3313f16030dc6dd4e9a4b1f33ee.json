{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$(),\n    _s4 = $RefreshSig$(),\n    _s5 = $RefreshSig$(),\n    _s6 = $RefreshSig$(),\n    _s7 = $RefreshSig$(),\n    _s8 = $RefreshSig$(),\n    _s9 = $RefreshSig$(),\n    _s10 = $RefreshSig$(),\n    _s11 = $RefreshSig$(),\n    _s12 = $RefreshSig$(),\n    _s13 = $RefreshSig$(),\n    _s14 = $RefreshSig$(),\n    _s15 = $RefreshSig$(),\n    _s16 = $RefreshSig$(),\n    _s17 = $RefreshSig$(),\n    _s18 = $RefreshSig$();\n\nimport { useCallback, useEffect, useState, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { getUnixTime, startOfHour, sub } from 'date-fns';\nimport { isAddress } from 'utils';\nimport fetchPoolChartData from 'state/info/queries/pools/chartData';\nimport fetchPoolTransactions from 'state/info/queries/pools/transactions';\nimport fetchTokenChartData from 'state/info/queries/tokens/chartData';\nimport fetchTokenTransactions from 'state/info/queries/tokens/transactions';\nimport fetchTokenPriceData from 'state/info/queries/tokens/priceData';\nimport fetchPoolsForToken from 'state/info/queries/tokens/poolsForToken';\nimport { updateProtocolData, updateProtocolChartData, updateProtocolTransactions, updatePoolData, addPoolKeys, updatePoolChartData, updatePoolTransactions, updateTokenData, addTokenKeys, addTokenPoolAddresses, updateTokenChartData, updateTokenPriceData, updateTokenTransactions } from './actions';\n// Protocol hooks\nexport const useProtocolData = () => {\n  _s();\n\n  const protocolData = useSelector(state => state.info.protocol.overview);\n  const dispatch = useDispatch();\n  const setProtocolData = useCallback(data => dispatch(updateProtocolData({\n    protocolData: data\n  })), [dispatch]);\n  return [protocolData, setProtocolData];\n};\n\n_s(useProtocolData, \"v+zYuUDrBqb8mwnlY+pI21u8I98=\", false, function () {\n  return [useSelector, useDispatch];\n});\n\nexport const useProtocolChartData = () => {\n  _s2();\n\n  const chartData = useSelector(state => state.info.protocol.chartData);\n  const dispatch = useDispatch();\n  const setChartData = useCallback(data => dispatch(updateProtocolChartData({\n    chartData: data\n  })), [dispatch]);\n  return [chartData, setChartData];\n};\n\n_s2(useProtocolChartData, \"TUGBpecLdUlREdIeiMSLLiRGoCU=\", false, function () {\n  return [useSelector, useDispatch];\n});\n\nexport const useProtocolTransactions = () => {\n  _s3();\n\n  const transactions = useSelector(state => state.info.protocol.transactions);\n  const dispatch = useDispatch();\n  const setTransactions = useCallback(transactionsData => dispatch(updateProtocolTransactions({\n    transactions: transactionsData\n  })), [dispatch]);\n  return [transactions, setTransactions];\n}; // Pools hooks\n\n_s3(useProtocolTransactions, \"6jgHi+2QedeMW83j+e3ehRdpq2s=\", false, function () {\n  return [useSelector, useDispatch];\n});\n\nexport const useAllPoolData = () => {\n  _s4();\n\n  return useSelector(state => state.info.pools.byAddress);\n};\n\n_s4(useAllPoolData, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport const useUpdatePoolData = () => {\n  _s5();\n\n  const dispatch = useDispatch();\n  return useCallback(pools => dispatch(updatePoolData({\n    pools\n  })), [dispatch]);\n};\n\n_s5(useUpdatePoolData, \"nhyv+fhSuBJ7yx/uYuCmtG3KTzU=\", false, function () {\n  return [useDispatch];\n});\n\nexport const useAddPoolKeys = () => {\n  _s6();\n\n  const dispatch = useDispatch();\n  return useCallback(poolAddresses => dispatch(addPoolKeys({\n    poolAddresses\n  })), [dispatch]);\n};\n\n_s6(useAddPoolKeys, \"nhyv+fhSuBJ7yx/uYuCmtG3KTzU=\", false, function () {\n  return [useDispatch];\n});\n\nexport const usePoolDatas = poolAddresses => {\n  _s7();\n\n  const allPoolData = useAllPoolData();\n  const addNewPoolKeys = useAddPoolKeys();\n  const untrackedAddresses = poolAddresses.reduce((accum, address) => {\n    if (!Object.keys(allPoolData).includes(address)) {\n      accum.push(address);\n    }\n\n    return accum;\n  }, []);\n  useEffect(() => {\n    if (untrackedAddresses) {\n      addNewPoolKeys(untrackedAddresses);\n    }\n  }, [addNewPoolKeys, untrackedAddresses]);\n  const poolsWithData = poolAddresses.map(address => {\n    var _allPoolData$address;\n\n    return (_allPoolData$address = allPoolData[address]) === null || _allPoolData$address === void 0 ? void 0 : _allPoolData$address.data;\n  }).filter(pool => pool);\n  return poolsWithData;\n};\n\n_s7(usePoolDatas, \"ZrSSNpJizgY2NT1BbRvRlp+SJ+U=\", false, function () {\n  return [useAllPoolData, useAddPoolKeys];\n});\n\nexport const usePoolChartData = address => {\n  _s8();\n\n  const dispatch = useDispatch();\n  const pool = useSelector(state => state.info.pools.byAddress[address]);\n  const chartData = pool === null || pool === void 0 ? void 0 : pool.chartData;\n  const [error, setError] = useState(false);\n  useEffect(() => {\n    const fetch = async () => {\n      const {\n        error: fetchError,\n        data\n      } = await fetchPoolChartData(address);\n\n      if (!fetchError && data) {\n        dispatch(updatePoolChartData({\n          poolAddress: address,\n          chartData: data\n        }));\n      }\n\n      if (fetchError) {\n        setError(fetchError);\n      }\n    };\n\n    if (!chartData && !error) {\n      fetch();\n    }\n  }, [address, dispatch, error, chartData]);\n  return chartData;\n};\n\n_s8(usePoolChartData, \"xDH+clcIwkBY69M6w3l9e0mSiJg=\", false, function () {\n  return [useDispatch, useSelector];\n});\n\nexport const usePoolTransactions = address => {\n  _s9();\n\n  const dispatch = useDispatch();\n  const pool = useSelector(state => state.info.pools.byAddress[address]);\n  const transactions = pool === null || pool === void 0 ? void 0 : pool.transactions;\n  const [error, setError] = useState(false);\n  useEffect(() => {\n    const fetch = async () => {\n      const {\n        error: fetchError,\n        data\n      } = await fetchPoolTransactions(address);\n\n      if (fetchError) {\n        setError(true);\n      } else {\n        dispatch(updatePoolTransactions({\n          poolAddress: address,\n          transactions: data\n        }));\n      }\n    };\n\n    if (!transactions && !error) {\n      fetch();\n    }\n  }, [address, dispatch, error, transactions]);\n  return transactions;\n}; // Tokens hooks\n\n_s9(usePoolTransactions, \"xDH+clcIwkBY69M6w3l9e0mSiJg=\", false, function () {\n  return [useDispatch, useSelector];\n});\n\nexport const useAllTokenData = () => {\n  _s10();\n\n  return useSelector(state => state.info.tokens.byAddress);\n};\n\n_s10(useAllTokenData, \"nKHvd/QB6hocKEk0fSJoSYcCyR8=\", false, function () {\n  return [useSelector];\n});\n\nexport const useUpdateTokenData = () => {\n  _s11();\n\n  const dispatch = useDispatch();\n  return useCallback(tokens => {\n    dispatch(updateTokenData({\n      tokens\n    }));\n  }, [dispatch]);\n};\n\n_s11(useUpdateTokenData, \"nhyv+fhSuBJ7yx/uYuCmtG3KTzU=\", false, function () {\n  return [useDispatch];\n});\n\nexport const useAddTokenKeys = () => {\n  _s12();\n\n  const dispatch = useDispatch();\n  return useCallback(tokenAddresses => dispatch(addTokenKeys({\n    tokenAddresses\n  })), [dispatch]);\n};\n\n_s12(useAddTokenKeys, \"nhyv+fhSuBJ7yx/uYuCmtG3KTzU=\", false, function () {\n  return [useDispatch];\n});\n\nexport const useTokenDatas = addresses => {\n  _s13();\n\n  const allTokenData = useAllTokenData();\n  const addNewTokenKeys = useAddTokenKeys(); // if token not tracked yet track it\n\n  addresses === null || addresses === void 0 ? void 0 : addresses.forEach(a => {\n    if (!allTokenData[a]) {\n      addNewTokenKeys([a]);\n    }\n  });\n  const tokensWithData = useMemo(() => {\n    if (!addresses) {\n      return undefined;\n    }\n\n    return addresses.map(a => {\n      var _allTokenData$a;\n\n      return (_allTokenData$a = allTokenData[a]) === null || _allTokenData$a === void 0 ? void 0 : _allTokenData$a.data;\n    }).filter(token => token);\n  }, [addresses, allTokenData]);\n  return tokensWithData;\n};\n\n_s13(useTokenDatas, \"fY5gHvogMMG3imEGuKWHxCyW/ww=\", false, function () {\n  return [useAllTokenData, useAddTokenKeys];\n});\n\nexport const useTokenData = address => {\n  _s14();\n\n  var _allTokenData$address;\n\n  const allTokenData = useAllTokenData();\n  const addNewTokenKeys = useAddTokenKeys();\n\n  if (!address || !isAddress(address)) {\n    return undefined;\n  } // if token not tracked yet track it\n\n\n  if (!allTokenData[address]) {\n    addNewTokenKeys([address]);\n  }\n\n  return (_allTokenData$address = allTokenData[address]) === null || _allTokenData$address === void 0 ? void 0 : _allTokenData$address.data;\n};\n\n_s14(useTokenData, \"yncFDHVIRx54ovrZEaGYH+BNWGg=\", false, function () {\n  return [useAllTokenData, useAddTokenKeys];\n});\n\nexport const usePoolsForToken = address => {\n  _s15();\n\n  const dispatch = useDispatch();\n  const token = useSelector(state => state.info.tokens.byAddress[address]);\n  const poolsForToken = token.poolAddresses;\n  const [error, setError] = useState(false);\n  useEffect(() => {\n    const fetch = async () => {\n      const {\n        error: fetchError,\n        addresses\n      } = await fetchPoolsForToken(address);\n\n      if (!fetchError && addresses) {\n        dispatch(addTokenPoolAddresses({\n          tokenAddress: address,\n          poolAddresses: addresses\n        }));\n      }\n\n      if (fetchError) {\n        setError(fetchError);\n      }\n    };\n\n    if (!poolsForToken && !error) {\n      fetch();\n    }\n  }, [address, dispatch, error, poolsForToken]);\n  return poolsForToken;\n};\n\n_s15(usePoolsForToken, \"3eVoq7UE/x1HcTUaOQw1QtpXivE=\", false, function () {\n  return [useDispatch, useSelector];\n});\n\nexport const useTokenChartData = address => {\n  _s16();\n\n  const dispatch = useDispatch();\n  const token = useSelector(state => state.info.tokens.byAddress[address]);\n  const {\n    chartData\n  } = token;\n  const [error, setError] = useState(false);\n  useEffect(() => {\n    const fetch = async () => {\n      const {\n        error: fetchError,\n        data\n      } = await fetchTokenChartData(address);\n\n      if (!fetchError && data) {\n        dispatch(updateTokenChartData({\n          tokenAddress: address,\n          chartData: data\n        }));\n      }\n\n      if (fetchError) {\n        setError(fetchError);\n      }\n    };\n\n    if (!chartData && !error) {\n      fetch();\n    }\n  }, [address, dispatch, error, chartData]);\n  return chartData;\n};\n\n_s16(useTokenChartData, \"3eVoq7UE/x1HcTUaOQw1QtpXivE=\", false, function () {\n  return [useDispatch, useSelector];\n});\n\nexport const useTokenPriceData = (address, interval, timeWindow) => {\n  _s17();\n\n  const dispatch = useDispatch();\n  const token = useSelector(state => state.info.tokens.byAddress[address]);\n  const priceData = token.priceData[interval];\n  const [error, setError] = useState(false); // construct timestamps and check if we need to fetch more data\n\n  const oldestTimestampFetched = token.priceData.oldestFetchedTimestamp;\n  const utcCurrentTime = getUnixTime(new Date()) * 1000;\n  const startTimestamp = getUnixTime(startOfHour(sub(utcCurrentTime, timeWindow)));\n  useEffect(() => {\n    const fetch = async () => {\n      const {\n        data,\n        error: fetchingError\n      } = await fetchTokenPriceData(address, interval, startTimestamp);\n\n      if (data) {\n        dispatch(updateTokenPriceData({\n          tokenAddress: address,\n          secondsInterval: interval,\n          priceData: data,\n          oldestFetchedTimestamp: startTimestamp\n        }));\n      }\n\n      if (fetchingError) {\n        setError(true);\n      }\n    };\n\n    if (!priceData && !error) {\n      fetch();\n    }\n  }, [address, dispatch, error, interval, oldestTimestampFetched, priceData, startTimestamp, timeWindow]);\n  return priceData;\n};\n\n_s17(useTokenPriceData, \"3eVoq7UE/x1HcTUaOQw1QtpXivE=\", false, function () {\n  return [useDispatch, useSelector];\n});\n\nexport const useTokenTransactions = address => {\n  _s18();\n\n  const dispatch = useDispatch();\n  const token = useSelector(state => state.info.tokens.byAddress[address]);\n  const {\n    transactions\n  } = token;\n  const [error, setError] = useState(false);\n  useEffect(() => {\n    const fetch = async () => {\n      const {\n        error: fetchError,\n        data\n      } = await fetchTokenTransactions(address);\n\n      if (fetchError) {\n        setError(true);\n      } else if (data) {\n        dispatch(updateTokenTransactions({\n          tokenAddress: address,\n          transactions: data\n        }));\n      }\n    };\n\n    if (!transactions && !error) {\n      fetch();\n    }\n  }, [address, dispatch, error, transactions]);\n  return transactions;\n};\n\n_s18(useTokenTransactions, \"3eVoq7UE/x1HcTUaOQw1QtpXivE=\", false, function () {\n  return [useDispatch, useSelector];\n});","map":{"version":3,"sources":["/Volumes/evo970/lou/madDex-master/src/state/info/hooks.ts"],"names":["useCallback","useEffect","useState","useMemo","useDispatch","useSelector","getUnixTime","startOfHour","sub","isAddress","fetchPoolChartData","fetchPoolTransactions","fetchTokenChartData","fetchTokenTransactions","fetchTokenPriceData","fetchPoolsForToken","updateProtocolData","updateProtocolChartData","updateProtocolTransactions","updatePoolData","addPoolKeys","updatePoolChartData","updatePoolTransactions","updateTokenData","addTokenKeys","addTokenPoolAddresses","updateTokenChartData","updateTokenPriceData","updateTokenTransactions","useProtocolData","protocolData","state","info","protocol","overview","dispatch","setProtocolData","data","useProtocolChartData","chartData","setChartData","useProtocolTransactions","transactions","setTransactions","transactionsData","useAllPoolData","pools","byAddress","useUpdatePoolData","useAddPoolKeys","poolAddresses","usePoolDatas","allPoolData","addNewPoolKeys","untrackedAddresses","reduce","accum","address","Object","keys","includes","push","poolsWithData","map","filter","pool","usePoolChartData","error","setError","fetch","fetchError","poolAddress","usePoolTransactions","useAllTokenData","tokens","useUpdateTokenData","useAddTokenKeys","tokenAddresses","useTokenDatas","addresses","allTokenData","addNewTokenKeys","forEach","a","tokensWithData","undefined","token","useTokenData","usePoolsForToken","poolsForToken","tokenAddress","useTokenChartData","useTokenPriceData","interval","timeWindow","priceData","oldestTimestampFetched","oldestFetchedTimestamp","utcCurrentTime","Date","startTimestamp","fetchingError","secondsInterval","useTokenTransactions"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,SAASA,WAAT,EAAsBC,SAAtB,EAAiCC,QAAjC,EAA2CC,OAA3C,QAA0D,OAA1D;AACA,SAASC,WAAT,EAAsBC,WAAtB,QAAyC,aAAzC;AACA,SAASC,WAAT,EAAsBC,WAAtB,EAA6CC,GAA7C,QAAwD,UAAxD;AAEA,SAASC,SAAT,QAA0B,OAA1B;AAEA,OAAOC,kBAAP,MAA+B,oCAA/B;AACA,OAAOC,qBAAP,MAAkC,uCAAlC;AACA,OAAOC,mBAAP,MAAgC,qCAAhC;AACA,OAAOC,sBAAP,MAAmC,wCAAnC;AACA,OAAOC,mBAAP,MAAgC,qCAAhC;AACA,OAAOC,kBAAP,MAA+B,yCAA/B;AACA,SACEC,kBADF,EAEEC,uBAFF,EAGEC,0BAHF,EAIEC,cAJF,EAKEC,WALF,EAMEC,mBANF,EAOEC,sBAPF,EAQEC,eARF,EASEC,YATF,EAUEC,qBAVF,EAWEC,oBAXF,EAYEC,oBAZF,EAaEC,uBAbF,QAcO,WAdP;AAiBA;AAEA,OAAO,MAAMC,eAAe,GAAG,MAAwE;AAAA;;AACrG,QAAMC,YAAsC,GAAGzB,WAAW,CAAE0B,KAAD,IAAqBA,KAAK,CAACC,IAAN,CAAWC,QAAX,CAAoBC,QAA1C,CAA1D;AAEA,QAAMC,QAAQ,GAAG/B,WAAW,EAA5B;AACA,QAAMgC,eAAqD,GAAGpC,WAAW,CACtEqC,IAAD,IAAwBF,QAAQ,CAACnB,kBAAkB,CAAC;AAAEc,IAAAA,YAAY,EAAEO;AAAhB,GAAD,CAAnB,CADuC,EAEvE,CAACF,QAAD,CAFuE,CAAzE;AAKA,SAAO,CAACL,YAAD,EAAeM,eAAf,CAAP;AACD,CAVM;;GAAMP,e;UACoCxB,W,EAE9BD,W;;;AASnB,OAAO,MAAMkC,oBAAoB,GAAG,MAAqE;AAAA;;AACvG,QAAMC,SAAmC,GAAGlC,WAAW,CAAE0B,KAAD,IAAqBA,KAAK,CAACC,IAAN,CAAWC,QAAX,CAAoBM,SAA1C,CAAvD;AACA,QAAMJ,QAAQ,GAAG/B,WAAW,EAA5B;AACA,QAAMoC,YAA+C,GAAGxC,WAAW,CAChEqC,IAAD,IAAwBF,QAAQ,CAAClB,uBAAuB,CAAC;AAAEsB,IAAAA,SAAS,EAAEF;AAAb,GAAD,CAAxB,CADiC,EAEjE,CAACF,QAAD,CAFiE,CAAnE;AAIA,SAAO,CAACI,SAAD,EAAYC,YAAZ,CAAP;AACD,CARM;;IAAMF,oB;UACiCjC,W,EAC3BD,W;;;AAQnB,OAAO,MAAMqC,uBAAuB,GAAG,MAA0E;AAAA;;AAC/G,QAAMC,YAAuC,GAAGrC,WAAW,CAAE0B,KAAD,IAAqBA,KAAK,CAACC,IAAN,CAAWC,QAAX,CAAoBS,YAA1C,CAA3D;AACA,QAAMP,QAAQ,GAAG/B,WAAW,EAA5B;AACA,QAAMuC,eAAsD,GAAG3C,WAAW,CACvE4C,gBAAD,IAAqCT,QAAQ,CAACjB,0BAA0B,CAAC;AAAEwB,IAAAA,YAAY,EAAEE;AAAhB,GAAD,CAA3B,CAD2B,EAExE,CAACT,QAAD,CAFwE,CAA1E;AAIA,SAAO,CAACO,YAAD,EAAeC,eAAf,CAAP;AACD,CARM,C,CAUP;;IAVaF,uB;UACqCpC,W,EAC/BD,W;;;AAUnB,OAAO,MAAMyC,cAAc,GAAG,MAEzB;AAAA;;AACH,SAAOxC,WAAW,CAAE0B,KAAD,IAAqBA,KAAK,CAACC,IAAN,CAAWc,KAAX,CAAiBC,SAAvC,CAAlB;AACD,CAJM;;IAAMF,c;UAGJxC,W;;;AAGT,OAAO,MAAM2C,iBAAiB,GAAG,MAAqC;AAAA;;AACpE,QAAMb,QAAQ,GAAG/B,WAAW,EAA5B;AACA,SAAOJ,WAAW,CAAE8C,KAAD,IAAuBX,QAAQ,CAAChB,cAAc,CAAC;AAAE2B,IAAAA;AAAF,GAAD,CAAf,CAAhC,EAA6D,CAACX,QAAD,CAA7D,CAAlB;AACD,CAHM;;IAAMa,iB;UACM5C,W;;;AAInB,OAAO,MAAM6C,cAAc,GAAG,MAAuC;AAAA;;AACnE,QAAMd,QAAQ,GAAG/B,WAAW,EAA5B;AACA,SAAOJ,WAAW,CAAEkD,aAAD,IAA6Bf,QAAQ,CAACf,WAAW,CAAC;AAAE8B,IAAAA;AAAF,GAAD,CAAZ,CAAtC,EAAwE,CAACf,QAAD,CAAxE,CAAlB;AACD,CAHM;;IAAMc,c;UACM7C,W;;;AAInB,OAAO,MAAM+C,YAAY,GAAID,aAAD,IAAyC;AAAA;;AACnE,QAAME,WAAW,GAAGP,cAAc,EAAlC;AACA,QAAMQ,cAAc,GAAGJ,cAAc,EAArC;AAEA,QAAMK,kBAAkB,GAAGJ,aAAa,CAACK,MAAd,CAAqB,CAACC,KAAD,EAAkBC,OAAlB,KAA8B;AAC5E,QAAI,CAACC,MAAM,CAACC,IAAP,CAAYP,WAAZ,EAAyBQ,QAAzB,CAAkCH,OAAlC,CAAL,EAAiD;AAC/CD,MAAAA,KAAK,CAACK,IAAN,CAAWJ,OAAX;AACD;;AACD,WAAOD,KAAP;AACD,GAL0B,EAKxB,EALwB,CAA3B;AAOAvD,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIqD,kBAAJ,EAAwB;AACtBD,MAAAA,cAAc,CAACC,kBAAD,CAAd;AACD;AACF,GAJQ,EAIN,CAACD,cAAD,EAAiBC,kBAAjB,CAJM,CAAT;AAMA,QAAMQ,aAAa,GAAGZ,aAAa,CAChCa,GADmB,CACdN,OAAD,IAAa;AAAA;;AAChB,mCAAOL,WAAW,CAACK,OAAD,CAAlB,yDAAO,qBAAsBpB,IAA7B;AACD,GAHmB,EAInB2B,MAJmB,CAIXC,IAAD,IAAUA,IAJE,CAAtB;AAMA,SAAOH,aAAP;AACD,CAxBM;;IAAMX,Y;UACSN,c,EACGI,c;;;AAwBzB,OAAO,MAAMiB,gBAAgB,GAAIT,OAAD,IAA+C;AAAA;;AAC7E,QAAMtB,QAAQ,GAAG/B,WAAW,EAA5B;AACA,QAAM6D,IAAI,GAAG5D,WAAW,CAAE0B,KAAD,IAAqBA,KAAK,CAACC,IAAN,CAAWc,KAAX,CAAiBC,SAAjB,CAA2BU,OAA3B,CAAtB,CAAxB;AACA,QAAMlB,SAAS,GAAG0B,IAAH,aAAGA,IAAH,uBAAGA,IAAI,CAAE1B,SAAxB;AACA,QAAM,CAAC4B,KAAD,EAAQC,QAAR,IAAoBlE,QAAQ,CAAC,KAAD,CAAlC;AAEAD,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMoE,KAAK,GAAG,YAAY;AACxB,YAAM;AAAEF,QAAAA,KAAK,EAAEG,UAAT;AAAqBjC,QAAAA;AAArB,UAA8B,MAAM3B,kBAAkB,CAAC+C,OAAD,CAA5D;;AACA,UAAI,CAACa,UAAD,IAAejC,IAAnB,EAAyB;AACvBF,QAAAA,QAAQ,CAACd,mBAAmB,CAAC;AAAEkD,UAAAA,WAAW,EAAEd,OAAf;AAAwBlB,UAAAA,SAAS,EAAEF;AAAnC,SAAD,CAApB,CAAR;AACD;;AACD,UAAIiC,UAAJ,EAAgB;AACdF,QAAAA,QAAQ,CAACE,UAAD,CAAR;AACD;AACF,KARD;;AASA,QAAI,CAAC/B,SAAD,IAAc,CAAC4B,KAAnB,EAA0B;AACxBE,MAAAA,KAAK;AACN;AACF,GAbQ,EAaN,CAACZ,OAAD,EAAUtB,QAAV,EAAoBgC,KAApB,EAA2B5B,SAA3B,CAbM,CAAT;AAeA,SAAOA,SAAP;AACD,CAtBM;;IAAM2B,gB;UACM9D,W,EACJC,W;;;AAsBf,OAAO,MAAMmE,mBAAmB,GAAIf,OAAD,IAAgD;AAAA;;AACjF,QAAMtB,QAAQ,GAAG/B,WAAW,EAA5B;AACA,QAAM6D,IAAI,GAAG5D,WAAW,CAAE0B,KAAD,IAAqBA,KAAK,CAACC,IAAN,CAAWc,KAAX,CAAiBC,SAAjB,CAA2BU,OAA3B,CAAtB,CAAxB;AACA,QAAMf,YAAY,GAAGuB,IAAH,aAAGA,IAAH,uBAAGA,IAAI,CAAEvB,YAA3B;AACA,QAAM,CAACyB,KAAD,EAAQC,QAAR,IAAoBlE,QAAQ,CAAC,KAAD,CAAlC;AAEAD,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMoE,KAAK,GAAG,YAAY;AACxB,YAAM;AAAEF,QAAAA,KAAK,EAAEG,UAAT;AAAqBjC,QAAAA;AAArB,UAA8B,MAAM1B,qBAAqB,CAAC8C,OAAD,CAA/D;;AACA,UAAIa,UAAJ,EAAgB;AACdF,QAAAA,QAAQ,CAAC,IAAD,CAAR;AACD,OAFD,MAEO;AACLjC,QAAAA,QAAQ,CAACb,sBAAsB,CAAC;AAAEiD,UAAAA,WAAW,EAAEd,OAAf;AAAwBf,UAAAA,YAAY,EAAEL;AAAtC,SAAD,CAAvB,CAAR;AACD;AACF,KAPD;;AAQA,QAAI,CAACK,YAAD,IAAiB,CAACyB,KAAtB,EAA6B;AAC3BE,MAAAA,KAAK;AACN;AACF,GAZQ,EAYN,CAACZ,OAAD,EAAUtB,QAAV,EAAoBgC,KAApB,EAA2BzB,YAA3B,CAZM,CAAT;AAcA,SAAOA,YAAP;AACD,CArBM,C,CAuBP;;IAvBa8B,mB;UACMpE,W,EACJC,W;;;AAuBf,OAAO,MAAMoE,eAAe,GAAG,MAE1B;AAAA;;AACH,SAAOpE,WAAW,CAAE0B,KAAD,IAAqBA,KAAK,CAACC,IAAN,CAAW0C,MAAX,CAAkB3B,SAAxC,CAAlB;AACD,CAJM;;KAAM0B,e;UAGJpE,W;;;AAGT,OAAO,MAAMsE,kBAAkB,GAAG,MAAuC;AAAA;;AACvE,QAAMxC,QAAQ,GAAG/B,WAAW,EAA5B;AACA,SAAOJ,WAAW,CACf0E,MAAD,IAAyB;AACvBvC,IAAAA,QAAQ,CAACZ,eAAe,CAAC;AAAEmD,MAAAA;AAAF,KAAD,CAAhB,CAAR;AACD,GAHe,EAIhB,CAACvC,QAAD,CAJgB,CAAlB;AAMD,CARM;;KAAMwC,kB;UACMvE,W;;;AASnB,OAAO,MAAMwE,eAAe,GAAG,MAAuC;AAAA;;AACpE,QAAMzC,QAAQ,GAAG/B,WAAW,EAA5B;AACA,SAAOJ,WAAW,CAAE6E,cAAD,IAA8B1C,QAAQ,CAACX,YAAY,CAAC;AAAEqD,IAAAA;AAAF,GAAD,CAAb,CAAvC,EAA2E,CAAC1C,QAAD,CAA3E,CAAlB;AACD,CAHM;;KAAMyC,e;UACMxE,W;;;AAInB,OAAO,MAAM0E,aAAa,GAAIC,SAAD,IAAmD;AAAA;;AAC9E,QAAMC,YAAY,GAAGP,eAAe,EAApC;AACA,QAAMQ,eAAe,GAAGL,eAAe,EAAvC,CAF8E,CAI9E;;AACAG,EAAAA,SAAS,SAAT,IAAAA,SAAS,WAAT,YAAAA,SAAS,CAAEG,OAAX,CAAoBC,CAAD,IAAO;AACxB,QAAI,CAACH,YAAY,CAACG,CAAD,CAAjB,EAAsB;AACpBF,MAAAA,eAAe,CAAC,CAACE,CAAD,CAAD,CAAf;AACD;AACF,GAJD;AAMA,QAAMC,cAAc,GAAGjF,OAAO,CAAC,MAAM;AACnC,QAAI,CAAC4E,SAAL,EAAgB;AACd,aAAOM,SAAP;AACD;;AACD,WAAON,SAAS,CACbhB,GADI,CACCoB,CAAD,IAAO;AAAA;;AACV,gCAAOH,YAAY,CAACG,CAAD,CAAnB,oDAAO,gBAAiB9C,IAAxB;AACD,KAHI,EAIJ2B,MAJI,CAIIsB,KAAD,IAAWA,KAJd,CAAP;AAKD,GAT6B,EAS3B,CAACP,SAAD,EAAYC,YAAZ,CAT2B,CAA9B;AAWA,SAAOI,cAAP;AACD,CAvBM;;KAAMN,a;UACUL,e,EACGG,e;;;AAuB1B,OAAO,MAAMW,YAAY,GAAI9B,OAAD,IAAwD;AAAA;;AAAA;;AAClF,QAAMuB,YAAY,GAAGP,eAAe,EAApC;AACA,QAAMQ,eAAe,GAAGL,eAAe,EAAvC;;AAEA,MAAI,CAACnB,OAAD,IAAY,CAAChD,SAAS,CAACgD,OAAD,CAA1B,EAAqC;AACnC,WAAO4B,SAAP;AACD,GANiF,CAQlF;;;AACA,MAAI,CAACL,YAAY,CAACvB,OAAD,CAAjB,EAA4B;AAC1BwB,IAAAA,eAAe,CAAC,CAACxB,OAAD,CAAD,CAAf;AACD;;AAED,kCAAOuB,YAAY,CAACvB,OAAD,CAAnB,0DAAO,sBAAuBpB,IAA9B;AACD,CAdM;;KAAMkD,Y;UACUd,e,EACGG,e;;;AAc1B,OAAO,MAAMY,gBAAgB,GAAI/B,OAAD,IAA2C;AAAA;;AACzE,QAAMtB,QAAQ,GAAG/B,WAAW,EAA5B;AACA,QAAMkF,KAAK,GAAGjF,WAAW,CAAE0B,KAAD,IAAqBA,KAAK,CAACC,IAAN,CAAW0C,MAAX,CAAkB3B,SAAlB,CAA4BU,OAA5B,CAAtB,CAAzB;AACA,QAAMgC,aAAa,GAAGH,KAAK,CAACpC,aAA5B;AACA,QAAM,CAACiB,KAAD,EAAQC,QAAR,IAAoBlE,QAAQ,CAAC,KAAD,CAAlC;AAEAD,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMoE,KAAK,GAAG,YAAY;AACxB,YAAM;AAAEF,QAAAA,KAAK,EAAEG,UAAT;AAAqBS,QAAAA;AAArB,UAAmC,MAAMhE,kBAAkB,CAAC0C,OAAD,CAAjE;;AACA,UAAI,CAACa,UAAD,IAAeS,SAAnB,EAA8B;AAC5B5C,QAAAA,QAAQ,CAACV,qBAAqB,CAAC;AAAEiE,UAAAA,YAAY,EAAEjC,OAAhB;AAAyBP,UAAAA,aAAa,EAAE6B;AAAxC,SAAD,CAAtB,CAAR;AACD;;AACD,UAAIT,UAAJ,EAAgB;AACdF,QAAAA,QAAQ,CAACE,UAAD,CAAR;AACD;AACF,KARD;;AASA,QAAI,CAACmB,aAAD,IAAkB,CAACtB,KAAvB,EAA8B;AAC5BE,MAAAA,KAAK;AACN;AACF,GAbQ,EAaN,CAACZ,OAAD,EAAUtB,QAAV,EAAoBgC,KAApB,EAA2BsB,aAA3B,CAbM,CAAT;AAeA,SAAOA,aAAP;AACD,CAtBM;;KAAMD,gB;UACMpF,W,EACHC,W;;;AAsBhB,OAAO,MAAMsF,iBAAiB,GAAIlC,OAAD,IAA+C;AAAA;;AAC9E,QAAMtB,QAAQ,GAAG/B,WAAW,EAA5B;AACA,QAAMkF,KAAK,GAAGjF,WAAW,CAAE0B,KAAD,IAAqBA,KAAK,CAACC,IAAN,CAAW0C,MAAX,CAAkB3B,SAAlB,CAA4BU,OAA5B,CAAtB,CAAzB;AACA,QAAM;AAAElB,IAAAA;AAAF,MAAgB+C,KAAtB;AACA,QAAM,CAACnB,KAAD,EAAQC,QAAR,IAAoBlE,QAAQ,CAAC,KAAD,CAAlC;AAEAD,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMoE,KAAK,GAAG,YAAY;AACxB,YAAM;AAAEF,QAAAA,KAAK,EAAEG,UAAT;AAAqBjC,QAAAA;AAArB,UAA8B,MAAMzB,mBAAmB,CAAC6C,OAAD,CAA7D;;AACA,UAAI,CAACa,UAAD,IAAejC,IAAnB,EAAyB;AACvBF,QAAAA,QAAQ,CAACT,oBAAoB,CAAC;AAAEgE,UAAAA,YAAY,EAAEjC,OAAhB;AAAyBlB,UAAAA,SAAS,EAAEF;AAApC,SAAD,CAArB,CAAR;AACD;;AACD,UAAIiC,UAAJ,EAAgB;AACdF,QAAAA,QAAQ,CAACE,UAAD,CAAR;AACD;AACF,KARD;;AASA,QAAI,CAAC/B,SAAD,IAAc,CAAC4B,KAAnB,EAA0B;AACxBE,MAAAA,KAAK;AACN;AACF,GAbQ,EAaN,CAACZ,OAAD,EAAUtB,QAAV,EAAoBgC,KAApB,EAA2B5B,SAA3B,CAbM,CAAT;AAeA,SAAOA,SAAP;AACD,CAtBM;;KAAMoD,iB;UACMvF,W,EACHC,W;;;AAsBhB,OAAO,MAAMuF,iBAAiB,GAAG,CAC/BnC,OAD+B,EAE/BoC,QAF+B,EAG/BC,UAH+B,KAIG;AAAA;;AAClC,QAAM3D,QAAQ,GAAG/B,WAAW,EAA5B;AACA,QAAMkF,KAAK,GAAGjF,WAAW,CAAE0B,KAAD,IAAqBA,KAAK,CAACC,IAAN,CAAW0C,MAAX,CAAkB3B,SAAlB,CAA4BU,OAA5B,CAAtB,CAAzB;AACA,QAAMsC,SAAS,GAAGT,KAAK,CAACS,SAAN,CAAgBF,QAAhB,CAAlB;AACA,QAAM,CAAC1B,KAAD,EAAQC,QAAR,IAAoBlE,QAAQ,CAAC,KAAD,CAAlC,CAJkC,CAMlC;;AACA,QAAM8F,sBAAsB,GAAGV,KAAK,CAACS,SAAN,CAAgBE,sBAA/C;AACA,QAAMC,cAAc,GAAG5F,WAAW,CAAC,IAAI6F,IAAJ,EAAD,CAAX,GAA0B,IAAjD;AACA,QAAMC,cAAc,GAAG9F,WAAW,CAACC,WAAW,CAACC,GAAG,CAAC0F,cAAD,EAAiBJ,UAAjB,CAAJ,CAAZ,CAAlC;AAEA7F,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMoE,KAAK,GAAG,YAAY;AACxB,YAAM;AAAEhC,QAAAA,IAAF;AAAQ8B,QAAAA,KAAK,EAAEkC;AAAf,UAAiC,MAAMvF,mBAAmB,CAAC2C,OAAD,EAAUoC,QAAV,EAAoBO,cAApB,CAAhE;;AACA,UAAI/D,IAAJ,EAAU;AACRF,QAAAA,QAAQ,CACNR,oBAAoB,CAAC;AACnB+D,UAAAA,YAAY,EAAEjC,OADK;AAEnB6C,UAAAA,eAAe,EAAET,QAFE;AAGnBE,UAAAA,SAAS,EAAE1D,IAHQ;AAInB4D,UAAAA,sBAAsB,EAAEG;AAJL,SAAD,CADd,CAAR;AAQD;;AACD,UAAIC,aAAJ,EAAmB;AACjBjC,QAAAA,QAAQ,CAAC,IAAD,CAAR;AACD;AACF,KAfD;;AAgBA,QAAI,CAAC2B,SAAD,IAAc,CAAC5B,KAAnB,EAA0B;AACxBE,MAAAA,KAAK;AACN;AACF,GApBQ,EAoBN,CAACZ,OAAD,EAAUtB,QAAV,EAAoBgC,KAApB,EAA2B0B,QAA3B,EAAqCG,sBAArC,EAA6DD,SAA7D,EAAwEK,cAAxE,EAAwFN,UAAxF,CApBM,CAAT;AAsBA,SAAOC,SAAP;AACD,CAtCM;;KAAMH,iB;UAKMxF,W,EACHC,W;;;AAkChB,OAAO,MAAMkG,oBAAoB,GAAI9C,OAAD,IAAgD;AAAA;;AAClF,QAAMtB,QAAQ,GAAG/B,WAAW,EAA5B;AACA,QAAMkF,KAAK,GAAGjF,WAAW,CAAE0B,KAAD,IAAqBA,KAAK,CAACC,IAAN,CAAW0C,MAAX,CAAkB3B,SAAlB,CAA4BU,OAA5B,CAAtB,CAAzB;AACA,QAAM;AAAEf,IAAAA;AAAF,MAAmB4C,KAAzB;AACA,QAAM,CAACnB,KAAD,EAAQC,QAAR,IAAoBlE,QAAQ,CAAC,KAAD,CAAlC;AAEAD,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMoE,KAAK,GAAG,YAAY;AACxB,YAAM;AAAEF,QAAAA,KAAK,EAAEG,UAAT;AAAqBjC,QAAAA;AAArB,UAA8B,MAAMxB,sBAAsB,CAAC4C,OAAD,CAAhE;;AACA,UAAIa,UAAJ,EAAgB;AACdF,QAAAA,QAAQ,CAAC,IAAD,CAAR;AACD,OAFD,MAEO,IAAI/B,IAAJ,EAAU;AACfF,QAAAA,QAAQ,CAACP,uBAAuB,CAAC;AAAE8D,UAAAA,YAAY,EAAEjC,OAAhB;AAAyBf,UAAAA,YAAY,EAAEL;AAAvC,SAAD,CAAxB,CAAR;AACD;AACF,KAPD;;AAQA,QAAI,CAACK,YAAD,IAAiB,CAACyB,KAAtB,EAA6B;AAC3BE,MAAAA,KAAK;AACN;AACF,GAZQ,EAYN,CAACZ,OAAD,EAAUtB,QAAV,EAAoBgC,KAApB,EAA2BzB,YAA3B,CAZM,CAAT;AAcA,SAAOA,YAAP;AACD,CArBM;;KAAM6D,oB;UACMnG,W,EACHC,W","sourcesContent":["import { useCallback, useEffect, useState, useMemo } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport { getUnixTime, startOfHour, Duration, sub } from 'date-fns'\nimport { AppState, AppDispatch } from 'state'\nimport { isAddress } from 'utils'\nimport { Transaction } from 'state/info/types'\nimport fetchPoolChartData from 'state/info/queries/pools/chartData'\nimport fetchPoolTransactions from 'state/info/queries/pools/transactions'\nimport fetchTokenChartData from 'state/info/queries/tokens/chartData'\nimport fetchTokenTransactions from 'state/info/queries/tokens/transactions'\nimport fetchTokenPriceData from 'state/info/queries/tokens/priceData'\nimport fetchPoolsForToken from 'state/info/queries/tokens/poolsForToken'\nimport {\n  updateProtocolData,\n  updateProtocolChartData,\n  updateProtocolTransactions,\n  updatePoolData,\n  addPoolKeys,\n  updatePoolChartData,\n  updatePoolTransactions,\n  updateTokenData,\n  addTokenKeys,\n  addTokenPoolAddresses,\n  updateTokenChartData,\n  updateTokenPriceData,\n  updateTokenTransactions,\n} from './actions'\nimport { ProtocolData, PoolData, TokenData, ChartEntry, PriceChartEntry } from './types'\n\n// Protocol hooks\n\nexport const useProtocolData = (): [ProtocolData | undefined, (protocolData: ProtocolData) => void] => {\n  const protocolData: ProtocolData | undefined = useSelector((state: AppState) => state.info.protocol.overview)\n\n  const dispatch = useDispatch<AppDispatch>()\n  const setProtocolData: (protocolData: ProtocolData) => void = useCallback(\n    (data: ProtocolData) => dispatch(updateProtocolData({ protocolData: data })),\n    [dispatch],\n  )\n\n  return [protocolData, setProtocolData]\n}\n\nexport const useProtocolChartData = (): [ChartEntry[] | undefined, (chartData: ChartEntry[]) => void] => {\n  const chartData: ChartEntry[] | undefined = useSelector((state: AppState) => state.info.protocol.chartData)\n  const dispatch = useDispatch<AppDispatch>()\n  const setChartData: (chartData: ChartEntry[]) => void = useCallback(\n    (data: ChartEntry[]) => dispatch(updateProtocolChartData({ chartData: data })),\n    [dispatch],\n  )\n  return [chartData, setChartData]\n}\n\nexport const useProtocolTransactions = (): [Transaction[] | undefined, (transactions: Transaction[]) => void] => {\n  const transactions: Transaction[] | undefined = useSelector((state: AppState) => state.info.protocol.transactions)\n  const dispatch = useDispatch<AppDispatch>()\n  const setTransactions: (transactions: Transaction[]) => void = useCallback(\n    (transactionsData: Transaction[]) => dispatch(updateProtocolTransactions({ transactions: transactionsData })),\n    [dispatch],\n  )\n  return [transactions, setTransactions]\n}\n\n// Pools hooks\n\nexport const useAllPoolData = (): {\n  [address: string]: { data?: PoolData }\n} => {\n  return useSelector((state: AppState) => state.info.pools.byAddress)\n}\n\nexport const useUpdatePoolData = (): ((pools: PoolData[]) => void) => {\n  const dispatch = useDispatch<AppDispatch>()\n  return useCallback((pools: PoolData[]) => dispatch(updatePoolData({ pools })), [dispatch])\n}\n\nexport const useAddPoolKeys = (): ((addresses: string[]) => void) => {\n  const dispatch = useDispatch<AppDispatch>()\n  return useCallback((poolAddresses: string[]) => dispatch(addPoolKeys({ poolAddresses })), [dispatch])\n}\n\nexport const usePoolDatas = (poolAddresses: string[]): PoolData[] => {\n  const allPoolData = useAllPoolData()\n  const addNewPoolKeys = useAddPoolKeys()\n\n  const untrackedAddresses = poolAddresses.reduce((accum: string[], address) => {\n    if (!Object.keys(allPoolData).includes(address)) {\n      accum.push(address)\n    }\n    return accum\n  }, [])\n\n  useEffect(() => {\n    if (untrackedAddresses) {\n      addNewPoolKeys(untrackedAddresses)\n    }\n  }, [addNewPoolKeys, untrackedAddresses])\n\n  const poolsWithData = poolAddresses\n    .map((address) => {\n      return allPoolData[address]?.data\n    })\n    .filter((pool) => pool)\n\n  return poolsWithData\n}\n\nexport const usePoolChartData = (address: string): ChartEntry[] | undefined => {\n  const dispatch = useDispatch<AppDispatch>()\n  const pool = useSelector((state: AppState) => state.info.pools.byAddress[address])\n  const chartData = pool?.chartData\n  const [error, setError] = useState(false)\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { error: fetchError, data } = await fetchPoolChartData(address)\n      if (!fetchError && data) {\n        dispatch(updatePoolChartData({ poolAddress: address, chartData: data }))\n      }\n      if (fetchError) {\n        setError(fetchError)\n      }\n    }\n    if (!chartData && !error) {\n      fetch()\n    }\n  }, [address, dispatch, error, chartData])\n\n  return chartData\n}\n\nexport const usePoolTransactions = (address: string): Transaction[] | undefined => {\n  const dispatch = useDispatch<AppDispatch>()\n  const pool = useSelector((state: AppState) => state.info.pools.byAddress[address])\n  const transactions = pool?.transactions\n  const [error, setError] = useState(false)\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { error: fetchError, data } = await fetchPoolTransactions(address)\n      if (fetchError) {\n        setError(true)\n      } else {\n        dispatch(updatePoolTransactions({ poolAddress: address, transactions: data }))\n      }\n    }\n    if (!transactions && !error) {\n      fetch()\n    }\n  }, [address, dispatch, error, transactions])\n\n  return transactions\n}\n\n// Tokens hooks\n\nexport const useAllTokenData = (): {\n  [address: string]: { data?: TokenData }\n} => {\n  return useSelector((state: AppState) => state.info.tokens.byAddress)\n}\n\nexport const useUpdateTokenData = (): ((tokens: TokenData[]) => void) => {\n  const dispatch = useDispatch<AppDispatch>()\n  return useCallback(\n    (tokens: TokenData[]) => {\n      dispatch(updateTokenData({ tokens }))\n    },\n    [dispatch],\n  )\n}\n\nexport const useAddTokenKeys = (): ((addresses: string[]) => void) => {\n  const dispatch = useDispatch<AppDispatch>()\n  return useCallback((tokenAddresses: string[]) => dispatch(addTokenKeys({ tokenAddresses })), [dispatch])\n}\n\nexport const useTokenDatas = (addresses?: string[]): TokenData[] | undefined => {\n  const allTokenData = useAllTokenData()\n  const addNewTokenKeys = useAddTokenKeys()\n\n  // if token not tracked yet track it\n  addresses?.forEach((a) => {\n    if (!allTokenData[a]) {\n      addNewTokenKeys([a])\n    }\n  })\n\n  const tokensWithData = useMemo(() => {\n    if (!addresses) {\n      return undefined\n    }\n    return addresses\n      .map((a) => {\n        return allTokenData[a]?.data\n      })\n      .filter((token) => token)\n  }, [addresses, allTokenData])\n\n  return tokensWithData\n}\n\nexport const useTokenData = (address: string | undefined): TokenData | undefined => {\n  const allTokenData = useAllTokenData()\n  const addNewTokenKeys = useAddTokenKeys()\n\n  if (!address || !isAddress(address)) {\n    return undefined\n  }\n\n  // if token not tracked yet track it\n  if (!allTokenData[address]) {\n    addNewTokenKeys([address])\n  }\n\n  return allTokenData[address]?.data\n}\n\nexport const usePoolsForToken = (address: string): string[] | undefined => {\n  const dispatch = useDispatch<AppDispatch>()\n  const token = useSelector((state: AppState) => state.info.tokens.byAddress[address])\n  const poolsForToken = token.poolAddresses\n  const [error, setError] = useState(false)\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { error: fetchError, addresses } = await fetchPoolsForToken(address)\n      if (!fetchError && addresses) {\n        dispatch(addTokenPoolAddresses({ tokenAddress: address, poolAddresses: addresses }))\n      }\n      if (fetchError) {\n        setError(fetchError)\n      }\n    }\n    if (!poolsForToken && !error) {\n      fetch()\n    }\n  }, [address, dispatch, error, poolsForToken])\n\n  return poolsForToken\n}\n\nexport const useTokenChartData = (address: string): ChartEntry[] | undefined => {\n  const dispatch = useDispatch<AppDispatch>()\n  const token = useSelector((state: AppState) => state.info.tokens.byAddress[address])\n  const { chartData } = token\n  const [error, setError] = useState(false)\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { error: fetchError, data } = await fetchTokenChartData(address)\n      if (!fetchError && data) {\n        dispatch(updateTokenChartData({ tokenAddress: address, chartData: data }))\n      }\n      if (fetchError) {\n        setError(fetchError)\n      }\n    }\n    if (!chartData && !error) {\n      fetch()\n    }\n  }, [address, dispatch, error, chartData])\n\n  return chartData\n}\n\nexport const useTokenPriceData = (\n  address: string,\n  interval: number,\n  timeWindow: Duration,\n): PriceChartEntry[] | undefined => {\n  const dispatch = useDispatch<AppDispatch>()\n  const token = useSelector((state: AppState) => state.info.tokens.byAddress[address])\n  const priceData = token.priceData[interval]\n  const [error, setError] = useState(false)\n\n  // construct timestamps and check if we need to fetch more data\n  const oldestTimestampFetched = token.priceData.oldestFetchedTimestamp\n  const utcCurrentTime = getUnixTime(new Date()) * 1000\n  const startTimestamp = getUnixTime(startOfHour(sub(utcCurrentTime, timeWindow)))\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { data, error: fetchingError } = await fetchTokenPriceData(address, interval, startTimestamp)\n      if (data) {\n        dispatch(\n          updateTokenPriceData({\n            tokenAddress: address,\n            secondsInterval: interval,\n            priceData: data,\n            oldestFetchedTimestamp: startTimestamp,\n          }),\n        )\n      }\n      if (fetchingError) {\n        setError(true)\n      }\n    }\n    if (!priceData && !error) {\n      fetch()\n    }\n  }, [address, dispatch, error, interval, oldestTimestampFetched, priceData, startTimestamp, timeWindow])\n\n  return priceData\n}\n\nexport const useTokenTransactions = (address: string): Transaction[] | undefined => {\n  const dispatch = useDispatch<AppDispatch>()\n  const token = useSelector((state: AppState) => state.info.tokens.byAddress[address])\n  const { transactions } = token\n  const [error, setError] = useState(false)\n\n  useEffect(() => {\n    const fetch = async () => {\n      const { error: fetchError, data } = await fetchTokenTransactions(address)\n      if (fetchError) {\n        setError(true)\n      } else if (data) {\n        dispatch(updateTokenTransactions({ tokenAddress: address, transactions: data }))\n      }\n    }\n    if (!transactions && !error) {\n      fetch()\n    }\n  }, [address, dispatch, error, transactions])\n\n  return transactions\n}\n"]},"metadata":{},"sourceType":"module"}